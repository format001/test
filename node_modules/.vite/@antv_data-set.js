import {
  esm_exports,
  init_esm,
  require_tslib
} from "./chunk-6GKUK2M2.js";
import {
  require_baseMap,
  require_castFunction,
  require_cloneDeep,
  require_isString,
  require_map
} from "./chunk-7I7ORBRD.js";
import {
  require_baseEach,
  require_baseForOwn,
  require_baseIteratee,
  require_baseProperty,
  require_hasIn
} from "./chunk-Q4RCBYUD.js";
import {
  require_baseFlatten,
  require_baseRest,
  require_baseSet,
  require_constant,
  require_flatRest,
  require_flatten,
  require_has,
  require_isArrayLikeObject,
  require_isIterateeCall,
  require_last,
  require_merge,
  require_now,
  require_toNumber
} from "./chunk-U7TDB76L.js";
import "./chunk-KCJINVUJ.js";
import {
  require_arrayEach,
  require_assignValue,
  require_baseClone,
  require_baseCreate,
  require_getPrototype,
  require_keysIn
} from "./chunk-2XCTJ7RW.js";
import {
  require_Set,
  require_SetCache,
  require_arrayFilter,
  require_arrayMap,
  require_baseAssignValue,
  require_baseFor,
  require_baseGet,
  require_baseKeys,
  require_baseUnary,
  require_cacheHas,
  require_castPath,
  require_eq,
  require_getTag,
  require_identity,
  require_isArguments,
  require_isArray,
  require_isArrayLike,
  require_isBuffer,
  require_isFunction,
  require_isObject,
  require_isPrototype,
  require_isSymbol,
  require_isTypedArray,
  require_keys,
  require_setToArray,
  require_toString
} from "./chunk-HDUQK43G.js";
import {
  require_isarray
} from "./chunk-VJF5YM3T.js";
import {
  __commonJS,
  __esm,
  __export,
  __require
} from "./chunk-XKRUNJNY.js";

// node_modules/d3-geo/src/adder.js
function adder_default() {
  return new Adder();
}
function Adder() {
  this.reset();
}
function add(adder, a3, b2) {
  var x4 = adder.s = a3 + b2, bv = x4 - a3, av = x4 - bv;
  adder.t = a3 - av + (b2 - bv);
}
var temp;
var init_adder = __esm({
  "node_modules/d3-geo/src/adder.js"() {
    Adder.prototype = {
      constructor: Adder,
      reset: function() {
        this.s = this.t = 0;
      },
      add: function(y4) {
        add(temp, y4, this.t);
        add(this, temp.s, this.s);
        if (this.s)
          this.t += temp.t;
        else
          this.s = temp.t;
      },
      valueOf: function() {
        return this.s;
      }
    };
    temp = new Adder();
  }
});

// node_modules/d3-geo/src/math.js
function acos(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi : Math.acos(x4);
}
function asin(x4) {
  return x4 > 1 ? halfPi : x4 < -1 ? -halfPi : Math.asin(x4);
}
function haversin(x4) {
  return (x4 = sin(x4 / 2)) * x4;
}
var epsilon, epsilon2, pi, halfPi, quarterPi, tau, degrees, radians, abs, atan, atan2, cos, ceil, exp, log, pow, sin, sign, sqrt, tan;
var init_math = __esm({
  "node_modules/d3-geo/src/math.js"() {
    epsilon = 1e-6;
    epsilon2 = 1e-12;
    pi = Math.PI;
    halfPi = pi / 2;
    quarterPi = pi / 4;
    tau = pi * 2;
    degrees = 180 / pi;
    radians = pi / 180;
    abs = Math.abs;
    atan = Math.atan;
    atan2 = Math.atan2;
    cos = Math.cos;
    ceil = Math.ceil;
    exp = Math.exp;
    log = Math.log;
    pow = Math.pow;
    sin = Math.sin;
    sign = Math.sign || function(x4) {
      return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;
    };
    sqrt = Math.sqrt;
    tan = Math.tan;
  }
});

// node_modules/d3-geo/src/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/d3-geo/src/noop.js"() {
  }
});

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
function streamLine(coordinates2, stream, closed) {
  var i2 = -1, n2 = coordinates2.length - closed, coordinate;
  stream.lineStart();
  while (++i2 < n2)
    coordinate = coordinates2[i2], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates2, stream) {
  var i2 = -1, n2 = coordinates2.length;
  stream.polygonStart();
  while (++i2 < n2)
    streamLine(coordinates2[i2], stream, 1);
  stream.polygonEnd();
}
function stream_default(object3, stream) {
  if (object3 && streamObjectType.hasOwnProperty(object3.type)) {
    streamObjectType[object3.type](object3, stream);
  } else {
    streamGeometry(object3, stream);
  }
}
var streamObjectType, streamGeometryType;
var init_stream = __esm({
  "node_modules/d3-geo/src/stream.js"() {
    streamObjectType = {
      Feature: function(object3, stream) {
        streamGeometry(object3.geometry, stream);
      },
      FeatureCollection: function(object3, stream) {
        var features = object3.features, i2 = -1, n2 = features.length;
        while (++i2 < n2)
          streamGeometry(features[i2].geometry, stream);
      }
    };
    streamGeometryType = {
      Sphere: function(object3, stream) {
        stream.sphere();
      },
      Point: function(object3, stream) {
        object3 = object3.coordinates;
        stream.point(object3[0], object3[1], object3[2]);
      },
      MultiPoint: function(object3, stream) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          object3 = coordinates2[i2], stream.point(object3[0], object3[1], object3[2]);
      },
      LineString: function(object3, stream) {
        streamLine(object3.coordinates, stream, 0);
      },
      MultiLineString: function(object3, stream) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          streamLine(coordinates2[i2], stream, 0);
      },
      Polygon: function(object3, stream) {
        streamPolygon(object3.coordinates, stream);
      },
      MultiPolygon: function(object3, stream) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          streamPolygon(coordinates2[i2], stream);
      },
      GeometryCollection: function(object3, stream) {
        var geometries = object3.geometries, i2 = -1, n2 = geometries.length;
        while (++i2 < n2)
          streamGeometry(geometries[i2], stream);
      }
    };
  }
});

// node_modules/d3-geo/src/area.js
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaRingEnd() {
  areaPoint(lambda00, phi00);
}
function areaPointFirst(lambda, phi2) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians, phi2 *= radians;
  lambda0 = lambda, cosPhi0 = cos(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin(phi2);
}
function areaPoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  phi2 = phi2 / 2 + quarterPi;
  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi2), sinPhi = sin(phi2), k4 = sinPhi0 * sinPhi, u2 = cosPhi0 * cosPhi + k4 * cos(adLambda), v2 = k4 * sdLambda * sin(adLambda);
  areaRingSum.add(atan2(v2, u2));
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}
function area_default(object3) {
  areaSum.reset();
  stream_default(object3, areaStream);
  return areaSum * 2;
}
var areaRingSum, areaSum, lambda00, phi00, lambda0, cosPhi0, sinPhi0, areaStream;
var init_area = __esm({
  "node_modules/d3-geo/src/area.js"() {
    init_adder();
    init_math();
    init_noop();
    init_stream();
    areaRingSum = adder_default();
    areaSum = adder_default();
    areaStream = {
      point: noop,
      lineStart: noop,
      lineEnd: noop,
      polygonStart: function() {
        areaRingSum.reset();
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum;
        areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop;
      },
      sphere: function() {
        areaSum.add(tau);
      }
    };
  }
});

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian5) {
  return [atan2(cartesian5[1], cartesian5[0]), asin(cartesian5[2])];
}
function cartesian(spherical5) {
  var lambda = spherical5[0], phi2 = spherical5[1], cosPhi = cos(phi2);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi2)];
}
function cartesianDot(a3, b2) {
  return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
}
function cartesianCross(a3, b2) {
  return [a3[1] * b2[2] - a3[2] * b2[1], a3[2] * b2[0] - a3[0] * b2[2], a3[0] * b2[1] - a3[1] * b2[0]];
}
function cartesianAddInPlace(a3, b2) {
  a3[0] += b2[0], a3[1] += b2[1], a3[2] += b2[2];
}
function cartesianScale(vector, k4) {
  return [vector[0] * k4, vector[1] * k4, vector[2] * k4];
}
function cartesianNormalizeInPlace(d2) {
  var l2 = sqrt(d2[0] * d2[0] + d2[1] * d2[1] + d2[2] * d2[2]);
  d2[0] /= l2, d2[1] /= l2, d2[2] /= l2;
}
var init_cartesian = __esm({
  "node_modules/d3-geo/src/cartesian.js"() {
    init_math();
  }
});

// node_modules/d3-geo/src/bounds.js
function boundsPoint(lambda, phi2) {
  ranges.push(range = [lambda02 = lambda, lambda1 = lambda]);
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
}
function linePoint(lambda, phi2) {
  var p2 = cartesian([lambda * radians, phi2 * radians]);
  if (p0) {
    var normal = cartesianCross(p0, p2), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign6 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign6, phii, antimeridian = abs(delta) > 180;
    if (antimeridian ^ (sign6 * lambda2 < lambdai && lambdai < sign6 * lambda)) {
      phii = inflection[1] * degrees;
      if (phii > phi1)
        phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign6 * lambda2 < lambdai && lambdai < sign6 * lambda)) {
      phii = -inflection[1] * degrees;
      if (phii < phi0)
        phi0 = phii;
    } else {
      if (phi2 < phi0)
        phi0 = phi2;
      if (phi2 > phi1)
        phi1 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda02, lambda) > angle(lambda02, lambda1))
          lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda02, lambda1))
          lambda02 = lambda;
      }
    } else {
      if (lambda1 >= lambda02) {
        if (lambda < lambda02)
          lambda02 = lambda;
        if (lambda > lambda1)
          lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1))
            lambda02 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda02 = lambda, lambda1 = lambda]);
  }
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
  p0 = p2, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream.point = linePoint;
}
function boundsLineEnd() {
  range[0] = lambda02, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}
function boundsRingPoint(lambda, phi2) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda002 = lambda, phi002 = phi2;
  }
  areaStream.point(lambda, phi2);
  linePoint(lambda, phi2);
}
function boundsRingStart() {
  areaStream.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda002, phi002);
  areaStream.lineEnd();
  if (abs(deltaSum) > epsilon)
    lambda02 = -(lambda1 = 180);
  range[0] = lambda02, range[1] = lambda1;
  p0 = null;
}
function angle(lambda06, lambda13) {
  return (lambda13 -= lambda06) < 0 ? lambda13 + 360 : lambda13;
}
function rangeCompare(a3, b2) {
  return a3[0] - b2[0];
}
function rangeContains(range3, x4) {
  return range3[0] <= range3[1] ? range3[0] <= x4 && x4 <= range3[1] : x4 < range3[0] || range3[1] < x4;
}
function bounds_default(feature2) {
  var i2, n2, a3, b2, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
  ranges = [];
  stream_default(feature2, boundsStream);
  if (n2 = ranges.length) {
    ranges.sort(rangeCompare);
    for (i2 = 1, a3 = ranges[0], merged = [a3]; i2 < n2; ++i2) {
      b2 = ranges[i2];
      if (rangeContains(a3, b2[0]) || rangeContains(a3, b2[1])) {
        if (angle(a3[0], b2[1]) > angle(a3[0], a3[1]))
          a3[1] = b2[1];
        if (angle(b2[0], a3[1]) > angle(a3[0], a3[1]))
          a3[0] = b2[0];
      } else {
        merged.push(a3 = b2);
      }
    }
    for (deltaMax = -Infinity, n2 = merged.length - 1, i2 = 0, a3 = merged[n2]; i2 <= n2; a3 = b2, ++i2) {
      b2 = merged[i2];
      if ((delta = angle(a3[1], b2[0])) > deltaMax)
        deltaMax = delta, lambda02 = b2[0], lambda1 = a3[1];
    }
  }
  ranges = range = null;
  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
}
var lambda02, phi0, lambda1, phi1, lambda2, lambda002, phi002, p0, deltaSum, ranges, range, boundsStream;
var init_bounds = __esm({
  "node_modules/d3-geo/src/bounds.js"() {
    init_adder();
    init_area();
    init_cartesian();
    init_math();
    init_stream();
    deltaSum = adder_default();
    boundsStream = {
      point: boundsPoint,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream.point = boundsRingPoint;
        boundsStream.lineStart = boundsRingStart;
        boundsStream.lineEnd = boundsRingEnd;
        deltaSum.reset();
        areaStream.polygonStart();
      },
      polygonEnd: function() {
        areaStream.polygonEnd();
        boundsStream.point = boundsPoint;
        boundsStream.lineStart = boundsLineStart;
        boundsStream.lineEnd = boundsLineEnd;
        if (areaRingSum < 0)
          lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon)
          phi1 = 90;
        else if (deltaSum < -epsilon)
          phi0 = -90;
        range[0] = lambda02, range[1] = lambda1;
      }
    };
  }
});

// node_modules/d3-geo/src/centroid.js
function centroidPoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos(phi2);
  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi2));
}
function centroidPointCartesian(x4, y4, z2) {
  ++W0;
  X0 += (x4 - X0) / W0;
  Y0 += (y4 - Y0) / W0;
  Z0 += (z2 - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos(phi2);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi2);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos(phi2), x4 = cosPhi * cos(lambda), y4 = cosPhi * sin(lambda), z2 = sin(phi2), w3 = atan2(sqrt((w3 = y0 * z2 - z0 * y4) * w3 + (w3 = z0 * x4 - x0 * z2) * w3 + (w3 = x0 * y4 - y0 * x4) * w3), x0 * x4 + y0 * y4 + z0 * z2);
  W1 += w3;
  X1 += w3 * (x0 + (x0 = x4));
  Y1 += w3 * (y0 + (y0 = y4));
  Z1 += w3 * (z0 + (z0 = z2));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda003, phi003);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda003 = lambda, phi003 = phi2;
  lambda *= radians, phi2 *= radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos(phi2);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi2);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos(phi2), x4 = cosPhi * cos(lambda), y4 = cosPhi * sin(lambda), z2 = sin(phi2), cx = y0 * z2 - z0 * y4, cy = z0 * x4 - x0 * z2, cz = x0 * y4 - y0 * x4, m2 = sqrt(cx * cx + cy * cy + cz * cz), w3 = asin(m2), v2 = m2 && -w3 / m2;
  X2 += v2 * cx;
  Y2 += v2 * cy;
  Z2 += v2 * cz;
  W1 += w3;
  X1 += w3 * (x0 + (x0 = x4));
  Y1 += w3 * (y0 + (y0 = y4));
  Z1 += w3 * (z0 + (z0 = z2));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object3) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
  stream_default(object3, centroidStream);
  var x4 = X2, y4 = Y2, z2 = Z2, m2 = x4 * x4 + y4 * y4 + z2 * z2;
  if (m2 < epsilon2) {
    x4 = X1, y4 = Y1, z2 = Z1;
    if (W1 < epsilon)
      x4 = X0, y4 = Y0, z2 = Z0;
    m2 = x4 * x4 + y4 * y4 + z2 * z2;
    if (m2 < epsilon2)
      return [NaN, NaN];
  }
  return [atan2(y4, x4) * degrees, asin(z2 / sqrt(m2)) * degrees];
}
var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda003, phi003, x0, y0, z0, centroidStream;
var init_centroid = __esm({
  "node_modules/d3-geo/src/centroid.js"() {
    init_math();
    init_noop();
    init_stream();
    centroidStream = {
      sphere: noop,
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      }
    };
  }
});

// node_modules/d3-geo/src/constant.js
function constant_default(x4) {
  return function() {
    return x4;
  };
}
var init_constant = __esm({
  "node_modules/d3-geo/src/constant.js"() {
  }
});

// node_modules/d3-geo/src/compose.js
function compose_default(a3, b2) {
  function compose(x4, y4) {
    return x4 = a3(x4, y4), b2(x4[0], x4[1]);
  }
  if (a3.invert && b2.invert)
    compose.invert = function(x4, y4) {
      return x4 = b2.invert(x4, y4), x4 && a3.invert(x4[0], x4[1]);
    };
  return compose;
}
var init_compose = __esm({
  "node_modules/d3-geo/src/compose.js"() {
  }
});

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi2];
}
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos(phi2), x4 = cos(lambda) * cosPhi, y4 = sin(lambda) * cosPhi, z2 = sin(phi2), k4 = z2 * cosDeltaPhi + x4 * sinDeltaPhi;
    return [
      atan2(y4 * cosDeltaGamma - k4 * sinDeltaGamma, x4 * cosDeltaPhi - z2 * sinDeltaPhi),
      asin(k4 * cosDeltaGamma + y4 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos(phi2), x4 = cos(lambda) * cosPhi, y4 = sin(lambda) * cosPhi, z2 = sin(phi2), k4 = z2 * cosDeltaGamma - y4 * sinDeltaGamma;
    return [
      atan2(y4 * cosDeltaGamma + z2 * sinDeltaGamma, x4 * cosDeltaPhi + k4 * sinDeltaPhi),
      asin(k4 * cosDeltaPhi - x4 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
  function forward(coordinates2) {
    coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
    return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
  }
  forward.invert = function(coordinates2) {
    coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
    return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
  };
  return forward;
}
var init_rotation = __esm({
  "node_modules/d3-geo/src/rotation.js"() {
    init_compose();
    init_math();
    rotationIdentity.invert = rotationIdentity;
  }
});

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta)
    return;
  var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1)
      t0 += direction * tau;
  }
  for (var point5, t2 = t0; direction > 0 ? t2 > t1 : t2 < t1; t2 -= step) {
    point5 = spherical([cosRadius, -sinRadius * cos(t2), -sinRadius * sin(t2)]);
    stream.point(point5[0], point5[1]);
  }
}
function circleRadius(cosRadius, point5) {
  point5 = cartesian(point5), point5[0] -= cosRadius;
  cartesianNormalizeInPlace(point5);
  var radius = acos(-point5[1]);
  return ((-point5[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
}
function circle_default() {
  var center2 = constant_default([0, 0]), radius = constant_default(90), precision = constant_default(6), ring, rotate, stream = { point: point5 };
  function point5(x4, y4) {
    ring.push(x4 = rotate(x4, y4));
    x4[0] *= degrees, x4[1] *= degrees;
  }
  function circle4() {
    var c2 = center2.apply(this, arguments), r2 = radius.apply(this, arguments) * radians, p2 = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c2[0] * radians, -c2[1] * radians, 0).invert;
    circleStream(stream, r2, p2, 1);
    c2 = { type: "Polygon", coordinates: [ring] };
    ring = rotate = null;
    return c2;
  }
  circle4.center = function(_2) {
    return arguments.length ? (center2 = typeof _2 === "function" ? _2 : constant_default([+_2[0], +_2[1]]), circle4) : center2;
  };
  circle4.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default(+_2), circle4) : radius;
  };
  circle4.precision = function(_2) {
    return arguments.length ? (precision = typeof _2 === "function" ? _2 : constant_default(+_2), circle4) : precision;
  };
  return circle4;
}
var init_circle = __esm({
  "node_modules/d3-geo/src/circle.js"() {
    init_cartesian();
    init_constant();
    init_math();
    init_rotation();
  }
});

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines2 = [], line;
  return {
    point: function(x4, y4) {
      line.push([x4, y4]);
    },
    lineStart: function() {
      lines2.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines2.length > 1)
        lines2.push(lines2.pop().concat(lines2.shift()));
    },
    result: function() {
      var result = lines2;
      lines2 = [];
      line = null;
      return result;
    }
  };
}
var init_buffer = __esm({
  "node_modules/d3-geo/src/clip/buffer.js"() {
    init_noop();
  }
});

// node_modules/d3-geo/src/clip/line.js
function line_default(a3, b2, x011, y011, x16, y16) {
  var ax = a3[0], ay = a3[1], bx = b2[0], by = b2[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x011 - ax;
  if (!dx && r2 > 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  } else if (dx > 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  }
  r2 = x16 - ax;
  if (!dx && r2 < 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  } else if (dx > 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  }
  r2 = y011 - ay;
  if (!dy && r2 > 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  } else if (dy > 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  }
  r2 = y16 - ay;
  if (!dy && r2 < 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  } else if (dy > 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  }
  if (t0 > 0)
    a3[0] = ax + t0 * dx, a3[1] = ay + t0 * dy;
  if (t1 < 1)
    b2[0] = ax + t1 * dx, b2[1] = ay + t1 * dy;
  return true;
}
var init_line = __esm({
  "node_modules/d3-geo/src/clip/line.js"() {
  }
});

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a3, b2) {
  return abs(a3[0] - b2[0]) < epsilon && abs(a3[1] - b2[1]) < epsilon;
}
var init_pointEqual = __esm({
  "node_modules/d3-geo/src/pointEqual.js"() {
    init_math();
  }
});

// node_modules/d3-geo/src/clip/polygon.js
function Intersection(point5, points2, other, entry) {
  this.x = point5;
  this.z = points2;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function polygon_default(segments, compareIntersection4, startInside, interpolate, stream) {
  var subject = [], clip = [], i2, n2;
  segments.forEach(function(segment) {
    if ((n3 = segment.length - 1) <= 0)
      return;
    var n3, p03 = segment[0], p1 = segment[n3], x4;
    if (pointEqual_default(p03, p1)) {
      stream.lineStart();
      for (i2 = 0; i2 < n3; ++i2)
        stream.point((p03 = segment[i2])[0], p03[1]);
      stream.lineEnd();
      return;
    }
    subject.push(x4 = new Intersection(p03, segment, null, true));
    clip.push(x4.o = new Intersection(p03, null, x4, false));
    subject.push(x4 = new Intersection(p1, segment, null, false));
    clip.push(x4.o = new Intersection(p1, null, x4, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection4);
  link(subject);
  link(clip);
  for (i2 = 0, n2 = clip.length; i2 < n2; ++i2) {
    clip[i2].e = startInside = !startInside;
  }
  var start = subject[0], points2, point5;
  while (1) {
    var current = start, isSubject = true;
    while (current.v)
      if ((current = current.n) === start)
        return;
    points2 = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i2 = 0, n2 = points2.length; i2 < n2; ++i2)
            stream.point((point5 = points2[i2])[0], point5[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points2 = current.p.z;
          for (i2 = points2.length - 1; i2 >= 0; --i2)
            stream.point((point5 = points2[i2])[0], point5[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points2 = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array3) {
  if (!(n2 = array3.length))
    return;
  var n2, i2 = 0, a3 = array3[0], b2;
  while (++i2 < n2) {
    a3.n = b2 = array3[i2];
    b2.p = a3;
    a3 = b2;
  }
  a3.n = b2 = array3[0];
  b2.p = a3;
}
var init_polygon = __esm({
  "node_modules/d3-geo/src/clip/polygon.js"() {
    init_pointEqual();
  }
});

// node_modules/d3-array/src/ascending.js
function ascending_default(a3, b2) {
  return a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
}
var init_ascending = __esm({
  "node_modules/d3-array/src/ascending.js"() {
  }
});

// node_modules/d3-array/src/bisector.js
function bisector_default(compare) {
  if (compare.length === 1)
    compare = ascendingComparator(compare);
  return {
    left: function(a3, x4, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a3.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a3[mid], x4) < 0)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    },
    right: function(a3, x4, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a3.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a3[mid], x4) > 0)
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator(f2) {
  return function(d2, x4) {
    return ascending_default(f2(d2), x4);
  };
}
var init_bisector = __esm({
  "node_modules/d3-array/src/bisector.js"() {
    init_ascending();
  }
});

// node_modules/d3-array/src/bisect.js
var ascendingBisect, bisectRight, bisectLeft;
var init_bisect = __esm({
  "node_modules/d3-array/src/bisect.js"() {
    init_ascending();
    init_bisector();
    ascendingBisect = bisector_default(ascending_default);
    bisectRight = ascendingBisect.right;
    bisectLeft = ascendingBisect.left;
  }
});

// node_modules/d3-array/src/pairs.js
var init_pairs = __esm({
  "node_modules/d3-array/src/pairs.js"() {
  }
});

// node_modules/d3-array/src/cross.js
var init_cross = __esm({
  "node_modules/d3-array/src/cross.js"() {
    init_pairs();
  }
});

// node_modules/d3-array/src/descending.js
var init_descending = __esm({
  "node_modules/d3-array/src/descending.js"() {
  }
});

// node_modules/d3-array/src/number.js
var init_number = __esm({
  "node_modules/d3-array/src/number.js"() {
  }
});

// node_modules/d3-array/src/variance.js
var init_variance = __esm({
  "node_modules/d3-array/src/variance.js"() {
    init_number();
  }
});

// node_modules/d3-array/src/deviation.js
var init_deviation = __esm({
  "node_modules/d3-array/src/deviation.js"() {
    init_variance();
  }
});

// node_modules/d3-array/src/extent.js
var init_extent = __esm({
  "node_modules/d3-array/src/extent.js"() {
  }
});

// node_modules/d3-array/src/array.js
var array, slice, map;
var init_array = __esm({
  "node_modules/d3-array/src/array.js"() {
    array = Array.prototype;
    slice = array.slice;
    map = array.map;
  }
});

// node_modules/d3-array/src/constant.js
var init_constant2 = __esm({
  "node_modules/d3-array/src/constant.js"() {
  }
});

// node_modules/d3-array/src/identity.js
var init_identity = __esm({
  "node_modules/d3-array/src/identity.js"() {
  }
});

// node_modules/d3-array/src/range.js
function range_default(start, stop, step) {
  start = +start, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start, start = 0, 1) : n2 < 3 ? 1 : +step;
  var i2 = -1, n2 = Math.max(0, Math.ceil((stop - start) / step)) | 0, range3 = new Array(n2);
  while (++i2 < n2) {
    range3[i2] = start + i2 * step;
  }
  return range3;
}
var init_range = __esm({
  "node_modules/d3-array/src/range.js"() {
  }
});

// node_modules/d3-array/src/ticks.js
var e10, e5, e2;
var init_ticks = __esm({
  "node_modules/d3-array/src/ticks.js"() {
    e10 = Math.sqrt(50);
    e5 = Math.sqrt(10);
    e2 = Math.sqrt(2);
  }
});

// node_modules/d3-array/src/threshold/sturges.js
var init_sturges = __esm({
  "node_modules/d3-array/src/threshold/sturges.js"() {
  }
});

// node_modules/d3-array/src/histogram.js
var init_histogram = __esm({
  "node_modules/d3-array/src/histogram.js"() {
    init_array();
    init_bisect();
    init_constant2();
    init_extent();
    init_identity();
    init_range();
    init_ticks();
    init_sturges();
  }
});

// node_modules/d3-array/src/quantile.js
var init_quantile = __esm({
  "node_modules/d3-array/src/quantile.js"() {
    init_number();
  }
});

// node_modules/d3-array/src/threshold/freedmanDiaconis.js
var init_freedmanDiaconis = __esm({
  "node_modules/d3-array/src/threshold/freedmanDiaconis.js"() {
    init_array();
    init_ascending();
    init_number();
    init_quantile();
  }
});

// node_modules/d3-array/src/threshold/scott.js
var init_scott = __esm({
  "node_modules/d3-array/src/threshold/scott.js"() {
    init_deviation();
  }
});

// node_modules/d3-array/src/max.js
function max_default(values, valueof) {
  var n2 = values.length, i2 = -1, value2, max4;
  if (valueof == null) {
    while (++i2 < n2) {
      if ((value2 = values[i2]) != null && value2 >= value2) {
        max4 = value2;
        while (++i2 < n2) {
          if ((value2 = values[i2]) != null && value2 > max4) {
            max4 = value2;
          }
        }
      }
    }
  } else {
    while (++i2 < n2) {
      if ((value2 = valueof(values[i2], i2, values)) != null && value2 >= value2) {
        max4 = value2;
        while (++i2 < n2) {
          if ((value2 = valueof(values[i2], i2, values)) != null && value2 > max4) {
            max4 = value2;
          }
        }
      }
    }
  }
  return max4;
}
var init_max = __esm({
  "node_modules/d3-array/src/max.js"() {
  }
});

// node_modules/d3-array/src/mean.js
var init_mean = __esm({
  "node_modules/d3-array/src/mean.js"() {
    init_number();
  }
});

// node_modules/d3-array/src/median.js
var init_median = __esm({
  "node_modules/d3-array/src/median.js"() {
    init_ascending();
    init_number();
    init_quantile();
  }
});

// node_modules/d3-array/src/merge.js
function merge_default(arrays) {
  var n2 = arrays.length, m2, i2 = -1, j2 = 0, merged, array3;
  while (++i2 < n2)
    j2 += arrays[i2].length;
  merged = new Array(j2);
  while (--n2 >= 0) {
    array3 = arrays[n2];
    m2 = array3.length;
    while (--m2 >= 0) {
      merged[--j2] = array3[m2];
    }
  }
  return merged;
}
var init_merge = __esm({
  "node_modules/d3-array/src/merge.js"() {
  }
});

// node_modules/d3-array/src/min.js
function min_default(values, valueof) {
  var n2 = values.length, i2 = -1, value2, min4;
  if (valueof == null) {
    while (++i2 < n2) {
      if ((value2 = values[i2]) != null && value2 >= value2) {
        min4 = value2;
        while (++i2 < n2) {
          if ((value2 = values[i2]) != null && min4 > value2) {
            min4 = value2;
          }
        }
      }
    }
  } else {
    while (++i2 < n2) {
      if ((value2 = valueof(values[i2], i2, values)) != null && value2 >= value2) {
        min4 = value2;
        while (++i2 < n2) {
          if ((value2 = valueof(values[i2], i2, values)) != null && min4 > value2) {
            min4 = value2;
          }
        }
      }
    }
  }
  return min4;
}
var init_min = __esm({
  "node_modules/d3-array/src/min.js"() {
  }
});

// node_modules/d3-array/src/permute.js
var init_permute = __esm({
  "node_modules/d3-array/src/permute.js"() {
  }
});

// node_modules/d3-array/src/scan.js
var init_scan = __esm({
  "node_modules/d3-array/src/scan.js"() {
    init_ascending();
  }
});

// node_modules/d3-array/src/shuffle.js
var init_shuffle = __esm({
  "node_modules/d3-array/src/shuffle.js"() {
  }
});

// node_modules/d3-array/src/sum.js
function sum_default(values, valueof) {
  var n2 = values.length, i2 = -1, value2, sum5 = 0;
  if (valueof == null) {
    while (++i2 < n2) {
      if (value2 = +values[i2])
        sum5 += value2;
    }
  } else {
    while (++i2 < n2) {
      if (value2 = +valueof(values[i2], i2, values))
        sum5 += value2;
    }
  }
  return sum5;
}
var init_sum = __esm({
  "node_modules/d3-array/src/sum.js"() {
  }
});

// node_modules/d3-array/src/transpose.js
var init_transpose = __esm({
  "node_modules/d3-array/src/transpose.js"() {
    init_min();
  }
});

// node_modules/d3-array/src/zip.js
var init_zip = __esm({
  "node_modules/d3-array/src/zip.js"() {
    init_transpose();
  }
});

// node_modules/d3-array/src/index.js
var init_src = __esm({
  "node_modules/d3-array/src/index.js"() {
    init_bisect();
    init_ascending();
    init_bisector();
    init_cross();
    init_descending();
    init_deviation();
    init_extent();
    init_histogram();
    init_freedmanDiaconis();
    init_scott();
    init_sturges();
    init_max();
    init_mean();
    init_median();
    init_merge();
    init_min();
    init_pairs();
    init_permute();
    init_quantile();
    init_range();
    init_scan();
    init_shuffle();
    init_sum();
    init_ticks();
    init_transpose();
    init_variance();
    init_zip();
  }
});

// node_modules/d3-geo/src/clip/extent.js
function clipExtent(x011, y011, x16, y16) {
  function visible(x4, y4) {
    return x011 <= x4 && x4 <= x16 && y011 <= y4 && y4 <= y16;
  }
  function interpolate(from, to, direction, stream) {
    var a3 = 0, a1 = 0;
    if (from == null || (a3 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a3 === 0 || a3 === 3 ? x011 : x16, a3 > 1 ? y16 : y011);
      while ((a3 = (a3 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p2, direction) {
    return abs(p2[0] - x011) < epsilon ? direction > 0 ? 0 : 3 : abs(p2[0] - x16) < epsilon ? direction > 0 ? 2 : 1 : abs(p2[1] - y011) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection4(a3, b2) {
    return comparePoint(a3.x, b2.x);
  }
  function comparePoint(a3, b2) {
    var ca = corner(a3, 1), cb = corner(b2, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a3[1] : ca === 1 ? a3[0] - b2[0] : ca === 2 ? a3[1] - b2[1] : b2[0] - a3[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point5(x4, y4) {
      if (visible(x4, y4))
        activeStream.point(x4, y4);
    }
    function polygonInside() {
      var winding = 0;
      for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
        for (var ring2 = polygon[i2], j2 = 1, m2 = ring2.length, point6 = ring2[0], a0, a1, b0 = point6[0], b1 = point6[1]; j2 < m2; ++j2) {
          a0 = b0, a1 = b1, point6 = ring2[j2], b0 = point6[0], b1 = point6[1];
          if (a1 <= y16) {
            if (b1 > y16 && (b0 - a0) * (y16 - a1) > (b1 - a1) * (x011 - a0))
              ++winding;
          } else {
            if (b1 <= y16 && (b0 - a0) * (y16 - a1) < (b1 - a1) * (x011 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge_default(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          polygon_default(segments, compareIntersection4, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint3;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint3(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point5;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint3(x4, y4) {
      var v2 = visible(x4, y4);
      if (polygon)
        ring.push([x4, y4]);
      if (first) {
        x__ = x4, y__ = y4, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x4, y4);
        }
      } else {
        if (v2 && v_)
          activeStream.point(x4, y4);
        else {
          var a3 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b2 = [x4 = Math.max(clipMin, Math.min(clipMax, x4)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];
          if (line_default(a3, b2, x011, y011, x16, y16)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a3[0], a3[1]);
            }
            activeStream.point(b2[0], b2[1]);
            if (!v2)
              activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x4, y4);
            clean = false;
          }
        }
      }
      x_ = x4, y_ = y4, v_ = v2;
    }
    return clipStream;
  };
}
function extent_default2() {
  var x011 = 0, y011 = 0, x16 = 960, y16 = 500, cache, cacheStream, clip;
  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipExtent(x011, y011, x16, y16)(cacheStream = stream);
    },
    extent: function(_2) {
      return arguments.length ? (x011 = +_2[0][0], y011 = +_2[0][1], x16 = +_2[1][0], y16 = +_2[1][1], cache = cacheStream = null, clip) : [[x011, y011], [x16, y16]];
    }
  };
}
var clipMax, clipMin;
var init_extent2 = __esm({
  "node_modules/d3-geo/src/clip/extent.js"() {
    init_math();
    init_buffer();
    init_line();
    init_polygon();
    init_src();
    clipMax = 1e9;
    clipMin = -clipMax;
  }
});

// node_modules/d3-geo/src/polygonContains.js
function polygonContains_default(polygon, point5) {
  var lambda = point5[0], phi2 = point5[1], normal = [sin(lambda), -cos(lambda), 0], angle5 = 0, winding = 0;
  sum.reset();
  for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
    if (!(m2 = (ring = polygon[i2]).length))
      continue;
    var ring, m2, point0 = ring[m2 - 1], lambda06 = point0[0], phi04 = point0[1] / 2 + quarterPi, sinPhi04 = sin(phi04), cosPhi04 = cos(phi04);
    for (var j2 = 0; j2 < m2; ++j2, lambda06 = lambda13, sinPhi04 = sinPhi1, cosPhi04 = cosPhi1, point0 = point1) {
      var point1 = ring[j2], lambda13 = point1[0], phi13 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi13), cosPhi1 = cos(phi13), delta = lambda13 - lambda06, sign6 = delta >= 0 ? 1 : -1, absDelta = sign6 * delta, antimeridian = absDelta > pi, k4 = sinPhi04 * sinPhi1;
      sum.add(atan2(k4 * sign6 * sin(absDelta), cosPhi04 * cosPhi1 + k4 * cos(absDelta)));
      angle5 += antimeridian ? delta + sign6 * tau : delta;
      if (antimeridian ^ lambda06 >= lambda ^ lambda13 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection2 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle5 < -epsilon || angle5 < epsilon && sum < -epsilon) ^ winding & 1;
}
var sum;
var init_polygonContains = __esm({
  "node_modules/d3-geo/src/polygonContains.js"() {
    init_adder();
    init_cartesian();
    init_math();
    sum = adder_default();
  }
});

// node_modules/d3-geo/src/length.js
function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}
function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop;
}
function lengthPointFirst(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  lambda03 = lambda, sinPhi02 = sin(phi2), cosPhi02 = cos(phi2);
  lengthStream.point = lengthPoint;
}
function lengthPoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var sinPhi = sin(phi2), cosPhi = cos(phi2), delta = abs(lambda - lambda03), cosDelta = cos(delta), sinDelta = sin(delta), x4 = cosPhi * sinDelta, y4 = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta, z2 = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x4 * x4 + y4 * y4), z2));
  lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;
}
function length_default(object3) {
  lengthSum.reset();
  stream_default(object3, lengthStream);
  return +lengthSum;
}
var lengthSum, lambda03, sinPhi02, cosPhi02, lengthStream;
var init_length = __esm({
  "node_modules/d3-geo/src/length.js"() {
    init_adder();
    init_math();
    init_noop();
    init_stream();
    lengthSum = adder_default();
    lengthStream = {
      sphere: noop,
      point: noop,
      lineStart: lengthLineStart,
      lineEnd: noop,
      polygonStart: noop,
      polygonEnd: noop
    };
  }
});

// node_modules/d3-geo/src/distance.js
function distance_default(a3, b2) {
  coordinates[0] = a3;
  coordinates[1] = b2;
  return length_default(object);
}
var coordinates, object;
var init_distance = __esm({
  "node_modules/d3-geo/src/distance.js"() {
    init_length();
    coordinates = [null, null];
    object = { type: "LineString", coordinates };
  }
});

// node_modules/d3-geo/src/contains.js
function containsGeometry(geometry, point5) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point5) : false;
}
function containsPoint(coordinates2, point5) {
  return distance_default(coordinates2, point5) === 0;
}
function containsLine(coordinates2, point5) {
  var ab = distance_default(coordinates2[0], coordinates2[1]), ao = distance_default(coordinates2[0], point5), ob = distance_default(point5, coordinates2[1]);
  return ao + ob <= ab + epsilon;
}
function containsPolygon(coordinates2, point5) {
  return !!polygonContains_default(coordinates2.map(ringRadians), pointRadians(point5));
}
function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}
function pointRadians(point5) {
  return [point5[0] * radians, point5[1] * radians];
}
function contains_default(object3, point5) {
  return (object3 && containsObjectType.hasOwnProperty(object3.type) ? containsObjectType[object3.type] : containsGeometry)(object3, point5);
}
var containsObjectType, containsGeometryType;
var init_contains = __esm({
  "node_modules/d3-geo/src/contains.js"() {
    init_polygonContains();
    init_distance();
    init_math();
    containsObjectType = {
      Feature: function(object3, point5) {
        return containsGeometry(object3.geometry, point5);
      },
      FeatureCollection: function(object3, point5) {
        var features = object3.features, i2 = -1, n2 = features.length;
        while (++i2 < n2)
          if (containsGeometry(features[i2].geometry, point5))
            return true;
        return false;
      }
    };
    containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object3, point5) {
        return containsPoint(object3.coordinates, point5);
      },
      MultiPoint: function(object3, point5) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          if (containsPoint(coordinates2[i2], point5))
            return true;
        return false;
      },
      LineString: function(object3, point5) {
        return containsLine(object3.coordinates, point5);
      },
      MultiLineString: function(object3, point5) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          if (containsLine(coordinates2[i2], point5))
            return true;
        return false;
      },
      Polygon: function(object3, point5) {
        return containsPolygon(object3.coordinates, point5);
      },
      MultiPolygon: function(object3, point5) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          if (containsPolygon(coordinates2[i2], point5))
            return true;
        return false;
      },
      GeometryCollection: function(object3, point5) {
        var geometries = object3.geometries, i2 = -1, n2 = geometries.length;
        while (++i2 < n2)
          if (containsGeometry(geometries[i2], point5))
            return true;
        return false;
      }
    };
  }
});

// node_modules/d3-geo/src/graticule.js
function graticuleX(y011, y16, dy) {
  var y4 = range_default(y011, y16 - epsilon, dy).concat(y16);
  return function(x4) {
    return y4.map(function(y5) {
      return [x4, y5];
    });
  };
}
function graticuleY(x011, x16, dx) {
  var x4 = range_default(x011, x16 - epsilon, dx).concat(x16);
  return function(y4) {
    return x4.map(function(x5) {
      return [x5, y4];
    });
  };
}
function graticule() {
  var x16, x011, X14, X04, y16, y011, Y14, Y04, dx = 10, dy = dx, DX = 90, DY = 360, x4, y4, X3, Y3, precision = 2.5;
  function graticule4() {
    return { type: "MultiLineString", coordinates: lines2() };
  }
  function lines2() {
    return range_default(ceil(X04 / DX) * DX, X14, DX).map(X3).concat(range_default(ceil(Y04 / DY) * DY, Y14, DY).map(Y3)).concat(range_default(ceil(x011 / dx) * dx, x16, dx).filter(function(x5) {
      return abs(x5 % DX) > epsilon;
    }).map(x4)).concat(range_default(ceil(y011 / dy) * dy, y16, dy).filter(function(y5) {
      return abs(y5 % DY) > epsilon;
    }).map(y4));
  }
  graticule4.lines = function() {
    return lines2().map(function(coordinates2) {
      return { type: "LineString", coordinates: coordinates2 };
    });
  };
  graticule4.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X3(X04).concat(Y3(Y14).slice(1), X3(X14).reverse().slice(1), Y3(Y04).reverse().slice(1))
      ]
    };
  };
  graticule4.extent = function(_2) {
    if (!arguments.length)
      return graticule4.extentMinor();
    return graticule4.extentMajor(_2).extentMinor(_2);
  };
  graticule4.extentMajor = function(_2) {
    if (!arguments.length)
      return [[X04, Y04], [X14, Y14]];
    X04 = +_2[0][0], X14 = +_2[1][0];
    Y04 = +_2[0][1], Y14 = +_2[1][1];
    if (X04 > X14)
      _2 = X04, X04 = X14, X14 = _2;
    if (Y04 > Y14)
      _2 = Y04, Y04 = Y14, Y14 = _2;
    return graticule4.precision(precision);
  };
  graticule4.extentMinor = function(_2) {
    if (!arguments.length)
      return [[x011, y011], [x16, y16]];
    x011 = +_2[0][0], x16 = +_2[1][0];
    y011 = +_2[0][1], y16 = +_2[1][1];
    if (x011 > x16)
      _2 = x011, x011 = x16, x16 = _2;
    if (y011 > y16)
      _2 = y011, y011 = y16, y16 = _2;
    return graticule4.precision(precision);
  };
  graticule4.step = function(_2) {
    if (!arguments.length)
      return graticule4.stepMinor();
    return graticule4.stepMajor(_2).stepMinor(_2);
  };
  graticule4.stepMajor = function(_2) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_2[0], DY = +_2[1];
    return graticule4;
  };
  graticule4.stepMinor = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_2[0], dy = +_2[1];
    return graticule4;
  };
  graticule4.precision = function(_2) {
    if (!arguments.length)
      return precision;
    precision = +_2;
    x4 = graticuleX(y011, y16, 90);
    y4 = graticuleY(x011, x16, precision);
    X3 = graticuleX(Y04, Y14, 90);
    Y3 = graticuleY(X04, X14, precision);
    return graticule4;
  };
  return graticule4.extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]]).extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
}
function graticule10() {
  return graticule()();
}
var init_graticule = __esm({
  "node_modules/d3-geo/src/graticule.js"() {
    init_src();
    init_math();
  }
});

// node_modules/d3-geo/src/interpolate.js
function interpolate_default(a3, b2) {
  var x011 = a3[0] * radians, y011 = a3[1] * radians, x16 = b2[0] * radians, y16 = b2[1] * radians, cy0 = cos(y011), sy0 = sin(y011), cy1 = cos(y16), sy1 = sin(y16), kx0 = cy0 * cos(x011), ky0 = cy0 * sin(x011), kx1 = cy1 * cos(x16), ky1 = cy1 * sin(x16), d2 = 2 * asin(sqrt(haversin(y16 - y011) + cy0 * cy1 * haversin(x16 - x011))), k4 = sin(d2);
  var interpolate = d2 ? function(t2) {
    var B3 = sin(t2 *= d2) / k4, A6 = sin(d2 - t2) / k4, x4 = A6 * kx0 + B3 * kx1, y4 = A6 * ky0 + B3 * ky1, z2 = A6 * sy0 + B3 * sy1;
    return [
      atan2(y4, x4) * degrees,
      atan2(z2, sqrt(x4 * x4 + y4 * y4)) * degrees
    ];
  } : function() {
    return [x011 * degrees, y011 * degrees];
  };
  interpolate.distance = d2;
  return interpolate;
}
var init_interpolate = __esm({
  "node_modules/d3-geo/src/interpolate.js"() {
    init_math();
  }
});

// node_modules/d3-geo/src/identity.js
function identity_default2(x4) {
  return x4;
}
var init_identity2 = __esm({
  "node_modules/d3-geo/src/identity.js"() {
  }
});

// node_modules/d3-geo/src/path/area.js
function areaRingStart2() {
  areaStream2.point = areaPointFirst2;
}
function areaPointFirst2(x4, y4) {
  areaStream2.point = areaPoint2;
  x00 = x02 = x4, y00 = y02 = y4;
}
function areaPoint2(x4, y4) {
  areaRingSum2.add(y02 * x4 - x02 * y4);
  x02 = x4, y02 = y4;
}
function areaRingEnd2() {
  areaPoint2(x00, y00);
}
var areaSum2, areaRingSum2, x00, y00, x02, y02, areaStream2, area_default2;
var init_area2 = __esm({
  "node_modules/d3-geo/src/path/area.js"() {
    init_adder();
    init_math();
    init_noop();
    areaSum2 = adder_default();
    areaRingSum2 = adder_default();
    areaStream2 = {
      point: noop,
      lineStart: noop,
      lineEnd: noop,
      polygonStart: function() {
        areaStream2.lineStart = areaRingStart2;
        areaStream2.lineEnd = areaRingEnd2;
      },
      polygonEnd: function() {
        areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop;
        areaSum2.add(abs(areaRingSum2));
        areaRingSum2.reset();
      },
      result: function() {
        var area = areaSum2 / 2;
        areaSum2.reset();
        return area;
      }
    };
    area_default2 = areaStream2;
  }
});

// node_modules/d3-geo/src/path/bounds.js
function boundsPoint2(x4, y4) {
  if (x4 < x03)
    x03 = x4;
  if (x4 > x1)
    x1 = x4;
  if (y4 < y03)
    y03 = y4;
  if (y4 > y1)
    y1 = y4;
}
var x03, y03, x1, y1, boundsStream2, bounds_default2;
var init_bounds2 = __esm({
  "node_modules/d3-geo/src/path/bounds.js"() {
    init_noop();
    x03 = Infinity;
    y03 = x03;
    x1 = -x03;
    y1 = x1;
    boundsStream2 = {
      point: boundsPoint2,
      lineStart: noop,
      lineEnd: noop,
      polygonStart: noop,
      polygonEnd: noop,
      result: function() {
        var bounds = [[x03, y03], [x1, y1]];
        x1 = y1 = -(y03 = x03 = Infinity);
        return bounds;
      }
    };
    bounds_default2 = boundsStream2;
  }
});

// node_modules/d3-geo/src/path/centroid.js
function centroidPoint2(x4, y4) {
  X02 += x4;
  Y02 += y4;
  ++Z02;
}
function centroidLineStart2() {
  centroidStream2.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x4, y4) {
  centroidStream2.point = centroidPointLine;
  centroidPoint2(x04 = x4, y04 = y4);
}
function centroidPointLine(x4, y4) {
  var dx = x4 - x04, dy = y4 - y04, z2 = sqrt(dx * dx + dy * dy);
  X12 += z2 * (x04 + x4) / 2;
  Y12 += z2 * (y04 + y4) / 2;
  Z12 += z2;
  centroidPoint2(x04 = x4, y04 = y4);
}
function centroidLineEnd2() {
  centroidStream2.point = centroidPoint2;
}
function centroidRingStart2() {
  centroidStream2.point = centroidPointFirstRing;
}
function centroidRingEnd2() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x4, y4) {
  centroidStream2.point = centroidPointRing;
  centroidPoint2(x002 = x04 = x4, y002 = y04 = y4);
}
function centroidPointRing(x4, y4) {
  var dx = x4 - x04, dy = y4 - y04, z2 = sqrt(dx * dx + dy * dy);
  X12 += z2 * (x04 + x4) / 2;
  Y12 += z2 * (y04 + y4) / 2;
  Z12 += z2;
  z2 = y04 * x4 - x04 * y4;
  X22 += z2 * (x04 + x4);
  Y22 += z2 * (y04 + y4);
  Z22 += z2 * 3;
  centroidPoint2(x04 = x4, y04 = y4);
}
var X02, Y02, Z02, X12, Y12, Z12, X22, Y22, Z22, x002, y002, x04, y04, centroidStream2, centroid_default2;
var init_centroid2 = __esm({
  "node_modules/d3-geo/src/path/centroid.js"() {
    init_math();
    X02 = 0;
    Y02 = 0;
    Z02 = 0;
    X12 = 0;
    Y12 = 0;
    Z12 = 0;
    X22 = 0;
    Y22 = 0;
    Z22 = 0;
    centroidStream2 = {
      point: centroidPoint2,
      lineStart: centroidLineStart2,
      lineEnd: centroidLineEnd2,
      polygonStart: function() {
        centroidStream2.lineStart = centroidRingStart2;
        centroidStream2.lineEnd = centroidRingEnd2;
      },
      polygonEnd: function() {
        centroidStream2.point = centroidPoint2;
        centroidStream2.lineStart = centroidLineStart2;
        centroidStream2.lineEnd = centroidLineEnd2;
      },
      result: function() {
        var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
        X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
        return centroid;
      }
    };
    centroid_default2 = centroidStream2;
  }
});

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
var init_context = __esm({
  "node_modules/d3-geo/src/path/context.js"() {
    init_math();
    init_noop();
    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_2) {
        return this._radius = _2, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._context.closePath();
        this._point = NaN;
      },
      point: function(x4, y4) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x4, y4);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x4, y4);
            break;
          }
          default: {
            this._context.moveTo(x4 + this._radius, y4);
            this._context.arc(x4, y4, this._radius, 0, tau);
            break;
          }
        }
      },
      result: noop
    };
  }
});

// node_modules/d3-geo/src/path/measure.js
function lengthPointFirst2(x4, y4) {
  lengthStream2.point = lengthPoint2;
  x003 = x05 = x4, y003 = y05 = y4;
}
function lengthPoint2(x4, y4) {
  x05 -= x4, y05 -= y4;
  lengthSum2.add(sqrt(x05 * x05 + y05 * y05));
  x05 = x4, y05 = y4;
}
var lengthSum2, lengthRing, x003, y003, x05, y05, lengthStream2, measure_default;
var init_measure = __esm({
  "node_modules/d3-geo/src/path/measure.js"() {
    init_adder();
    init_math();
    init_noop();
    lengthSum2 = adder_default();
    lengthStream2 = {
      point: noop,
      lineStart: function() {
        lengthStream2.point = lengthPointFirst2;
      },
      lineEnd: function() {
        if (lengthRing)
          lengthPoint2(x003, y003);
        lengthStream2.point = noop;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length2 = +lengthSum2;
        lengthSum2.reset();
        return length2;
      }
    };
    measure_default = lengthStream2;
  }
});

// node_modules/d3-geo/src/path/string.js
function PathString() {
  this._string = [];
}
function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}
var init_string = __esm({
  "node_modules/d3-geo/src/path/string.js"() {
    PathString.prototype = {
      _radius: 4.5,
      _circle: circle(4.5),
      pointRadius: function(_2) {
        if ((_2 = +_2) !== this._radius)
          this._radius = _2, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._string.push("Z");
        this._point = NaN;
      },
      point: function(x4, y4) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x4, ",", y4);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x4, ",", y4);
            break;
          }
          default: {
            if (this._circle == null)
              this._circle = circle(this._radius);
            this._string.push("M", x4, ",", y4, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };
  }
});

// node_modules/d3-geo/src/path/index.js
function path_default(projection4, context) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path3(object3) {
    if (object3) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object3, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path3.area = function(object3) {
    stream_default(object3, projectionStream(area_default2));
    return area_default2.result();
  };
  path3.measure = function(object3) {
    stream_default(object3, projectionStream(measure_default));
    return measure_default.result();
  };
  path3.bounds = function(object3) {
    stream_default(object3, projectionStream(bounds_default2));
    return bounds_default2.result();
  };
  path3.centroid = function(object3) {
    stream_default(object3, projectionStream(centroid_default2));
    return centroid_default2.result();
  };
  path3.projection = function(_2) {
    return arguments.length ? (projectionStream = _2 == null ? (projection4 = null, identity_default2) : (projection4 = _2).stream, path3) : projection4;
  };
  path3.context = function(_2) {
    if (!arguments.length)
      return context;
    contextStream = _2 == null ? (context = null, new PathString()) : new PathContext(context = _2);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path3;
  };
  path3.pointRadius = function(_2) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
    return path3;
  };
  return path3.projection(projection4).context(context);
}
var init_path = __esm({
  "node_modules/d3-geo/src/path/index.js"() {
    init_identity2();
    init_stream();
    init_area2();
    init_bounds2();
    init_centroid2();
    init_context();
    init_measure();
    init_string();
  }
});

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start) {
  return function(rotate, sink) {
    var line = clipLine(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point5;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge_default(segments);
        var startInside = polygonContains_default(polygon, rotatedStart);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          polygon_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point5(lambda, phi2) {
      var point6 = rotate(lambda, phi2);
      if (pointVisible(lambda = point6[0], phi2 = point6[1]))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      var point6 = rotate(lambda, phi2);
      line.point(point6[0], point6[1]);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point5;
      line.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      var point6 = rotate(lambda, phi2);
      ringSink.point(point6[0], point6[1]);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i2, n2 = ringSegments.length, m2, segment, point6;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n2)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i2 = 0; i2 < m2; ++i2)
            sink.point((point6 = segment[i2])[0], point6[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n2 > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a3, b2) {
  return ((a3 = a3.x)[0] < 0 ? a3[1] - halfPi - epsilon : halfPi - a3[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi - epsilon : halfPi - b2[1]);
}
var init_clip = __esm({
  "node_modules/d3-geo/src/clip/index.js"() {
    init_buffer();
    init_polygon();
    init_math();
    init_polygonContains();
    init_src();
  }
});

// node_modules/d3-geo/src/clip/antimeridian.js
function clipAntimeridianLine(stream) {
  var lambda06 = NaN, phi04 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda13, phi13) {
      var sign1 = lambda13 > 0 ? pi : -pi, delta = abs(lambda13 - lambda06);
      if (abs(delta - pi) < epsilon) {
        stream.point(lambda06, phi04 = (phi04 + phi13) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi04);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi04);
        stream.point(lambda13, phi04);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi) {
        if (abs(lambda06 - sign0) < epsilon)
          lambda06 -= sign0 * epsilon;
        if (abs(lambda13 - sign1) < epsilon)
          lambda13 -= sign1 * epsilon;
        phi04 = clipAntimeridianIntersect(lambda06, phi04, lambda13, phi13);
        stream.point(sign0, phi04);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi04);
        clean = 0;
      }
      stream.point(lambda06 = lambda13, phi04 = phi13);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda06 = phi04 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda06, phi04, lambda13, phi13) {
  var cosPhi04, cosPhi1, sinLambda0Lambda1 = sin(lambda06 - lambda13);
  return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi04) * (cosPhi1 = cos(phi13)) * sin(lambda13) - sin(phi13) * (cosPhi04 = cos(phi04)) * sin(lambda06)) / (cosPhi04 * cosPhi1 * sinLambda0Lambda1)) : (phi04 + phi13) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi;
    stream.point(-pi, phi2);
    stream.point(0, phi2);
    stream.point(pi, phi2);
    stream.point(pi, 0);
    stream.point(pi, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi, -phi2);
    stream.point(-pi, 0);
    stream.point(-pi, phi2);
  } else if (abs(from[0] - to[0]) > epsilon) {
    var lambda = from[0] < to[0] ? pi : -pi;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}
var antimeridian_default;
var init_antimeridian = __esm({
  "node_modules/d3-geo/src/clip/antimeridian.js"() {
    init_clip();
    init_math();
    antimeridian_default = clip_default(function() {
      return true;
    }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);
  }
});

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius, delta) {
  var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos(lambda) * cos(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v2 = visible(lambda, phi2), c2 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi : -pi), phi2) : 0;
        if (!point0 && (v00 = v0 = v2))
          stream.lineStart();
        if (v2 !== v0) {
          point22 = intersect(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22)) {
            point1[0] += epsilon;
            point1[1] += epsilon;
            v2 = visible(point1[0], point1[1]);
          }
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream.lineStart();
            point22 = intersect(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect(point0, point1);
            stream.point(point22[0], point22[1]);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t2;
          if (!(c2 & c0) && (t2 = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t2[0][0], t2[0][1]);
              stream.point(t2[1][0], t2[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t2[1][0], t2[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t2[0][0], t2[0][1]);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c2;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect(a3, b2, two) {
    var pa = cartesian(a3), pb = cartesian(b2);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a3;
    var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A6 = cartesianScale(n1, c1), B3 = cartesianScale(n2, c2);
    cartesianAddInPlace(A6, B3);
    var u2 = n1xn2, w3 = cartesianDot(A6, u2), uu = cartesianDot(u2, u2), t2 = w3 * w3 - uu * (cartesianDot(A6, A6) - 1);
    if (t2 < 0)
      return;
    var t3 = sqrt(t2), q2 = cartesianScale(u2, (-w3 - t3) / uu);
    cartesianAddInPlace(q2, A6);
    q2 = spherical(q2);
    if (!two)
      return q2;
    var lambda06 = a3[0], lambda13 = b2[0], phi04 = a3[1], phi13 = b2[1], z2;
    if (lambda13 < lambda06)
      z2 = lambda06, lambda06 = lambda13, lambda13 = z2;
    var delta2 = lambda13 - lambda06, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
    if (!polar && phi13 < phi04)
      z2 = phi04, phi04 = phi13, phi13 = z2;
    if (meridian ? polar ? phi04 + phi13 > 0 ^ q2[1] < (abs(q2[0] - lambda06) < epsilon ? phi04 : phi13) : phi04 <= q2[1] && q2[1] <= phi13 : delta2 > pi ^ (lambda06 <= q2[0] && q2[0] <= lambda13)) {
      var q1 = cartesianScale(u2, (-w3 + t3) / uu);
      cartesianAddInPlace(q1, A6);
      return [q2, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r2 = smallRadius ? radius : pi - radius, code2 = 0;
    if (lambda < -r2)
      code2 |= 1;
    else if (lambda > r2)
      code2 |= 2;
    if (phi2 < -r2)
      code2 |= 4;
    else if (phi2 > r2)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
}
var init_circle2 = __esm({
  "node_modules/d3-geo/src/clip/circle.js"() {
    init_cartesian();
    init_circle();
    init_math();
    init_pointEqual();
    init_clip();
  }
});

// node_modules/d3-geo/src/transform.js
function transform_default(methods) {
  return {
    stream: transformer(methods)
  };
}
function transformer(methods) {
  return function(stream) {
    var s3 = new TransformStream();
    for (var key in methods)
      s3[key] = methods[key];
    s3.stream = stream;
    return s3;
  };
}
function TransformStream() {
}
var init_transform = __esm({
  "node_modules/d3-geo/src/transform.js"() {
    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x4, y4) {
        this.stream.point(x4, y4);
      },
      sphere: function() {
        this.stream.sphere();
      },
      lineStart: function() {
        this.stream.lineStart();
      },
      lineEnd: function() {
        this.stream.lineEnd();
      },
      polygonStart: function() {
        this.stream.polygonStart();
      },
      polygonEnd: function() {
        this.stream.polygonEnd();
      }
    };
  }
});

// node_modules/d3-geo/src/projection/fit.js
function fitExtent(projection4, extent, object3) {
  var w3 = extent[1][0] - extent[0][0], h2 = extent[1][1] - extent[0][1], clip = projection4.clipExtent && projection4.clipExtent();
  projection4.scale(150).translate([0, 0]);
  if (clip != null)
    projection4.clipExtent(null);
  stream_default(object3, projection4.stream(bounds_default2));
  var b2 = bounds_default2.result(), k4 = Math.min(w3 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x4 = +extent[0][0] + (w3 - k4 * (b2[1][0] + b2[0][0])) / 2, y4 = +extent[0][1] + (h2 - k4 * (b2[1][1] + b2[0][1])) / 2;
  if (clip != null)
    projection4.clipExtent(clip);
  return projection4.scale(k4 * 150).translate([x4, y4]);
}
function fitSize(projection4, size, object3) {
  return fitExtent(projection4, [[0, 0], size], object3);
}
var init_fit = __esm({
  "node_modules/d3-geo/src/projection/fit.js"() {
    init_stream();
    init_bounds2();
  }
});

// node_modules/d3-geo/src/projection/resample.js
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x4, y4) {
      x4 = project(x4, y4);
      this.stream.point(x4[0], x4[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x011, y011, lambda06, a0, b0, c0, x16, y16, lambda13, a1, b1, c1, depth, stream) {
    var dx = x16 - x011, dy = y16 - y011, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a3 = a0 + a1, b2 = b0 + b1, c2 = c0 + c1, m2 = sqrt(a3 * a3 + b2 * b2 + c2 * c2), phi2 = asin(c2 /= m2), lambda23 = abs(abs(c2) - 1) < epsilon || abs(lambda06 - lambda13) < epsilon ? (lambda06 + lambda13) / 2 : atan2(b2, a3), p2 = project(lambda23, phi2), x22 = p2[0], y22 = p2[1], dx2 = x22 - x011, dy2 = y22 - y011, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x011, y011, lambda06, a0, b0, c0, x22, y22, lambda23, a3 /= m2, b2 /= m2, c2, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda23, a3, b2, c2, x16, y16, lambda13, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda007, x004, y004, a00, b00, c00, lambda06, x011, y011, a0, b0, c0;
    var resampleStream = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point5(x4, y4) {
      x4 = project(x4, y4);
      stream.point(x4[0], x4[1]);
    }
    function lineStart() {
      x011 = NaN;
      resampleStream.point = linePoint3;
      stream.lineStart();
    }
    function linePoint3(lambda, phi2) {
      var c2 = cartesian([lambda, phi2]), p2 = project(lambda, phi2);
      resampleLineTo(x011, y011, lambda06, a0, b0, c0, x011 = p2[0], y011 = p2[1], lambda06 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth, stream);
      stream.point(x011, y011);
    }
    function lineEnd() {
      resampleStream.point = point5;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint3(lambda007 = lambda, phi2), x004 = x011, y004 = y011, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint3;
    }
    function ringEnd() {
      resampleLineTo(x011, y011, lambda06, a0, b0, c0, x004, y004, lambda007, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}
var maxDepth, cosMinDistance;
var init_resample = __esm({
  "node_modules/d3-geo/src/projection/resample.js"() {
    init_cartesian();
    init_math();
    init_transform();
    maxDepth = 16;
    cosMinDistance = cos(30 * radians);
  }
});

// node_modules/d3-geo/src/projection/index.js
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k4 = 150, x4 = 480, y4 = 250, dx, dy, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, theta = null, preclip = antimeridian_default, x011 = null, y011, x16, y16, postclip = identity_default2, delta2 = 0.5, projectResample = resample_default(projectTransform, delta2), cache, cacheStream;
  function projection4(point5) {
    point5 = projectRotate(point5[0] * radians, point5[1] * radians);
    return [point5[0] * k4 + dx, dy - point5[1] * k4];
  }
  function invert(point5) {
    point5 = projectRotate.invert((point5[0] - dx) / k4, (dy - point5[1]) / k4);
    return point5 && [point5[0] * degrees, point5[1] * degrees];
  }
  function projectTransform(x5, y5) {
    return x5 = project(x5, y5), [x5[0] * k4 + dx, dy - x5[1] * k4];
  }
  projection4.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
  };
  projection4.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? circle_default2(theta = _2 * radians, 6 * radians) : (theta = null, antimeridian_default), reset()) : theta * degrees;
  };
  projection4.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x011 = y011 = x16 = y16 = null, identity_default2) : clipExtent(x011 = +_2[0][0], y011 = +_2[0][1], x16 = +_2[1][0], y16 = +_2[1][1]), reset()) : x011 == null ? null : [[x011, y011], [x16, y16]];
  };
  projection4.scale = function(_2) {
    return arguments.length ? (k4 = +_2, recenter()) : k4;
  };
  projection4.translate = function(_2) {
    return arguments.length ? (x4 = +_2[0], y4 = +_2[1], recenter()) : [x4, y4];
  };
  projection4.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians, phi2 = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
  };
  projection4.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection4.precision = function(_2) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt(delta2);
  };
  projection4.fitExtent = function(extent, object3) {
    return fitExtent(projection4, extent, object3);
  };
  projection4.fitSize = function(size, object3) {
    return fitSize(projection4, size, object3);
  };
  function recenter() {
    projectRotate = compose_default(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
    var center2 = project(lambda, phi2);
    dx = x4 - center2[0] * k4;
    dy = y4 + center2[1] * k4;
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection4;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection4.invert = project.invert && invert;
    return recenter();
  };
}
var transformRadians;
var init_projection = __esm({
  "node_modules/d3-geo/src/projection/index.js"() {
    init_antimeridian();
    init_circle2();
    init_extent2();
    init_compose();
    init_identity2();
    init_math();
    init_rotation();
    init_transform();
    init_fit();
    init_resample();
    transformRadians = transformer({
      point: function(x4, y4) {
        this.stream.point(x4 * radians, y4 * radians);
      }
    });
  }
});

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi04 = 0, phi13 = pi / 3, m2 = projectionMutator(projectAt), p2 = m2(phi04, phi13);
  p2.parallels = function(_2) {
    return arguments.length ? m2(phi04 = _2[0] * radians, phi13 = _2[1] * radians) : [phi04 * degrees, phi13 * degrees];
  };
  return p2;
}
var init_conic = __esm({
  "node_modules/d3-geo/src/projection/conic.js"() {
    init_math();
    init_projection();
  }
});

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi04) {
  var cosPhi04 = cos(phi04);
  function forward(lambda, phi2) {
    return [lambda * cosPhi04, sin(phi2) / cosPhi04];
  }
  forward.invert = function(x4, y4) {
    return [x4 / cosPhi04, asin(y4 * cosPhi04)];
  };
  return forward;
}
var init_cylindricalEqualArea = __esm({
  "node_modules/d3-geo/src/projection/cylindricalEqualArea.js"() {
    init_math();
  }
});

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y011, y16) {
  var sy0 = sin(y011), n2 = (sy0 + sin(y16)) / 2;
  if (abs(n2) < epsilon)
    return cylindricalEqualAreaRaw(y011);
  var c2 = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt(c2) / n2;
  function project(x4, y4) {
    var r2 = sqrt(c2 - 2 * n2 * sin(y4)) / n2;
    return [r2 * sin(x4 *= n2), r0 - r2 * cos(x4)];
  }
  project.invert = function(x4, y4) {
    var r0y = r0 - y4;
    return [atan2(x4, abs(r0y)) / n2 * sign(r0y), asin((c2 - (x4 * x4 + r0y * r0y) * n2 * n2) / (2 * n2))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}
var init_conicEqualArea = __esm({
  "node_modules/d3-geo/src/projection/conicEqualArea.js"() {
    init_math();
    init_conic();
    init_cylindricalEqualArea();
  }
});

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
var init_albers = __esm({
  "node_modules/d3-geo/src/projection/albers.js"() {
    init_conicEqualArea();
  }
});

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].point(x4, y4);
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].sphere();
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].lineStart();
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].lineEnd();
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].polygonStart();
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska2 = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function albersUsa(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (lower48Point.point(x4, y4), point5) || (alaskaPoint.point(x4, y4), point5) || (hawaiiPoint.point(x4, y4), point5);
  }
  albersUsa.invert = function(coordinates2) {
    var k4 = lower48.scale(), t2 = lower48.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= 0.12 && y4 < 0.234 && x4 >= -0.425 && x4 < -0.214 ? alaska2 : y4 >= 0.166 && y4 < 0.234 && x4 >= -0.214 && x4 < -0.115 ? hawaii : lower48).invert(coordinates2);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska2.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_2) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_2), alaska2.precision(_2), hawaii.precision(_2);
    return reset();
  };
  albersUsa.scale = function(_2) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_2), alaska2.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_2) {
    if (!arguments.length)
      return lower48.translate();
    var k4 = lower48.scale(), x4 = +_2[0], y4 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x4 - 0.455 * k4, y4 - 0.238 * k4], [x4 + 0.455 * k4, y4 + 0.238 * k4]]).stream(pointStream);
    alaskaPoint = alaska2.translate([x4 - 0.307 * k4, y4 + 0.201 * k4]).clipExtent([[x4 - 0.425 * k4 + epsilon, y4 + 0.12 * k4 + epsilon], [x4 - 0.214 * k4 - epsilon, y4 + 0.234 * k4 - epsilon]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x4 - 0.205 * k4, y4 + 0.212 * k4]).clipExtent([[x4 - 0.214 * k4 + epsilon, y4 + 0.166 * k4 + epsilon], [x4 - 0.115 * k4 - epsilon, y4 + 0.234 * k4 - epsilon]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent, object3) {
    return fitExtent(albersUsa, extent, object3);
  };
  albersUsa.fitSize = function(size, object3) {
    return fitSize(albersUsa, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}
var init_albersUsa = __esm({
  "node_modules/d3-geo/src/projection/albersUsa.js"() {
    init_math();
    init_albers();
    init_conicEqualArea();
    init_fit();
  }
});

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale) {
  return function(x4, y4) {
    var cx = cos(x4), cy = cos(y4), k4 = scale(cx * cy);
    return [
      k4 * cy * sin(x4),
      k4 * sin(y4)
    ];
  };
}
function azimuthalInvert(angle5) {
  return function(x4, y4) {
    var z2 = sqrt(x4 * x4 + y4 * y4), c2 = angle5(z2), sc = sin(c2), cc = cos(c2);
    return [
      atan2(x4 * sc, z2 * cc),
      asin(z2 && y4 * sc / z2)
    ];
  };
}
var init_azimuthal = __esm({
  "node_modules/d3-geo/src/projection/azimuthal.js"() {
    init_math();
  }
});

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}
var azimuthalEqualAreaRaw;
var init_azimuthalEqualArea = __esm({
  "node_modules/d3-geo/src/projection/azimuthalEqualArea.js"() {
    init_math();
    init_azimuthal();
    init_projection();
    azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt(2 / (1 + cxcy));
    });
    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z2) {
      return 2 * asin(z2 / 2);
    });
  }
});

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}
var azimuthalEquidistantRaw;
var init_azimuthalEquidistant = __esm({
  "node_modules/d3-geo/src/projection/azimuthalEquidistant.js"() {
    init_math();
    init_azimuthal();
    init_projection();
    azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
      return (c2 = acos(c2)) && c2 / sin(c2);
    });
    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z2) {
      return z2;
    });
  }
});

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log(tan((halfPi + phi2) / 2))];
}
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau);
}
function mercatorProjection(project) {
  var m2 = projection(project), center2 = m2.center, scale = m2.scale, translate = m2.translate, clipExtent2 = m2.clipExtent, x011 = null, y011, x16, y16;
  m2.scale = function(_2) {
    return arguments.length ? (scale(_2), reclip()) : scale();
  };
  m2.translate = function(_2) {
    return arguments.length ? (translate(_2), reclip()) : translate();
  };
  m2.center = function(_2) {
    return arguments.length ? (center2(_2), reclip()) : center2();
  };
  m2.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x011 = y011 = x16 = y16 = null : (x011 = +_2[0][0], y011 = +_2[0][1], x16 = +_2[1][0], y16 = +_2[1][1]), reclip()) : x011 == null ? null : [[x011, y011], [x16, y16]];
  };
  function reclip() {
    var k4 = pi * scale(), t2 = m2(rotation_default(m2.rotate()).invert([0, 0]));
    return clipExtent2(x011 == null ? [[t2[0] - k4, t2[1] - k4], [t2[0] + k4, t2[1] + k4]] : project === mercatorRaw ? [[Math.max(t2[0] - k4, x011), y011], [Math.min(t2[0] + k4, x16), y16]] : [[x011, Math.max(t2[1] - k4, y011)], [x16, Math.min(t2[1] + k4, y16)]]);
  }
  return reclip();
}
var init_mercator = __esm({
  "node_modules/d3-geo/src/projection/mercator.js"() {
    init_math();
    init_rotation();
    init_projection();
    mercatorRaw.invert = function(x4, y4) {
      return [x4, 2 * atan(exp(y4)) - halfPi];
    };
  }
});

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y4) {
  return tan((halfPi + y4) / 2);
}
function conicConformalRaw(y011, y16) {
  var cy0 = cos(y011), n2 = y011 === y16 ? sin(y011) : log(cy0 / cos(y16)) / log(tany(y16) / tany(y011)), f2 = cy0 * pow(tany(y011), n2) / n2;
  if (!n2)
    return mercatorRaw;
  function project(x4, y4) {
    if (f2 > 0) {
      if (y4 < -halfPi + epsilon)
        y4 = -halfPi + epsilon;
    } else {
      if (y4 > halfPi - epsilon)
        y4 = halfPi - epsilon;
    }
    var r2 = f2 / pow(tany(y4), n2);
    return [r2 * sin(n2 * x4), f2 - r2 * cos(n2 * x4)];
  }
  project.invert = function(x4, y4) {
    var fy = f2 - y4, r2 = sign(n2) * sqrt(x4 * x4 + fy * fy);
    return [atan2(x4, abs(fy)) / n2 * sign(fy), 2 * atan(pow(f2 / r2, 1 / n2)) - halfPi];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}
var init_conicConformal = __esm({
  "node_modules/d3-geo/src/projection/conicConformal.js"() {
    init_math();
    init_conic();
    init_mercator();
  }
});

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}
var init_equirectangular = __esm({
  "node_modules/d3-geo/src/projection/equirectangular.js"() {
    init_projection();
    equirectangularRaw.invert = equirectangularRaw;
  }
});

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y011, y16) {
  var cy0 = cos(y011), n2 = y011 === y16 ? sin(y011) : (cy0 - cos(y16)) / (y16 - y011), g2 = cy0 / n2 + y011;
  if (abs(n2) < epsilon)
    return equirectangularRaw;
  function project(x4, y4) {
    var gy = g2 - y4, nx = n2 * x4;
    return [gy * sin(nx), g2 - gy * cos(nx)];
  }
  project.invert = function(x4, y4) {
    var gy = g2 - y4;
    return [atan2(x4, abs(gy)) / n2 * sign(gy), g2 - sign(n2) * sqrt(x4 * x4 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}
var init_conicEquidistant = __esm({
  "node_modules/d3-geo/src/projection/conicEquidistant.js"() {
    init_math();
    init_conic();
    init_equirectangular();
  }
});

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x4, y4) {
  var cy = cos(y4), k4 = cos(x4) * cy;
  return [cy * sin(x4) / k4, sin(y4) / k4];
}
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}
var init_gnomonic = __esm({
  "node_modules/d3-geo/src/projection/gnomonic.js"() {
    init_math();
    init_azimuthal();
    init_projection();
    gnomonicRaw.invert = azimuthalInvert(atan);
  }
});

// node_modules/d3-geo/src/projection/identity.js
function scaleTranslate(kx3, ky2, tx, ty) {
  return kx3 === 1 && ky2 === 1 && tx === 0 && ty === 0 ? identity_default2 : transformer({
    point: function(x4, y4) {
      this.stream.point(x4 * kx3 + tx, y4 * ky2 + ty);
    }
  });
}
function identity_default3() {
  var k4 = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity_default2, x011 = null, y011, x16, y16, clip = identity_default2, cache, cacheStream, projection4;
  function reset() {
    cache = cacheStream = null;
    return projection4;
  }
  return projection4 = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));
    },
    clipExtent: function(_2) {
      return arguments.length ? (clip = _2 == null ? (x011 = y011 = x16 = y16 = null, identity_default2) : clipExtent(x011 = +_2[0][0], y011 = +_2[0][1], x16 = +_2[1][0], y16 = +_2[1][1]), reset()) : x011 == null ? null : [[x011, y011], [x16, y16]];
    },
    scale: function(_2) {
      return arguments.length ? (transform = scaleTranslate((k4 = +_2) * sx, k4 * sy, tx, ty), reset()) : k4;
    },
    translate: function(_2) {
      return arguments.length ? (transform = scaleTranslate(k4 * sx, k4 * sy, tx = +_2[0], ty = +_2[1]), reset()) : [tx, ty];
    },
    reflectX: function(_2) {
      return arguments.length ? (transform = scaleTranslate(k4 * (sx = _2 ? -1 : 1), k4 * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function(_2) {
      return arguments.length ? (transform = scaleTranslate(k4 * sx, k4 * (sy = _2 ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function(extent, object3) {
      return fitExtent(projection4, extent, object3);
    },
    fitSize: function(size, object3) {
      return fitSize(projection4, size, object3);
    }
  };
}
var init_identity3 = __esm({
  "node_modules/d3-geo/src/projection/identity.js"() {
    init_extent2();
    init_identity2();
    init_transform();
    init_fit();
  }
});

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x4, y4) {
  return [cos(y4) * sin(x4), sin(y4)];
}
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
}
var init_orthographic = __esm({
  "node_modules/d3-geo/src/projection/orthographic.js"() {
    init_math();
    init_azimuthal();
    init_projection();
    orthographicRaw.invert = azimuthalInvert(asin);
  }
});

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x4, y4) {
  var cy = cos(y4), k4 = 1 + cos(x4) * cy;
  return [cy * sin(x4) / k4, sin(y4) / k4];
}
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}
var init_stereographic = __esm({
  "node_modules/d3-geo/src/projection/stereographic.js"() {
    init_math();
    init_azimuthal();
    init_projection();
    stereographicRaw.invert = azimuthalInvert(function(z2) {
      return 2 * atan(z2);
    });
  }
});

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log(tan((halfPi + phi2) / 2)), -lambda];
}
function transverseMercator_default() {
  var m2 = mercatorProjection(transverseMercatorRaw), center2 = m2.center, rotate = m2.rotate;
  m2.center = function(_2) {
    return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
  };
  m2.rotate = function(_2) {
    return arguments.length ? rotate([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}
var init_transverseMercator = __esm({
  "node_modules/d3-geo/src/projection/transverseMercator.js"() {
    init_math();
    init_mercator();
    transverseMercatorRaw.invert = function(x4, y4) {
      return [-y4, 2 * atan(exp(x4)) - halfPi];
    };
  }
});

// node_modules/d3-geo/index.js
var d3_geo_exports = {};
__export(d3_geo_exports, {
  geoAlbers: () => albers_default,
  geoAlbersUsa: () => albersUsa_default,
  geoArea: () => area_default,
  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
  geoBounds: () => bounds_default,
  geoCentroid: () => centroid_default,
  geoCircle: () => circle_default,
  geoClipExtent: () => extent_default2,
  geoConicConformal: () => conicConformal_default,
  geoConicConformalRaw: () => conicConformalRaw,
  geoConicEqualArea: () => conicEqualArea_default,
  geoConicEqualAreaRaw: () => conicEqualAreaRaw,
  geoConicEquidistant: () => conicEquidistant_default,
  geoConicEquidistantRaw: () => conicEquidistantRaw,
  geoContains: () => contains_default,
  geoDistance: () => distance_default,
  geoEquirectangular: () => equirectangular_default,
  geoEquirectangularRaw: () => equirectangularRaw,
  geoGnomonic: () => gnomonic_default,
  geoGnomonicRaw: () => gnomonicRaw,
  geoGraticule: () => graticule,
  geoGraticule10: () => graticule10,
  geoIdentity: () => identity_default3,
  geoInterpolate: () => interpolate_default,
  geoLength: () => length_default,
  geoMercator: () => mercator_default,
  geoMercatorRaw: () => mercatorRaw,
  geoOrthographic: () => orthographic_default,
  geoOrthographicRaw: () => orthographicRaw,
  geoPath: () => path_default,
  geoProjection: () => projection,
  geoProjectionMutator: () => projectionMutator,
  geoRotation: () => rotation_default,
  geoStereographic: () => stereographic_default,
  geoStereographicRaw: () => stereographicRaw,
  geoStream: () => stream_default,
  geoTransform: () => transform_default,
  geoTransverseMercator: () => transverseMercator_default,
  geoTransverseMercatorRaw: () => transverseMercatorRaw
});
var init_d3_geo = __esm({
  "node_modules/d3-geo/index.js"() {
    init_area();
    init_bounds();
    init_centroid();
    init_circle();
    init_extent2();
    init_contains();
    init_distance();
    init_graticule();
    init_interpolate();
    init_length();
    init_path();
    init_albers();
    init_albersUsa();
    init_azimuthalEqualArea();
    init_azimuthalEquidistant();
    init_conicConformal();
    init_conicEqualArea();
    init_conicEquidistant();
    init_equirectangular();
    init_gnomonic();
    init_identity3();
    init_projection();
    init_mercator();
    init_orthographic();
    init_stereographic();
    init_transverseMercator();
    init_rotation();
    init_stream();
    init_transform();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/adder.js
function adder_default2() {
  return new Adder2();
}
function Adder2() {
  this.reset();
}
function add2(adder, a3, b2) {
  var x4 = adder.s = a3 + b2, bv = x4 - a3, av = x4 - bv;
  adder.t = a3 - av + (b2 - bv);
}
var temp2;
var init_adder2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/adder.js"() {
    Adder2.prototype = {
      constructor: Adder2,
      reset: function() {
        this.s = this.t = 0;
      },
      add: function(y4) {
        add2(temp2, y4, this.t);
        add2(this, temp2.s, this.s);
        if (this.s)
          this.t += temp2.t;
        else
          this.s = temp2.t;
      },
      valueOf: function() {
        return this.s;
      }
    };
    temp2 = new Adder2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js
function acos2(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi2 : Math.acos(x4);
}
function asin2(x4) {
  return x4 > 1 ? halfPi2 : x4 < -1 ? -halfPi2 : Math.asin(x4);
}
function haversin2(x4) {
  return (x4 = sin2(x4 / 2)) * x4;
}
var epsilon3, epsilon22, pi2, halfPi2, quarterPi2, tau2, degrees2, radians2, abs2, atan3, atan22, cos2, exp2, log2, sin2, sign2, sqrt2, tan2;
var init_math2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/math.js"() {
    epsilon3 = 1e-6;
    epsilon22 = 1e-12;
    pi2 = Math.PI;
    halfPi2 = pi2 / 2;
    quarterPi2 = pi2 / 4;
    tau2 = pi2 * 2;
    degrees2 = 180 / pi2;
    radians2 = pi2 / 180;
    abs2 = Math.abs;
    atan3 = Math.atan;
    atan22 = Math.atan2;
    cos2 = Math.cos;
    exp2 = Math.exp;
    log2 = Math.log;
    sin2 = Math.sin;
    sign2 = Math.sign || function(x4) {
      return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;
    };
    sqrt2 = Math.sqrt;
    tan2 = Math.tan;
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js
function noop2() {
}
var init_noop2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/noop.js"() {
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js
function streamGeometry2(geometry, stream) {
  if (geometry && streamGeometryType2.hasOwnProperty(geometry.type)) {
    streamGeometryType2[geometry.type](geometry, stream);
  }
}
function streamLine2(coordinates2, stream, closed) {
  var i2 = -1, n2 = coordinates2.length - closed, coordinate;
  stream.lineStart();
  while (++i2 < n2)
    coordinate = coordinates2[i2], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon2(coordinates2, stream) {
  var i2 = -1, n2 = coordinates2.length;
  stream.polygonStart();
  while (++i2 < n2)
    streamLine2(coordinates2[i2], stream, 1);
  stream.polygonEnd();
}
function stream_default2(object3, stream) {
  if (object3 && streamObjectType2.hasOwnProperty(object3.type)) {
    streamObjectType2[object3.type](object3, stream);
  } else {
    streamGeometry2(object3, stream);
  }
}
var streamObjectType2, streamGeometryType2;
var init_stream2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/stream.js"() {
    streamObjectType2 = {
      Feature: function(object3, stream) {
        streamGeometry2(object3.geometry, stream);
      },
      FeatureCollection: function(object3, stream) {
        var features = object3.features, i2 = -1, n2 = features.length;
        while (++i2 < n2)
          streamGeometry2(features[i2].geometry, stream);
      }
    };
    streamGeometryType2 = {
      Sphere: function(object3, stream) {
        stream.sphere();
      },
      Point: function(object3, stream) {
        object3 = object3.coordinates;
        stream.point(object3[0], object3[1], object3[2]);
      },
      MultiPoint: function(object3, stream) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          object3 = coordinates2[i2], stream.point(object3[0], object3[1], object3[2]);
      },
      LineString: function(object3, stream) {
        streamLine2(object3.coordinates, stream, 0);
      },
      MultiLineString: function(object3, stream) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          streamLine2(coordinates2[i2], stream, 0);
      },
      Polygon: function(object3, stream) {
        streamPolygon2(object3.coordinates, stream);
      },
      MultiPolygon: function(object3, stream) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          streamPolygon2(coordinates2[i2], stream);
      },
      GeometryCollection: function(object3, stream) {
        var geometries = object3.geometries, i2 = -1, n2 = geometries.length;
        while (++i2 < n2)
          streamGeometry2(geometries[i2], stream);
      }
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/area.js
function areaRingStart3() {
  areaStream3.point = areaPointFirst3;
}
function areaRingEnd3() {
  areaPoint3(lambda004, phi004);
}
function areaPointFirst3(lambda, phi2) {
  areaStream3.point = areaPoint3;
  lambda004 = lambda, phi004 = phi2;
  lambda *= radians2, phi2 *= radians2;
  lambda04 = lambda, cosPhi03 = cos2(phi2 = phi2 / 2 + quarterPi2), sinPhi03 = sin2(phi2);
}
function areaPoint3(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  phi2 = phi2 / 2 + quarterPi2;
  var dLambda = lambda - lambda04, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k4 = sinPhi03 * sinPhi, u2 = cosPhi03 * cosPhi + k4 * cos2(adLambda), v2 = k4 * sdLambda * sin2(adLambda);
  areaRingSum3.add(atan22(v2, u2));
  lambda04 = lambda, cosPhi03 = cosPhi, sinPhi03 = sinPhi;
}
var areaRingSum3, areaSum3, lambda004, phi004, lambda04, cosPhi03, sinPhi03, areaStream3;
var init_area3 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/area.js"() {
    init_adder2();
    init_math2();
    init_noop2();
    init_stream2();
    areaRingSum3 = adder_default2();
    areaSum3 = adder_default2();
    areaStream3 = {
      point: noop2,
      lineStart: noop2,
      lineEnd: noop2,
      polygonStart: function() {
        areaRingSum3.reset();
        areaStream3.lineStart = areaRingStart3;
        areaStream3.lineEnd = areaRingEnd3;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum3;
        areaSum3.add(areaRing < 0 ? tau2 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop2;
      },
      sphere: function() {
        areaSum3.add(tau2);
      }
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js
function spherical2(cartesian5) {
  return [atan22(cartesian5[1], cartesian5[0]), asin2(cartesian5[2])];
}
function cartesian2(spherical5) {
  var lambda = spherical5[0], phi2 = spherical5[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot2(a3, b2) {
  return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
}
function cartesianCross2(a3, b2) {
  return [a3[1] * b2[2] - a3[2] * b2[1], a3[2] * b2[0] - a3[0] * b2[2], a3[0] * b2[1] - a3[1] * b2[0]];
}
function cartesianAddInPlace2(a3, b2) {
  a3[0] += b2[0], a3[1] += b2[1], a3[2] += b2[2];
}
function cartesianScale2(vector, k4) {
  return [vector[0] * k4, vector[1] * k4, vector[2] * k4];
}
function cartesianNormalizeInPlace2(d2) {
  var l2 = sqrt2(d2[0] * d2[0] + d2[1] * d2[1] + d2[2] * d2[2]);
  d2[0] /= l2, d2[1] /= l2, d2[2] /= l2;
}
var init_cartesian2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/cartesian.js"() {
    init_math2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/bounds.js
function boundsPoint3(lambda, phi2) {
  ranges2.push(range2 = [lambda05 = lambda, lambda12 = lambda]);
  if (phi2 < phi02)
    phi02 = phi2;
  if (phi2 > phi12)
    phi12 = phi2;
}
function linePoint2(lambda, phi2) {
  var p2 = cartesian2([lambda * radians2, phi2 * radians2]);
  if (p02) {
    var normal = cartesianCross2(p02, p2), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross2(equatorial, normal);
    cartesianNormalizeInPlace2(inflection);
    inflection = spherical2(inflection);
    var delta = lambda - lambda22, sign6 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees2 * sign6, phii, antimeridian = abs2(delta) > 180;
    if (antimeridian ^ (sign6 * lambda22 < lambdai && lambdai < sign6 * lambda)) {
      phii = inflection[1] * degrees2;
      if (phii > phi12)
        phi12 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign6 * lambda22 < lambdai && lambdai < sign6 * lambda)) {
      phii = -inflection[1] * degrees2;
      if (phii < phi02)
        phi02 = phii;
    } else {
      if (phi2 < phi02)
        phi02 = phi2;
      if (phi2 > phi12)
        phi12 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda22) {
        if (angle2(lambda05, lambda) > angle2(lambda05, lambda12))
          lambda12 = lambda;
      } else {
        if (angle2(lambda, lambda12) > angle2(lambda05, lambda12))
          lambda05 = lambda;
      }
    } else {
      if (lambda12 >= lambda05) {
        if (lambda < lambda05)
          lambda05 = lambda;
        if (lambda > lambda12)
          lambda12 = lambda;
      } else {
        if (lambda > lambda22) {
          if (angle2(lambda05, lambda) > angle2(lambda05, lambda12))
            lambda12 = lambda;
        } else {
          if (angle2(lambda, lambda12) > angle2(lambda05, lambda12))
            lambda05 = lambda;
        }
      }
    }
  } else {
    ranges2.push(range2 = [lambda05 = lambda, lambda12 = lambda]);
  }
  if (phi2 < phi02)
    phi02 = phi2;
  if (phi2 > phi12)
    phi12 = phi2;
  p02 = p2, lambda22 = lambda;
}
function boundsLineStart2() {
  boundsStream3.point = linePoint2;
}
function boundsLineEnd2() {
  range2[0] = lambda05, range2[1] = lambda12;
  boundsStream3.point = boundsPoint3;
  p02 = null;
}
function boundsRingPoint2(lambda, phi2) {
  if (p02) {
    var delta = lambda - lambda22;
    deltaSum2.add(abs2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda005 = lambda, phi005 = phi2;
  }
  areaStream3.point(lambda, phi2);
  linePoint2(lambda, phi2);
}
function boundsRingStart2() {
  areaStream3.lineStart();
}
function boundsRingEnd2() {
  boundsRingPoint2(lambda005, phi005);
  areaStream3.lineEnd();
  if (abs2(deltaSum2) > epsilon3)
    lambda05 = -(lambda12 = 180);
  range2[0] = lambda05, range2[1] = lambda12;
  p02 = null;
}
function angle2(lambda06, lambda13) {
  return (lambda13 -= lambda06) < 0 ? lambda13 + 360 : lambda13;
}
function rangeCompare2(a3, b2) {
  return a3[0] - b2[0];
}
function rangeContains2(range3, x4) {
  return range3[0] <= range3[1] ? range3[0] <= x4 && x4 <= range3[1] : x4 < range3[0] || range3[1] < x4;
}
function bounds_default3(feature2) {
  var i2, n2, a3, b2, merged, deltaMax, delta;
  phi12 = lambda12 = -(lambda05 = phi02 = Infinity);
  ranges2 = [];
  stream_default2(feature2, boundsStream3);
  if (n2 = ranges2.length) {
    ranges2.sort(rangeCompare2);
    for (i2 = 1, a3 = ranges2[0], merged = [a3]; i2 < n2; ++i2) {
      b2 = ranges2[i2];
      if (rangeContains2(a3, b2[0]) || rangeContains2(a3, b2[1])) {
        if (angle2(a3[0], b2[1]) > angle2(a3[0], a3[1]))
          a3[1] = b2[1];
        if (angle2(b2[0], a3[1]) > angle2(a3[0], a3[1]))
          a3[0] = b2[0];
      } else {
        merged.push(a3 = b2);
      }
    }
    for (deltaMax = -Infinity, n2 = merged.length - 1, i2 = 0, a3 = merged[n2]; i2 <= n2; a3 = b2, ++i2) {
      b2 = merged[i2];
      if ((delta = angle2(a3[1], b2[0])) > deltaMax)
        deltaMax = delta, lambda05 = b2[0], lambda12 = a3[1];
    }
  }
  ranges2 = range2 = null;
  return lambda05 === Infinity || phi02 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda05, phi02], [lambda12, phi12]];
}
var lambda05, phi02, lambda12, phi12, lambda22, lambda005, phi005, p02, deltaSum2, ranges2, range2, boundsStream3;
var init_bounds3 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/bounds.js"() {
    init_adder2();
    init_area3();
    init_cartesian2();
    init_math2();
    init_stream2();
    deltaSum2 = adder_default2();
    boundsStream3 = {
      point: boundsPoint3,
      lineStart: boundsLineStart2,
      lineEnd: boundsLineEnd2,
      polygonStart: function() {
        boundsStream3.point = boundsRingPoint2;
        boundsStream3.lineStart = boundsRingStart2;
        boundsStream3.lineEnd = boundsRingEnd2;
        deltaSum2.reset();
        areaStream3.polygonStart();
      },
      polygonEnd: function() {
        areaStream3.polygonEnd();
        boundsStream3.point = boundsPoint3;
        boundsStream3.lineStart = boundsLineStart2;
        boundsStream3.lineEnd = boundsLineEnd2;
        if (areaRingSum3 < 0)
          lambda05 = -(lambda12 = 180), phi02 = -(phi12 = 90);
        else if (deltaSum2 > epsilon3)
          phi12 = 90;
        else if (deltaSum2 < -epsilon3)
          phi02 = -90;
        range2[0] = lambda05, range2[1] = lambda12;
      },
      sphere: function() {
        lambda05 = -(lambda12 = 180), phi02 = -(phi12 = 90);
      }
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/centroid.js
function centroidPoint3(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  centroidPointCartesian2(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));
}
function centroidPointCartesian2(x4, y4, z2) {
  ++W02;
  X03 += (x4 - X03) / W02;
  Y03 += (y4 - Y03) / W02;
  Z03 += (z2 - Z03) / W02;
}
function centroidLineStart3() {
  centroidStream3.point = centroidLinePointFirst2;
}
function centroidLinePointFirst2(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  x06 = cosPhi * cos2(lambda);
  y06 = cosPhi * sin2(lambda);
  z02 = sin2(phi2);
  centroidStream3.point = centroidLinePoint2;
  centroidPointCartesian2(x06, y06, z02);
}
function centroidLinePoint2(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z2 = sin2(phi2), w3 = atan22(sqrt2((w3 = y06 * z2 - z02 * y4) * w3 + (w3 = z02 * x4 - x06 * z2) * w3 + (w3 = x06 * y4 - y06 * x4) * w3), x06 * x4 + y06 * y4 + z02 * z2);
  W12 += w3;
  X13 += w3 * (x06 + (x06 = x4));
  Y13 += w3 * (y06 + (y06 = y4));
  Z13 += w3 * (z02 + (z02 = z2));
  centroidPointCartesian2(x06, y06, z02);
}
function centroidLineEnd3() {
  centroidStream3.point = centroidPoint3;
}
function centroidRingStart3() {
  centroidStream3.point = centroidRingPointFirst2;
}
function centroidRingEnd3() {
  centroidRingPoint2(lambda006, phi006);
  centroidStream3.point = centroidPoint3;
}
function centroidRingPointFirst2(lambda, phi2) {
  lambda006 = lambda, phi006 = phi2;
  lambda *= radians2, phi2 *= radians2;
  centroidStream3.point = centroidRingPoint2;
  var cosPhi = cos2(phi2);
  x06 = cosPhi * cos2(lambda);
  y06 = cosPhi * sin2(lambda);
  z02 = sin2(phi2);
  centroidPointCartesian2(x06, y06, z02);
}
function centroidRingPoint2(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x4 = cosPhi * cos2(lambda), y4 = cosPhi * sin2(lambda), z2 = sin2(phi2), cx = y06 * z2 - z02 * y4, cy = z02 * x4 - x06 * z2, cz = x06 * y4 - y06 * x4, m2 = sqrt2(cx * cx + cy * cy + cz * cz), w3 = asin2(m2), v2 = m2 && -w3 / m2;
  X23 += v2 * cx;
  Y23 += v2 * cy;
  Z23 += v2 * cz;
  W12 += w3;
  X13 += w3 * (x06 + (x06 = x4));
  Y13 += w3 * (y06 + (y06 = y4));
  Z13 += w3 * (z02 + (z02 = z2));
  centroidPointCartesian2(x06, y06, z02);
}
function centroid_default3(object3) {
  W02 = W12 = X03 = Y03 = Z03 = X13 = Y13 = Z13 = X23 = Y23 = Z23 = 0;
  stream_default2(object3, centroidStream3);
  var x4 = X23, y4 = Y23, z2 = Z23, m2 = x4 * x4 + y4 * y4 + z2 * z2;
  if (m2 < epsilon22) {
    x4 = X13, y4 = Y13, z2 = Z13;
    if (W12 < epsilon3)
      x4 = X03, y4 = Y03, z2 = Z03;
    m2 = x4 * x4 + y4 * y4 + z2 * z2;
    if (m2 < epsilon22)
      return [NaN, NaN];
  }
  return [atan22(y4, x4) * degrees2, asin2(z2 / sqrt2(m2)) * degrees2];
}
var W02, W12, X03, Y03, Z03, X13, Y13, Z13, X23, Y23, Z23, lambda006, phi006, x06, y06, z02, centroidStream3;
var init_centroid3 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/centroid.js"() {
    init_math2();
    init_noop2();
    init_stream2();
    centroidStream3 = {
      sphere: noop2,
      point: centroidPoint3,
      lineStart: centroidLineStart3,
      lineEnd: centroidLineEnd3,
      polygonStart: function() {
        centroidStream3.lineStart = centroidRingStart3;
        centroidStream3.lineEnd = centroidRingEnd3;
      },
      polygonEnd: function() {
        centroidStream3.lineStart = centroidLineStart3;
        centroidStream3.lineEnd = centroidLineEnd3;
      }
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js
function constant_default3(x4) {
  return function() {
    return x4;
  };
}
var init_constant3 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/constant.js"() {
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js
function compose_default2(a3, b2) {
  function compose(x4, y4) {
    return x4 = a3(x4, y4), b2(x4[0], x4[1]);
  }
  if (a3.invert && b2.invert)
    compose.invert = function(x4, y4) {
      return x4 = b2.invert(x4, y4), x4 && a3.invert(x4[0], x4[1]);
    };
  return compose;
}
var init_compose2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/compose.js"() {
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js
function rotationIdentity2(lambda, phi2) {
  return [abs2(lambda) > pi2 ? lambda + Math.round(-lambda / tau2) * tau2 : lambda, phi2];
}
function rotateRadians2(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau2) ? deltaPhi || deltaGamma ? compose_default2(rotationLambda2(deltaLambda), rotationPhiGamma2(deltaPhi, deltaGamma)) : rotationLambda2(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma2(deltaPhi, deltaGamma) : rotationIdentity2;
}
function forwardRotationLambda2(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi2 ? lambda - tau2 : lambda < -pi2 ? lambda + tau2 : lambda, phi2];
  };
}
function rotationLambda2(deltaLambda) {
  var rotation = forwardRotationLambda2(deltaLambda);
  rotation.invert = forwardRotationLambda2(-deltaLambda);
  return rotation;
}
function rotationPhiGamma2(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z2 = sin2(phi2), k4 = z2 * cosDeltaPhi + x4 * sinDeltaPhi;
    return [
      atan22(y4 * cosDeltaGamma - k4 * sinDeltaGamma, x4 * cosDeltaPhi - z2 * sinDeltaPhi),
      asin2(k4 * cosDeltaGamma + y4 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x4 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z2 = sin2(phi2), k4 = z2 * cosDeltaGamma - y4 * sinDeltaGamma;
    return [
      atan22(y4 * cosDeltaGamma + z2 * sinDeltaGamma, x4 * cosDeltaPhi + k4 * sinDeltaPhi),
      asin2(k4 * cosDeltaPhi - x4 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default2(rotate) {
  rotate = rotateRadians2(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
  function forward(coordinates2) {
    coordinates2 = rotate(coordinates2[0] * radians2, coordinates2[1] * radians2);
    return coordinates2[0] *= degrees2, coordinates2[1] *= degrees2, coordinates2;
  }
  forward.invert = function(coordinates2) {
    coordinates2 = rotate.invert(coordinates2[0] * radians2, coordinates2[1] * radians2);
    return coordinates2[0] *= degrees2, coordinates2[1] *= degrees2, coordinates2;
  };
  return forward;
}
var init_rotation2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/rotation.js"() {
    init_compose2();
    init_math2();
    rotationIdentity2.invert = rotationIdentity2;
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js
function circleStream2(stream, radius, delta, direction, t0, t1) {
  if (!delta)
    return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau2;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius2(cosRadius, t0);
    t1 = circleRadius2(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1)
      t0 += direction * tau2;
  }
  for (var point5, t2 = t0; direction > 0 ? t2 > t1 : t2 < t1; t2 -= step) {
    point5 = spherical2([cosRadius, -sinRadius * cos2(t2), -sinRadius * sin2(t2)]);
    stream.point(point5[0], point5[1]);
  }
}
function circleRadius2(cosRadius, point5) {
  point5 = cartesian2(point5), point5[0] -= cosRadius;
  cartesianNormalizeInPlace2(point5);
  var radius = acos2(-point5[1]);
  return ((-point5[2] < 0 ? -radius : radius) + tau2 - epsilon3) % tau2;
}
function circle_default3() {
  var center2 = constant_default3([0, 0]), radius = constant_default3(90), precision = constant_default3(6), ring, rotate, stream = { point: point5 };
  function point5(x4, y4) {
    ring.push(x4 = rotate(x4, y4));
    x4[0] *= degrees2, x4[1] *= degrees2;
  }
  function circle4() {
    var c2 = center2.apply(this, arguments), r2 = radius.apply(this, arguments) * radians2, p2 = precision.apply(this, arguments) * radians2;
    ring = [];
    rotate = rotateRadians2(-c2[0] * radians2, -c2[1] * radians2, 0).invert;
    circleStream2(stream, r2, p2, 1);
    c2 = { type: "Polygon", coordinates: [ring] };
    ring = rotate = null;
    return c2;
  }
  circle4.center = function(_2) {
    return arguments.length ? (center2 = typeof _2 === "function" ? _2 : constant_default3([+_2[0], +_2[1]]), circle4) : center2;
  };
  circle4.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default3(+_2), circle4) : radius;
  };
  circle4.precision = function(_2) {
    return arguments.length ? (precision = typeof _2 === "function" ? _2 : constant_default3(+_2), circle4) : precision;
  };
  return circle4;
}
var init_circle3 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/circle.js"() {
    init_cartesian2();
    init_constant3();
    init_math2();
    init_rotation2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js
function buffer_default2() {
  var lines2 = [], line;
  return {
    point: function(x4, y4, m2) {
      line.push([x4, y4, m2]);
    },
    lineStart: function() {
      lines2.push(line = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines2.length > 1)
        lines2.push(lines2.pop().concat(lines2.shift()));
    },
    result: function() {
      var result = lines2;
      lines2 = [];
      line = null;
      return result;
    }
  };
}
var init_buffer2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/buffer.js"() {
    init_noop2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js
function pointEqual_default2(a3, b2) {
  return abs2(a3[0] - b2[0]) < epsilon3 && abs2(a3[1] - b2[1]) < epsilon3;
}
var init_pointEqual2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/pointEqual.js"() {
    init_math2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js
function Intersection2(point5, points2, other, entry) {
  this.x = point5;
  this.z = points2;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection4, startInside, interpolate, stream) {
  var subject = [], clip = [], i2, n2;
  segments.forEach(function(segment) {
    if ((n3 = segment.length - 1) <= 0)
      return;
    var n3, p03 = segment[0], p1 = segment[n3], x4;
    if (pointEqual_default2(p03, p1)) {
      if (!p03[2] && !p1[2]) {
        stream.lineStart();
        for (i2 = 0; i2 < n3; ++i2)
          stream.point((p03 = segment[i2])[0], p03[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon3;
    }
    subject.push(x4 = new Intersection2(p03, segment, null, true));
    clip.push(x4.o = new Intersection2(p03, null, x4, false));
    subject.push(x4 = new Intersection2(p1, segment, null, false));
    clip.push(x4.o = new Intersection2(p1, null, x4, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection4);
  link2(subject);
  link2(clip);
  for (i2 = 0, n2 = clip.length; i2 < n2; ++i2) {
    clip[i2].e = startInside = !startInside;
  }
  var start = subject[0], points2, point5;
  while (1) {
    var current = start, isSubject = true;
    while (current.v)
      if ((current = current.n) === start)
        return;
    points2 = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i2 = 0, n2 = points2.length; i2 < n2; ++i2)
            stream.point((point5 = points2[i2])[0], point5[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points2 = current.p.z;
          for (i2 = points2.length - 1; i2 >= 0; --i2)
            stream.point((point5 = points2[i2])[0], point5[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points2 = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link2(array3) {
  if (!(n2 = array3.length))
    return;
  var n2, i2 = 0, a3 = array3[0], b2;
  while (++i2 < n2) {
    a3.n = b2 = array3[i2];
    b2.p = a3;
    a3 = b2;
  }
  a3.n = b2 = array3[0];
  b2.p = a3;
}
var init_rejoin = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rejoin.js"() {
    init_pointEqual2();
    init_math2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js
function longitude(point5) {
  if (abs2(point5[0]) <= pi2)
    return point5[0];
  else
    return sign2(point5[0]) * ((abs2(point5[0]) + pi2) % tau2 - pi2);
}
function polygonContains_default2(polygon, point5) {
  var lambda = longitude(point5), phi2 = point5[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle5 = 0, winding = 0;
  sum2.reset();
  if (sinPhi === 1)
    phi2 = halfPi2 + epsilon3;
  else if (sinPhi === -1)
    phi2 = -halfPi2 - epsilon3;
  for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
    if (!(m2 = (ring = polygon[i2]).length))
      continue;
    var ring, m2, point0 = ring[m2 - 1], lambda06 = longitude(point0), phi04 = point0[1] / 2 + quarterPi2, sinPhi04 = sin2(phi04), cosPhi04 = cos2(phi04);
    for (var j2 = 0; j2 < m2; ++j2, lambda06 = lambda13, sinPhi04 = sinPhi1, cosPhi04 = cosPhi1, point0 = point1) {
      var point1 = ring[j2], lambda13 = longitude(point1), phi13 = point1[1] / 2 + quarterPi2, sinPhi1 = sin2(phi13), cosPhi1 = cos2(phi13), delta = lambda13 - lambda06, sign6 = delta >= 0 ? 1 : -1, absDelta = sign6 * delta, antimeridian = absDelta > pi2, k4 = sinPhi04 * sinPhi1;
      sum2.add(atan22(k4 * sign6 * sin2(absDelta), cosPhi04 * cosPhi1 + k4 * cos2(absDelta)));
      angle5 += antimeridian ? delta + sign6 * tau2 : delta;
      if (antimeridian ^ lambda06 >= lambda ^ lambda13 >= lambda) {
        var arc = cartesianCross2(cartesian2(point0), cartesian2(point1));
        cartesianNormalizeInPlace2(arc);
        var intersection2 = cartesianCross2(normal, arc);
        cartesianNormalizeInPlace2(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle5 < -epsilon3 || angle5 < epsilon3 && sum2 < -epsilon3) ^ winding & 1;
}
var sum2;
var init_polygonContains2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/polygonContains.js"() {
    init_adder2();
    init_cartesian2();
    init_math2();
    sum2 = adder_default2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js
function clip_default2(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default2(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point5;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge_default(segments);
        var startInside = polygonContains_default2(polygon, start);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection2, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point5(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point5;
      line.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i2, n2 = ringSegments.length, m2, segment, point6;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n2)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i2 = 0; i2 < m2; ++i2)
            sink.point((point6 = segment[i2])[0], point6[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n2 > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment2));
    }
    return clip;
  };
}
function validSegment2(segment) {
  return segment.length > 1;
}
function compareIntersection2(a3, b2) {
  return ((a3 = a3.x)[0] < 0 ? a3[1] - halfPi2 - epsilon3 : halfPi2 - a3[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi2 - epsilon3 : halfPi2 - b2[1]);
}
var init_clip2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/index.js"() {
    init_buffer2();
    init_rejoin();
    init_math2();
    init_polygonContains2();
    init_src();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js
function clipAntimeridianLine2(stream) {
  var lambda06 = NaN, phi04 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda13, phi13) {
      var sign1 = lambda13 > 0 ? pi2 : -pi2, delta = abs2(lambda13 - lambda06);
      if (abs2(delta - pi2) < epsilon3) {
        stream.point(lambda06, phi04 = (phi04 + phi13) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi04);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi04);
        stream.point(lambda13, phi04);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi2) {
        if (abs2(lambda06 - sign0) < epsilon3)
          lambda06 -= sign0 * epsilon3;
        if (abs2(lambda13 - sign1) < epsilon3)
          lambda13 -= sign1 * epsilon3;
        phi04 = clipAntimeridianIntersect2(lambda06, phi04, lambda13, phi13);
        stream.point(sign0, phi04);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi04);
        clean = 0;
      }
      stream.point(lambda06 = lambda13, phi04 = phi13);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda06 = phi04 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect2(lambda06, phi04, lambda13, phi13) {
  var cosPhi04, cosPhi1, sinLambda0Lambda1 = sin2(lambda06 - lambda13);
  return abs2(sinLambda0Lambda1) > epsilon3 ? atan3((sin2(phi04) * (cosPhi1 = cos2(phi13)) * sin2(lambda13) - sin2(phi13) * (cosPhi04 = cos2(phi04)) * sin2(lambda06)) / (cosPhi04 * cosPhi1 * sinLambda0Lambda1)) : (phi04 + phi13) / 2;
}
function clipAntimeridianInterpolate2(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi2;
    stream.point(-pi2, phi2);
    stream.point(0, phi2);
    stream.point(pi2, phi2);
    stream.point(pi2, 0);
    stream.point(pi2, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi2, -phi2);
    stream.point(-pi2, 0);
    stream.point(-pi2, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon3) {
    var lambda = from[0] < to[0] ? pi2 : -pi2;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}
var antimeridian_default2;
var init_antimeridian2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/antimeridian.js"() {
    init_clip2();
    init_math2();
    antimeridian_default2 = clip_default2(function() {
      return true;
    }, clipAntimeridianLine2, clipAntimeridianInterpolate2, [-pi2, -halfPi2]);
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js
function circle_default4(radius) {
  var cr = cos2(radius), delta = 6 * radians2, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
  function interpolate(from, to, direction, stream) {
    circleStream2(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v2 = visible(lambda, phi2), c2 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi2 : -pi2), phi2) : 0;
        if (!point0 && (v00 = v0 = v2))
          stream.lineStart();
        if (v2 !== v0) {
          point22 = intersect(point0, point1);
          if (!point22 || pointEqual_default2(point0, point22) || pointEqual_default2(point1, point22))
            point1[2] = 1;
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream.lineStart();
            point22 = intersect(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t2;
          if (!(c2 & c0) && (t2 = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t2[0][0], t2[0][1]);
              stream.point(t2[1][0], t2[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t2[1][0], t2[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t2[0][0], t2[0][1], 3);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default2(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c2;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect(a3, b2, two) {
    var pa = cartesian2(a3), pb = cartesian2(b2);
    var n1 = [1, 0, 0], n2 = cartesianCross2(pa, pb), n2n2 = cartesianDot2(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a3;
    var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross2(n1, n2), A6 = cartesianScale2(n1, c1), B3 = cartesianScale2(n2, c2);
    cartesianAddInPlace2(A6, B3);
    var u2 = n1xn2, w3 = cartesianDot2(A6, u2), uu = cartesianDot2(u2, u2), t2 = w3 * w3 - uu * (cartesianDot2(A6, A6) - 1);
    if (t2 < 0)
      return;
    var t3 = sqrt2(t2), q2 = cartesianScale2(u2, (-w3 - t3) / uu);
    cartesianAddInPlace2(q2, A6);
    q2 = spherical2(q2);
    if (!two)
      return q2;
    var lambda06 = a3[0], lambda13 = b2[0], phi04 = a3[1], phi13 = b2[1], z2;
    if (lambda13 < lambda06)
      z2 = lambda06, lambda06 = lambda13, lambda13 = z2;
    var delta2 = lambda13 - lambda06, polar = abs2(delta2 - pi2) < epsilon3, meridian = polar || delta2 < epsilon3;
    if (!polar && phi13 < phi04)
      z2 = phi04, phi04 = phi13, phi13 = z2;
    if (meridian ? polar ? phi04 + phi13 > 0 ^ q2[1] < (abs2(q2[0] - lambda06) < epsilon3 ? phi04 : phi13) : phi04 <= q2[1] && q2[1] <= phi13 : delta2 > pi2 ^ (lambda06 <= q2[0] && q2[0] <= lambda13)) {
      var q1 = cartesianScale2(u2, (-w3 + t3) / uu);
      cartesianAddInPlace2(q1, A6);
      return [q2, spherical2(q1)];
    }
  }
  function code(lambda, phi2) {
    var r2 = smallRadius ? radius : pi2 - radius, code2 = 0;
    if (lambda < -r2)
      code2 |= 1;
    else if (lambda > r2)
      code2 |= 2;
    if (phi2 < -r2)
      code2 |= 4;
    else if (phi2 > r2)
      code2 |= 8;
    return code2;
  }
  return clip_default2(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi2, radius - pi2]);
}
var init_circle4 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/circle.js"() {
    init_cartesian2();
    init_circle3();
    init_math2();
    init_pointEqual2();
    init_clip2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js
function line_default2(a3, b2, x011, y011, x16, y16) {
  var ax = a3[0], ay = a3[1], bx = b2[0], by = b2[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x011 - ax;
  if (!dx && r2 > 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  } else if (dx > 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  }
  r2 = x16 - ax;
  if (!dx && r2 < 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  } else if (dx > 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  }
  r2 = y011 - ay;
  if (!dy && r2 > 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  } else if (dy > 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  }
  r2 = y16 - ay;
  if (!dy && r2 < 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  } else if (dy > 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  }
  if (t0 > 0)
    a3[0] = ax + t0 * dx, a3[1] = ay + t0 * dy;
  if (t1 < 1)
    b2[0] = ax + t1 * dx, b2[1] = ay + t1 * dy;
  return true;
}
var init_line2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/line.js"() {
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js
function clipRectangle(x011, y011, x16, y16) {
  function visible(x4, y4) {
    return x011 <= x4 && x4 <= x16 && y011 <= y4 && y4 <= y16;
  }
  function interpolate(from, to, direction, stream) {
    var a3 = 0, a1 = 0;
    if (from == null || (a3 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a3 === 0 || a3 === 3 ? x011 : x16, a3 > 1 ? y16 : y011);
      while ((a3 = (a3 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p2, direction) {
    return abs2(p2[0] - x011) < epsilon3 ? direction > 0 ? 0 : 3 : abs2(p2[0] - x16) < epsilon3 ? direction > 0 ? 2 : 1 : abs2(p2[1] - y011) < epsilon3 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection4(a3, b2) {
    return comparePoint(a3.x, b2.x);
  }
  function comparePoint(a3, b2) {
    var ca = corner(a3, 1), cb = corner(b2, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a3[1] : ca === 1 ? a3[0] - b2[0] : ca === 2 ? a3[1] - b2[1] : b2[0] - a3[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default2(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point5(x4, y4) {
      if (visible(x4, y4))
        activeStream.point(x4, y4);
    }
    function polygonInside() {
      var winding = 0;
      for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
        for (var ring2 = polygon[i2], j2 = 1, m2 = ring2.length, point6 = ring2[0], a0, a1, b0 = point6[0], b1 = point6[1]; j2 < m2; ++j2) {
          a0 = b0, a1 = b1, point6 = ring2[j2], b0 = point6[0], b1 = point6[1];
          if (a1 <= y16) {
            if (b1 > y16 && (b0 - a0) * (y16 - a1) > (b1 - a1) * (x011 - a0))
              ++winding;
          } else {
            if (b1 <= y16 && (b0 - a0) * (y16 - a1) < (b1 - a1) * (x011 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge_default(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection4, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint3;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint3(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point5;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint3(x4, y4) {
      var v2 = visible(x4, y4);
      if (polygon)
        ring.push([x4, y4]);
      if (first) {
        x__ = x4, y__ = y4, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x4, y4);
        }
      } else {
        if (v2 && v_)
          activeStream.point(x4, y4);
        else {
          var a3 = [x_ = Math.max(clipMin2, Math.min(clipMax2, x_)), y_ = Math.max(clipMin2, Math.min(clipMax2, y_))], b2 = [x4 = Math.max(clipMin2, Math.min(clipMax2, x4)), y4 = Math.max(clipMin2, Math.min(clipMax2, y4))];
          if (line_default2(a3, b2, x011, y011, x16, y16)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a3[0], a3[1]);
            }
            activeStream.point(b2[0], b2[1]);
            if (!v2)
              activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x4, y4);
            clean = false;
          }
        }
      }
      x_ = x4, y_ = y4, v_ = v2;
    }
    return clipStream;
  };
}
var clipMax2, clipMin2;
var init_rectangle = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/rectangle.js"() {
    init_math2();
    init_buffer2();
    init_line2();
    init_rejoin();
    init_src();
    clipMax2 = 1e9;
    clipMin2 = -clipMax2;
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/extent.js
var init_extent3 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/clip/extent.js"() {
    init_rectangle();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/length.js
var lengthSum3;
var init_length2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/length.js"() {
    init_adder2();
    init_math2();
    init_noop2();
    init_stream2();
    lengthSum3 = adder_default2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/distance.js
var init_distance2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/distance.js"() {
    init_length2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/contains.js
var init_contains2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/contains.js"() {
    init_polygonContains2();
    init_distance2();
    init_math2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/graticule.js
var init_graticule2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/graticule.js"() {
    init_src();
    init_math2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/interpolate.js
function interpolate_default2(a3, b2) {
  var x011 = a3[0] * radians2, y011 = a3[1] * radians2, x16 = b2[0] * radians2, y16 = b2[1] * radians2, cy0 = cos2(y011), sy0 = sin2(y011), cy1 = cos2(y16), sy1 = sin2(y16), kx0 = cy0 * cos2(x011), ky0 = cy0 * sin2(x011), kx1 = cy1 * cos2(x16), ky1 = cy1 * sin2(x16), d2 = 2 * asin2(sqrt2(haversin2(y16 - y011) + cy0 * cy1 * haversin2(x16 - x011))), k4 = sin2(d2);
  var interpolate = d2 ? function(t2) {
    var B3 = sin2(t2 *= d2) / k4, A6 = sin2(d2 - t2) / k4, x4 = A6 * kx0 + B3 * kx1, y4 = A6 * ky0 + B3 * ky1, z2 = A6 * sy0 + B3 * sy1;
    return [
      atan22(y4, x4) * degrees2,
      atan22(z2, sqrt2(x4 * x4 + y4 * y4)) * degrees2
    ];
  } : function() {
    return [x011 * degrees2, y011 * degrees2];
  };
  interpolate.distance = d2;
  return interpolate;
}
var init_interpolate2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/interpolate.js"() {
    init_math2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js
function identity_default4(x4) {
  return x4;
}
var init_identity4 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/identity.js"() {
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/path/area.js
var areaSum4, areaRingSum4;
var init_area4 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/path/area.js"() {
    init_adder2();
    init_math2();
    init_noop2();
    areaSum4 = adder_default2();
    areaRingSum4 = adder_default2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js
function boundsPoint4(x4, y4) {
  if (x4 < x07)
    x07 = x4;
  if (x4 > x12)
    x12 = x4;
  if (y4 < y07)
    y07 = y4;
  if (y4 > y12)
    y12 = y4;
}
var x07, y07, x12, y12, boundsStream4, bounds_default4;
var init_bounds4 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/path/bounds.js"() {
    init_noop2();
    x07 = Infinity;
    y07 = x07;
    x12 = -x07;
    y12 = x12;
    boundsStream4 = {
      point: boundsPoint4,
      lineStart: noop2,
      lineEnd: noop2,
      polygonStart: noop2,
      polygonEnd: noop2,
      result: function() {
        var bounds = [[x07, y07], [x12, y12]];
        x12 = y12 = -(y07 = x07 = Infinity);
        return bounds;
      }
    };
    bounds_default4 = boundsStream4;
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/path/centroid.js
var init_centroid4 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/path/centroid.js"() {
    init_math2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/path/context.js
function PathContext2(context) {
  this._context = context;
}
var init_context2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/path/context.js"() {
    init_math2();
    init_noop2();
    PathContext2.prototype = {
      _radius: 4.5,
      pointRadius: function(_2) {
        return this._radius = _2, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._context.closePath();
        this._point = NaN;
      },
      point: function(x4, y4) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x4, y4);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x4, y4);
            break;
          }
          default: {
            this._context.moveTo(x4 + this._radius, y4);
            this._context.arc(x4, y4, this._radius, 0, tau2);
            break;
          }
        }
      },
      result: noop2
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/path/measure.js
var lengthSum4;
var init_measure2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/path/measure.js"() {
    init_adder2();
    init_math2();
    init_noop2();
    lengthSum4 = adder_default2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/path/string.js
function PathString2() {
  this._string = [];
}
function circle2(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}
var init_string2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/path/string.js"() {
    PathString2.prototype = {
      _radius: 4.5,
      _circle: circle2(4.5),
      pointRadius: function(_2) {
        if ((_2 = +_2) !== this._radius)
          this._radius = _2, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._string.push("Z");
        this._point = NaN;
      },
      point: function(x4, y4) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x4, ",", y4);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x4, ",", y4);
            break;
          }
          default: {
            if (this._circle == null)
              this._circle = circle2(this._radius);
            this._string.push("M", x4, ",", y4, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/path/index.js
var init_path2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/path/index.js"() {
    init_identity4();
    init_stream2();
    init_area4();
    init_bounds4();
    init_centroid4();
    init_context2();
    init_measure2();
    init_string2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js
function transformer2(methods) {
  return function(stream) {
    var s3 = new TransformStream2();
    for (var key in methods)
      s3[key] = methods[key];
    s3.stream = stream;
    return s3;
  };
}
function TransformStream2() {
}
var init_transform2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/transform.js"() {
    TransformStream2.prototype = {
      constructor: TransformStream2,
      point: function(x4, y4) {
        this.stream.point(x4, y4);
      },
      sphere: function() {
        this.stream.sphere();
      },
      lineStart: function() {
        this.stream.lineStart();
      },
      lineEnd: function() {
        this.stream.lineEnd();
      },
      polygonStart: function() {
        this.stream.polygonStart();
      },
      polygonEnd: function() {
        this.stream.polygonEnd();
      }
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js
function fit(projection4, fitBounds, object3) {
  var clip = projection4.clipExtent && projection4.clipExtent();
  projection4.scale(150).translate([0, 0]);
  if (clip != null)
    projection4.clipExtent(null);
  stream_default2(object3, projection4.stream(bounds_default4));
  fitBounds(bounds_default4.result());
  if (clip != null)
    projection4.clipExtent(clip);
  return projection4;
}
function fitExtent2(projection4, extent, object3) {
  return fit(projection4, function(b2) {
    var w3 = extent[1][0] - extent[0][0], h2 = extent[1][1] - extent[0][1], k4 = Math.min(w3 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x4 = +extent[0][0] + (w3 - k4 * (b2[1][0] + b2[0][0])) / 2, y4 = +extent[0][1] + (h2 - k4 * (b2[1][1] + b2[0][1])) / 2;
    projection4.scale(150 * k4).translate([x4, y4]);
  }, object3);
}
function fitSize2(projection4, size, object3) {
  return fitExtent2(projection4, [[0, 0], size], object3);
}
function fitWidth(projection4, width, object3) {
  return fit(projection4, function(b2) {
    var w3 = +width, k4 = w3 / (b2[1][0] - b2[0][0]), x4 = (w3 - k4 * (b2[1][0] + b2[0][0])) / 2, y4 = -k4 * b2[0][1];
    projection4.scale(150 * k4).translate([x4, y4]);
  }, object3);
}
function fitHeight(projection4, height, object3) {
  return fit(projection4, function(b2) {
    var h2 = +height, k4 = h2 / (b2[1][1] - b2[0][1]), x4 = -k4 * b2[0][0], y4 = (h2 - k4 * (b2[1][1] + b2[0][1])) / 2;
    projection4.scale(150 * k4).translate([x4, y4]);
  }, object3);
}
var init_fit2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/fit.js"() {
    init_stream2();
    init_bounds4();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js
function resample_default2(project, delta2) {
  return +delta2 ? resample2(project, delta2) : resampleNone2(project);
}
function resampleNone2(project) {
  return transformer2({
    point: function(x4, y4) {
      x4 = project(x4, y4);
      this.stream.point(x4[0], x4[1]);
    }
  });
}
function resample2(project, delta2) {
  function resampleLineTo(x011, y011, lambda06, a0, b0, c0, x16, y16, lambda13, a1, b1, c1, depth, stream) {
    var dx = x16 - x011, dy = y16 - y011, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a3 = a0 + a1, b2 = b0 + b1, c2 = c0 + c1, m2 = sqrt2(a3 * a3 + b2 * b2 + c2 * c2), phi2 = asin2(c2 /= m2), lambda23 = abs2(abs2(c2) - 1) < epsilon3 || abs2(lambda06 - lambda13) < epsilon3 ? (lambda06 + lambda13) / 2 : atan22(b2, a3), p2 = project(lambda23, phi2), x22 = p2[0], y22 = p2[1], dx2 = x22 - x011, dy2 = y22 - y011, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance2) {
        resampleLineTo(x011, y011, lambda06, a0, b0, c0, x22, y22, lambda23, a3 /= m2, b2 /= m2, c2, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda23, a3, b2, c2, x16, y16, lambda13, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda007, x004, y004, a00, b00, c00, lambda06, x011, y011, a0, b0, c0;
    var resampleStream = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point5(x4, y4) {
      x4 = project(x4, y4);
      stream.point(x4[0], x4[1]);
    }
    function lineStart() {
      x011 = NaN;
      resampleStream.point = linePoint3;
      stream.lineStart();
    }
    function linePoint3(lambda, phi2) {
      var c2 = cartesian2([lambda, phi2]), p2 = project(lambda, phi2);
      resampleLineTo(x011, y011, lambda06, a0, b0, c0, x011 = p2[0], y011 = p2[1], lambda06 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth2, stream);
      stream.point(x011, y011);
    }
    function lineEnd() {
      resampleStream.point = point5;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint3(lambda007 = lambda, phi2), x004 = x011, y004 = y011, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint3;
    }
    function ringEnd() {
      resampleLineTo(x011, y011, lambda06, a0, b0, c0, x004, y004, lambda007, a00, b00, c00, maxDepth2, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}
var maxDepth2, cosMinDistance2;
var init_resample2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/resample.js"() {
    init_cartesian2();
    init_math2();
    init_transform2();
    maxDepth2 = 16;
    cosMinDistance2 = cos2(30 * radians2);
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js
function transformRotate(rotate) {
  return transformer2({
    point: function(x4, y4) {
      var r2 = rotate(x4, y4);
      return this.stream.point(r2[0], r2[1]);
    }
  });
}
function scaleTranslate2(k4, dx, dy, sx, sy) {
  function transform(x4, y4) {
    x4 *= sx;
    y4 *= sy;
    return [dx + k4 * x4, dy - k4 * y4];
  }
  transform.invert = function(x4, y4) {
    return [(x4 - dx) / k4 * sx, (dy - y4) / k4 * sy];
  };
  return transform;
}
function scaleTranslateRotate(k4, dx, dy, sx, sy, alpha) {
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a3 = cosAlpha * k4, b2 = sinAlpha * k4, ai = cosAlpha / k4, bi = sinAlpha / k4, ci = (sinAlpha * dy - cosAlpha * dx) / k4, fi = (sinAlpha * dx + cosAlpha * dy) / k4;
  function transform(x4, y4) {
    x4 *= sx;
    y4 *= sy;
    return [a3 * x4 - b2 * y4 + dx, dy - b2 * x4 - a3 * y4];
  }
  transform.invert = function(x4, y4) {
    return [sx * (ai * x4 - bi * y4 + ci), sy * (fi - bi * x4 - ai * y4)];
  };
  return transform;
}
function projection2(project) {
  return projectionMutator2(function() {
    return project;
  })();
}
function projectionMutator2(projectAt) {
  var project, k4 = 150, x4 = 480, y4 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default2, x011 = null, y011, x16, y16, postclip = identity_default4, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection4(point5) {
    return projectRotateTransform(point5[0] * radians2, point5[1] * radians2);
  }
  function invert(point5) {
    point5 = projectRotateTransform.invert(point5[0], point5[1]);
    return point5 && [point5[0] * degrees2, point5[1] * degrees2];
  }
  projection4.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians2(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection4.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
  };
  projection4.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x011 = y011 = x16 = y16 = null, reset()) : postclip;
  };
  projection4.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? circle_default4(theta = _2 * radians2) : (theta = null, antimeridian_default2), reset()) : theta * degrees2;
  };
  projection4.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x011 = y011 = x16 = y16 = null, identity_default4) : clipRectangle(x011 = +_2[0][0], y011 = +_2[0][1], x16 = +_2[1][0], y16 = +_2[1][1]), reset()) : x011 == null ? null : [[x011, y011], [x16, y16]];
  };
  projection4.scale = function(_2) {
    return arguments.length ? (k4 = +_2, recenter()) : k4;
  };
  projection4.translate = function(_2) {
    return arguments.length ? (x4 = +_2[0], y4 = +_2[1], recenter()) : [x4, y4];
  };
  projection4.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians2, phi2 = _2[1] % 360 * radians2, recenter()) : [lambda * degrees2, phi2 * degrees2];
  };
  projection4.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians2, deltaPhi = _2[1] % 360 * radians2, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees2, deltaPhi * degrees2, deltaGamma * degrees2];
  };
  projection4.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians2, recenter()) : alpha * degrees2;
  };
  projection4.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection4.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection4.precision = function(_2) {
    return arguments.length ? (projectResample = resample_default2(projectTransform, delta2 = _2 * _2), reset()) : sqrt2(delta2);
  };
  projection4.fitExtent = function(extent, object3) {
    return fitExtent2(projection4, extent, object3);
  };
  projection4.fitSize = function(size, object3) {
    return fitSize2(projection4, size, object3);
  };
  projection4.fitWidth = function(width, object3) {
    return fitWidth(projection4, width, object3);
  };
  projection4.fitHeight = function(height, object3) {
    return fitHeight(projection4, height, object3);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k4, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform = (alpha ? scaleTranslateRotate : scaleTranslate2)(k4, x4 - center2[0], y4 - center2[1], sx, sy, alpha);
    rotate = rotateRadians2(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default2(project, transform);
    projectRotateTransform = compose_default2(rotate, projectTransform);
    projectResample = resample_default2(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection4;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection4.invert = project.invert && invert;
    return recenter();
  };
}
var transformRadians2;
var init_projection2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/index.js"() {
    init_antimeridian2();
    init_circle4();
    init_rectangle();
    init_compose2();
    init_identity4();
    init_math2();
    init_rotation2();
    init_transform2();
    init_fit2();
    init_resample2();
    transformRadians2 = transformer2({
      point: function(x4, y4) {
        this.stream.point(x4 * radians2, y4 * radians2);
      }
    });
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conic.js
var init_conic2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conic.js"() {
    init_math2();
    init_projection2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/cylindricalEqualArea.js
var init_cylindricalEqualArea2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/cylindricalEqualArea.js"() {
    init_math2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEqualArea.js
var init_conicEqualArea2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEqualArea.js"() {
    init_math2();
    init_conic2();
    init_cylindricalEqualArea2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albers.js
var init_albers2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albers.js"() {
    init_conicEqualArea2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albersUsa.js
var init_albersUsa2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/albersUsa.js"() {
    init_math2();
    init_albers2();
    init_conicEqualArea2();
    init_fit2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw2(scale) {
  return function(x4, y4) {
    var cx = cos2(x4), cy = cos2(y4), k4 = scale(cx * cy);
    return [
      k4 * cy * sin2(x4),
      k4 * sin2(y4)
    ];
  };
}
function azimuthalInvert2(angle5) {
  return function(x4, y4) {
    var z2 = sqrt2(x4 * x4 + y4 * y4), c2 = angle5(z2), sc = sin2(c2), cc = cos2(c2);
    return [
      atan22(x4 * sc, z2 * cc),
      asin2(z2 && y4 * sc / z2)
    ];
  };
}
var init_azimuthal2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthal.js"() {
    init_math2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw2;
var init_azimuthalEqualArea2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthalEqualArea.js"() {
    init_math2();
    init_azimuthal2();
    init_projection2();
    azimuthalEqualAreaRaw2 = azimuthalRaw2(function(cxcy) {
      return sqrt2(2 / (1 + cxcy));
    });
    azimuthalEqualAreaRaw2.invert = azimuthalInvert2(function(z2) {
      return 2 * asin2(z2 / 2);
    });
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw2;
var init_azimuthalEquidistant2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/azimuthalEquidistant.js"() {
    init_math2();
    init_azimuthal2();
    init_projection2();
    azimuthalEquidistantRaw2 = azimuthalRaw2(function(c2) {
      return (c2 = acos2(c2)) && c2 / sin2(c2);
    });
    azimuthalEquidistantRaw2.invert = azimuthalInvert2(function(z2) {
      return z2;
    });
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw2(lambda, phi2) {
  return [lambda, log2(tan2((halfPi2 + phi2) / 2))];
}
var init_mercator2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/mercator.js"() {
    init_math2();
    init_rotation2();
    init_projection2();
    mercatorRaw2.invert = function(x4, y4) {
      return [x4, 2 * atan3(exp2(y4)) - halfPi2];
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicConformal.js
var init_conicConformal2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicConformal.js"() {
    init_math2();
    init_conic2();
    init_mercator2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw2(lambda, phi2) {
  return [lambda, phi2];
}
function equirectangular_default2() {
  return projection2(equirectangularRaw2).scale(152.63);
}
var init_equirectangular2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/equirectangular.js"() {
    init_projection2();
    equirectangularRaw2.invert = equirectangularRaw2;
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEquidistant.js
var init_conicEquidistant2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/conicEquidistant.js"() {
    init_math2();
    init_conic2();
    init_equirectangular2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/equalEarth.js
function equalEarthRaw(lambda, phi2) {
  var l2 = asin2(M * sin2(phi2)), l22 = l2 * l2, l6 = l22 * l22 * l22;
  return [
    lambda * cos2(l2) / (M * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22))),
    l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22))
  ];
}
var A1, A2, A3, A4, M, iterations;
var init_equalEarth = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/equalEarth.js"() {
    init_projection2();
    init_math2();
    A1 = 1.340264;
    A2 = -0.081106;
    A3 = 893e-6;
    A4 = 3796e-6;
    M = sqrt2(3) / 2;
    iterations = 12;
    equalEarthRaw.invert = function(x4, y4) {
      var l2 = y4, l22 = l2 * l2, l6 = l22 * l22 * l22;
      for (var i2 = 0, delta, fy, fpy; i2 < iterations; ++i2) {
        fy = l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22)) - y4;
        fpy = A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22);
        l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
        if (abs2(delta) < epsilon22)
          break;
      }
      return [
        M * x4 * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22)) / cos2(l2),
        asin2(sin2(l2) / M)
      ];
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw2(x4, y4) {
  var cy = cos2(y4), k4 = cos2(x4) * cy;
  return [cy * sin2(x4) / k4, sin2(y4) / k4];
}
function gnomonic_default2() {
  return projection2(gnomonicRaw2).scale(144.049).clipAngle(60);
}
var init_gnomonic2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/gnomonic.js"() {
    init_math2();
    init_azimuthal2();
    init_projection2();
    gnomonicRaw2.invert = azimuthalInvert2(atan3);
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/identity.js
var init_identity5 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/identity.js"() {
    init_rectangle();
    init_identity4();
    init_transform2();
    init_fit2();
    init_math2();
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
var init_naturalEarth1 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/naturalEarth1.js"() {
    init_projection2();
    init_math2();
    naturalEarth1Raw.invert = function(x4, y4) {
      var phi2 = y4, i2 = 25, delta;
      do {
        var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
        phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
      } while (abs2(delta) > epsilon3 && --i2 > 0);
      return [
        x4 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
        phi2
      ];
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw2(x4, y4) {
  return [cos2(y4) * sin2(x4), sin2(y4)];
}
function orthographic_default2() {
  return projection2(orthographicRaw2).scale(249.5).clipAngle(90 + epsilon3);
}
var init_orthographic2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/orthographic.js"() {
    init_math2();
    init_azimuthal2();
    init_projection2();
    orthographicRaw2.invert = azimuthalInvert2(asin2);
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw2(x4, y4) {
  var cy = cos2(y4), k4 = 1 + cos2(x4) * cy;
  return [cy * sin2(x4) / k4, sin2(y4) / k4];
}
var init_stereographic2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/stereographic.js"() {
    init_math2();
    init_azimuthal2();
    init_projection2();
    stereographicRaw2.invert = azimuthalInvert2(function(z2) {
      return 2 * atan3(z2);
    });
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw2(lambda, phi2) {
  return [log2(tan2((halfPi2 + phi2) / 2)), -lambda];
}
var init_transverseMercator2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/projection/transverseMercator.js"() {
    init_math2();
    init_mercator2();
    transverseMercatorRaw2.invert = function(x4, y4) {
      return [-y4, 2 * atan3(exp2(x4)) - halfPi2];
    };
  }
});

// node_modules/d3-geo-projection/node_modules/d3-geo/src/index.js
var init_src2 = __esm({
  "node_modules/d3-geo-projection/node_modules/d3-geo/src/index.js"() {
    init_area3();
    init_bounds3();
    init_centroid3();
    init_circle3();
    init_antimeridian2();
    init_circle4();
    init_extent3();
    init_rectangle();
    init_contains2();
    init_distance2();
    init_graticule2();
    init_interpolate2();
    init_length2();
    init_path2();
    init_albers2();
    init_albersUsa2();
    init_azimuthalEqualArea2();
    init_azimuthalEquidistant2();
    init_conicConformal2();
    init_conicEqualArea2();
    init_conicEquidistant2();
    init_equalEarth();
    init_equirectangular2();
    init_gnomonic2();
    init_identity5();
    init_projection2();
    init_mercator2();
    init_naturalEarth1();
    init_orthographic2();
    init_stereographic2();
    init_transverseMercator2();
    init_rotation2();
    init_stream2();
    init_transform2();
  }
});

// node_modules/d3-geo-projection/src/math.js
function sinci(x4) {
  return x4 ? x4 / Math.sin(x4) : 1;
}
function asin3(x4) {
  return x4 > 1 ? halfPi3 : x4 < -1 ? -halfPi3 : Math.asin(x4);
}
function acos3(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi3 : Math.acos(x4);
}
function sqrt3(x4) {
  return x4 > 0 ? Math.sqrt(x4) : 0;
}
function tanh(x4) {
  x4 = exp3(2 * x4);
  return (x4 - 1) / (x4 + 1);
}
function sinh(x4) {
  return (exp3(x4) - exp3(-x4)) / 2;
}
function cosh(x4) {
  return (exp3(x4) + exp3(-x4)) / 2;
}
function arsinh(x4) {
  return log3(x4 + sqrt3(x4 * x4 + 1));
}
function arcosh(x4) {
  return log3(x4 + sqrt3(x4 * x4 - 1));
}
var abs3, atan4, atan23, cos3, exp3, floor, log3, max, min, pow3, round, sign3, sin3, tan3, epsilon4, epsilon23, pi3, halfPi3, quarterPi3, sqrt1_2, sqrt22, sqrtPi, tau3, degrees3, radians3;
var init_math3 = __esm({
  "node_modules/d3-geo-projection/src/math.js"() {
    abs3 = Math.abs;
    atan4 = Math.atan;
    atan23 = Math.atan2;
    cos3 = Math.cos;
    exp3 = Math.exp;
    floor = Math.floor;
    log3 = Math.log;
    max = Math.max;
    min = Math.min;
    pow3 = Math.pow;
    round = Math.round;
    sign3 = Math.sign || function(x4) {
      return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;
    };
    sin3 = Math.sin;
    tan3 = Math.tan;
    epsilon4 = 1e-6;
    epsilon23 = 1e-12;
    pi3 = Math.PI;
    halfPi3 = pi3 / 2;
    quarterPi3 = pi3 / 4;
    sqrt1_2 = Math.SQRT1_2;
    sqrt22 = sqrt3(2);
    sqrtPi = sqrt3(pi3);
    tau3 = pi3 * 2;
    degrees3 = 180 / pi3;
    radians3 = pi3 / 180;
  }
});

// node_modules/d3-geo-projection/src/airy.js
function airyRaw(beta) {
  var tanBeta_2 = tan3(beta / 2), b2 = 2 * log3(cos3(beta / 2)) / (tanBeta_2 * tanBeta_2);
  function forward(x4, y4) {
    var cosx = cos3(x4), cosy = cos3(y4), siny = sin3(y4), cosz = cosy * cosx, k4 = -((1 - cosz ? log3((1 + cosz) / 2) / (1 - cosz) : -0.5) + b2 / (1 + cosz));
    return [k4 * cosy * sin3(x4), k4 * siny];
  }
  forward.invert = function(x4, y4) {
    var r2 = sqrt3(x4 * x4 + y4 * y4), z2 = -beta / 2, i2 = 50, delta;
    if (!r2)
      return [0, 0];
    do {
      var z_2 = z2 / 2, cosz_2 = cos3(z_2), sinz_2 = sin3(z_2), tanz_2 = tan3(z_2), lnsecz_2 = log3(1 / cosz_2);
      z2 -= delta = (2 / tanz_2 * lnsecz_2 - b2 * tanz_2 - r2) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - b2 / (2 * cosz_2 * cosz_2));
    } while (abs3(delta) > epsilon4 && --i2 > 0);
    var sinz = sin3(z2);
    return [atan23(x4 * sinz, r2 * cos3(z2)), asin3(y4 * sinz / r2)];
  };
  return forward;
}
function airy_default() {
  var beta = halfPi3, m2 = projectionMutator2(airyRaw), p2 = m2(beta);
  p2.radius = function(_2) {
    return arguments.length ? m2(beta = _2 * radians3) : beta * degrees3;
  };
  return p2.scale(179.976).clipAngle(147);
}
var init_airy = __esm({
  "node_modules/d3-geo-projection/src/airy.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/aitoff.js
function aitoffRaw(x4, y4) {
  var cosy = cos3(y4), sincia = sinci(acos3(cosy * cos3(x4 /= 2)));
  return [2 * cosy * sin3(x4) * sincia, sin3(y4) * sincia];
}
function aitoff_default() {
  return projection2(aitoffRaw).scale(152.63);
}
var init_aitoff = __esm({
  "node_modules/d3-geo-projection/src/aitoff.js"() {
    init_src2();
    init_math3();
    aitoffRaw.invert = function(x4, y4) {
      if (x4 * x4 + 4 * y4 * y4 > pi3 * pi3 + epsilon4)
        return;
      var x16 = x4, y16 = y4, i2 = 25;
      do {
        var sinx = sin3(x16), sinx_2 = sin3(x16 / 2), cosx_2 = cos3(x16 / 2), siny = sin3(y16), cosy = cos3(y16), sin_2y = sin3(2 * y16), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c2 = 1 - cos2y * cosx_2 * cosx_2, e3 = c2 ? acos3(cosy * cosx_2) * sqrt3(f2 = 1 / c2) : f2 = 0, f2, fx = 2 * e3 * cosy * sinx_2 - x4, fy = e3 * siny - y4, dxdx = f2 * (cos2y * sin2x_2 + e3 * cosy * cosx_2 * sin2y), dxdy = f2 * (0.5 * sinx * sin_2y - e3 * 2 * siny * sinx_2), dydx = f2 * 0.25 * (sin_2y * sinx_2 - e3 * siny * cos2y * sinx), dydy = f2 * (sin2y * cosx_2 + e3 * sin2x_2 * cosy), z2 = dxdy * dydx - dydy * dxdx;
        if (!z2)
          break;
        var dx = (fy * dxdy - fx * dydy) / z2, dy = (fx * dydx - fy * dxdx) / z2;
        x16 -= dx, y16 -= dy;
      } while ((abs3(dx) > epsilon4 || abs3(dy) > epsilon4) && --i2 > 0);
      return [x16, y16];
    };
  }
});

// node_modules/d3-geo-projection/src/armadillo.js
function armadilloRaw(phi04) {
  var sinPhi04 = sin3(phi04), cosPhi04 = cos3(phi04), sPhi0 = phi04 >= 0 ? 1 : -1, tanPhi0 = tan3(sPhi0 * phi04), k4 = (1 + sinPhi04 - cosPhi04) / 2;
  function forward(lambda, phi2) {
    var cosPhi = cos3(phi2), cosLambda = cos3(lambda /= 2);
    return [
      (1 + cosPhi) * sin3(lambda),
      (sPhi0 * phi2 > -atan23(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k4 + sin3(phi2) * cosPhi04 - (1 + cosPhi) * sinPhi04 * cosLambda
    ];
  }
  forward.invert = function(x4, y4) {
    var lambda = 0, phi2 = 0, i2 = 50;
    do {
      var cosLambda = cos3(lambda), sinLambda = sin3(lambda), cosPhi = cos3(phi2), sinPhi = sin3(phi2), A6 = 1 + cosPhi, fx = A6 * sinLambda - x4, fy = k4 + sinPhi * cosPhi04 - A6 * sinPhi04 * cosLambda - y4, dxdLambda = A6 * cosLambda / 2, dxdPhi = -sinLambda * sinPhi, dydLambda = sinPhi04 * A6 * sinLambda / 2, dydPhi = cosPhi04 * cosPhi + sinPhi04 * cosLambda * sinPhi, denominator = dxdPhi * dydLambda - dydPhi * dxdLambda, dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2, dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;
      lambda -= dLambda, phi2 -= dPhi;
    } while ((abs3(dLambda) > epsilon4 || abs3(dPhi) > epsilon4) && --i2 > 0);
    return sPhi0 * phi2 > -atan23(cos3(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi2] : null;
  };
  return forward;
}
function armadillo_default() {
  var phi04 = 20 * radians3, sPhi0 = phi04 >= 0 ? 1 : -1, tanPhi0 = tan3(sPhi0 * phi04), m2 = projectionMutator2(armadilloRaw), p2 = m2(phi04), stream_ = p2.stream;
  p2.parallel = function(_2) {
    if (!arguments.length)
      return phi04 * degrees3;
    tanPhi0 = tan3((sPhi0 = (phi04 = _2 * radians3) >= 0 ? 1 : -1) * phi04);
    return m2(phi04);
  };
  p2.stream = function(stream) {
    var rotate = p2.rotate(), rotateStream = stream_(stream), sphereStream = (p2.rotate([0, 0]), stream_(stream));
    p2.rotate(rotate);
    rotateStream.sphere = function() {
      sphereStream.polygonStart(), sphereStream.lineStart();
      for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90)
        sphereStream.point(lambda, sPhi0 * 90);
      while (sPhi0 * (lambda -= phi04) >= -180) {
        sphereStream.point(lambda, sPhi0 * -atan23(cos3(lambda * radians3 / 2), tanPhi0) * degrees3);
      }
      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };
    return rotateStream;
  };
  return p2.scale(218.695).center([0, 28.0974]);
}
var init_armadillo = __esm({
  "node_modules/d3-geo-projection/src/armadillo.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/august.js
function augustRaw(lambda, phi2) {
  var tanPhi = tan3(phi2 / 2), k4 = sqrt3(1 - tanPhi * tanPhi), c2 = 1 + k4 * cos3(lambda /= 2), x4 = sin3(lambda) * k4 / c2, y4 = tanPhi / c2, x22 = x4 * x4, y22 = y4 * y4;
  return [
    4 / 3 * x4 * (3 + x22 - 3 * y22),
    4 / 3 * y4 * (3 + 3 * x22 - y22)
  ];
}
function august_default() {
  return projection2(augustRaw).scale(66.1603);
}
var init_august = __esm({
  "node_modules/d3-geo-projection/src/august.js"() {
    init_src2();
    init_math3();
    augustRaw.invert = function(x4, y4) {
      x4 *= 3 / 8, y4 *= 3 / 8;
      if (!x4 && abs3(y4) > 1)
        return null;
      var x22 = x4 * x4, y22 = y4 * y4, s3 = 1 + x22 + y22, sin3Eta = sqrt3((s3 - sqrt3(s3 * s3 - 4 * y4 * y4)) / 2), eta = asin3(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs3(y4 / sin3Eta)) / 3 : arsinh(abs3(x4)) / 3, cosEta = cos3(eta), coshXi = cosh(xi), d2 = coshXi * coshXi - cosEta * cosEta;
      return [
        sign3(x4) * 2 * atan23(sinh(xi) * cosEta, 0.25 - d2),
        sign3(y4) * 2 * atan23(coshXi * sin3(eta), 0.25 + d2)
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/baker.js
function bakerRaw(lambda, phi2) {
  var phi04 = abs3(phi2);
  return phi04 < quarterPi3 ? [lambda, log3(tan3(quarterPi3 + phi2 / 2))] : [lambda * cos3(phi04) * (2 * sqrt22 - 1 / sin3(phi04)), sign3(phi2) * (2 * sqrt22 * (phi04 - quarterPi3) - log3(tan3(phi04 / 2)))];
}
function baker_default() {
  return projection2(bakerRaw).scale(112.314);
}
var sqrt8, phi03;
var init_baker = __esm({
  "node_modules/d3-geo-projection/src/baker.js"() {
    init_src2();
    init_math3();
    sqrt8 = sqrt3(8);
    phi03 = log3(1 + sqrt22);
    bakerRaw.invert = function(x4, y4) {
      if ((y011 = abs3(y4)) < phi03)
        return [x4, 2 * atan4(exp3(y4)) - halfPi3];
      var phi2 = quarterPi3, i2 = 25, delta, y011;
      do {
        var cosPhi_2 = cos3(phi2 / 2), tanPhi_2 = tan3(phi2 / 2);
        phi2 -= delta = (sqrt8 * (phi2 - quarterPi3) - log3(tanPhi_2) - y011) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
      } while (abs3(delta) > epsilon23 && --i2 > 0);
      return [x4 / (cos3(phi2) * (sqrt8 - 1 / sin3(phi2))), sign3(y4) * phi2];
    };
  }
});

// node_modules/d3-geo-projection/src/berghaus.js
function berghausRaw(lobes7) {
  var k4 = 2 * pi3 / lobes7;
  function forward(lambda, phi2) {
    var p2 = azimuthalEquidistantRaw2(lambda, phi2);
    if (abs3(lambda) > halfPi3) {
      var theta = atan23(p2[1], p2[0]), r2 = sqrt3(p2[0] * p2[0] + p2[1] * p2[1]), theta0 = k4 * round((theta - halfPi3) / k4) + halfPi3, alpha = atan23(sin3(theta -= theta0), 2 - cos3(theta));
      theta = theta0 + asin3(pi3 / r2 * sin3(alpha)) - alpha;
      p2[0] = r2 * cos3(theta);
      p2[1] = r2 * sin3(theta);
    }
    return p2;
  }
  forward.invert = function(x4, y4) {
    var r2 = sqrt3(x4 * x4 + y4 * y4);
    if (r2 > halfPi3) {
      var theta = atan23(y4, x4), theta0 = k4 * round((theta - halfPi3) / k4) + halfPi3, s3 = theta > theta0 ? -1 : 1, A6 = r2 * cos3(theta0 - theta), cotAlpha = 1 / tan3(s3 * acos3((A6 - pi3) / sqrt3(pi3 * (pi3 - 2 * A6) + r2 * r2)));
      theta = theta0 + 2 * atan4((cotAlpha + s3 * sqrt3(cotAlpha * cotAlpha - 3)) / 3);
      x4 = r2 * cos3(theta), y4 = r2 * sin3(theta);
    }
    return azimuthalEquidistantRaw2.invert(x4, y4);
  };
  return forward;
}
function berghaus_default() {
  var lobes7 = 5, m2 = projectionMutator2(berghausRaw), p2 = m2(lobes7), projectionStream = p2.stream, epsilon12 = 0.01, cr = -cos3(epsilon12 * radians3), sr = sin3(epsilon12 * radians3);
  p2.lobes = function(_2) {
    return arguments.length ? m2(lobes7 = +_2) : lobes7;
  };
  p2.stream = function(stream) {
    var rotate = p2.rotate(), rotateStream = projectionStream(stream), sphereStream = (p2.rotate([0, 0]), projectionStream(stream));
    p2.rotate(rotate);
    rotateStream.sphere = function() {
      sphereStream.polygonStart(), sphereStream.lineStart();
      for (var i2 = 0, delta = 360 / lobes7, delta0 = 2 * pi3 / lobes7, phi2 = 90 - 180 / lobes7, phi04 = halfPi3; i2 < lobes7; ++i2, phi2 -= delta, phi04 -= delta0) {
        sphereStream.point(atan23(sr * cos3(phi04), cr) * degrees3, asin3(sr * sin3(phi04)) * degrees3);
        if (phi2 < -90) {
          sphereStream.point(-90, -180 - phi2 - epsilon12);
          sphereStream.point(-90, -180 - phi2 + epsilon12);
        } else {
          sphereStream.point(90, phi2 + epsilon12);
          sphereStream.point(90, phi2 - epsilon12);
        }
      }
      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };
    return rotateStream;
  };
  return p2.scale(87.8076).center([0, 17.1875]).clipAngle(180 - 1e-3);
}
var init_berghaus = __esm({
  "node_modules/d3-geo-projection/src/berghaus.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/mollweide.js
function mollweideBromleyTheta(cp, phi2) {
  var cpsinPhi = cp * sin3(phi2), i2 = 30, delta;
  do
    phi2 -= delta = (phi2 + sin3(phi2) - cpsinPhi) / (1 + cos3(phi2));
  while (abs3(delta) > epsilon4 && --i2 > 0);
  return phi2 / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi2) {
    return [cx * lambda * cos3(phi2 = mollweideBromleyTheta(cp, phi2)), cy * sin3(phi2)];
  }
  forward.invert = function(x4, y4) {
    return y4 = asin3(y4 / cy), [x4 / (cx * cos3(y4)), asin3((2 * y4 + sin3(2 * y4)) / cp)];
  };
  return forward;
}
function mollweide_default() {
  return projection2(mollweideRaw).scale(169.529);
}
var mollweideRaw;
var init_mollweide = __esm({
  "node_modules/d3-geo-projection/src/mollweide.js"() {
    init_src2();
    init_math3();
    mollweideRaw = mollweideBromleyRaw(sqrt22 / halfPi3, sqrt22, pi3);
  }
});

// node_modules/d3-geo-projection/src/boggs.js
function boggsRaw(lambda, phi2) {
  var theta = mollweideBromleyTheta(pi3, phi2);
  return [k * lambda / (1 / cos3(phi2) + w / cos3(theta)), (phi2 + sqrt22 * sin3(theta)) / k];
}
function boggs_default() {
  return projection2(boggsRaw).scale(160.857);
}
var k, w;
var init_boggs = __esm({
  "node_modules/d3-geo-projection/src/boggs.js"() {
    init_src2();
    init_mollweide();
    init_math3();
    k = 2.00276;
    w = 1.11072;
    boggsRaw.invert = function(x4, y4) {
      var ky2 = k * y4, theta = y4 < 0 ? -quarterPi3 : quarterPi3, i2 = 25, delta, phi2;
      do {
        phi2 = ky2 - sqrt22 * sin3(theta);
        theta -= delta = (sin3(2 * theta) + 2 * theta - pi3 * sin3(phi2)) / (2 * cos3(2 * theta) + 2 + pi3 * cos3(phi2) * sqrt22 * cos3(theta));
      } while (abs3(delta) > epsilon4 && --i2 > 0);
      phi2 = ky2 - sqrt22 * sin3(theta);
      return [x4 * (1 / cos3(phi2) + w / cos3(theta)) / k, phi2];
    };
  }
});

// node_modules/d3-geo-projection/src/parallel1.js
function parallel1_default(projectAt) {
  var phi04 = 0, m2 = projectionMutator2(projectAt), p2 = m2(phi04);
  p2.parallel = function(_2) {
    return arguments.length ? m2(phi04 = _2 * radians3) : phi04 * degrees3;
  };
  return p2;
}
var init_parallel1 = __esm({
  "node_modules/d3-geo-projection/src/parallel1.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/sinusoidal.js
function sinusoidalRaw(lambda, phi2) {
  return [lambda * cos3(phi2), phi2];
}
function sinusoidal_default() {
  return projection2(sinusoidalRaw).scale(152.63);
}
var init_sinusoidal = __esm({
  "node_modules/d3-geo-projection/src/sinusoidal.js"() {
    init_src2();
    init_math3();
    sinusoidalRaw.invert = function(x4, y4) {
      return [x4 / cos3(y4), y4];
    };
  }
});

// node_modules/d3-geo-projection/src/bonne.js
function bonneRaw(phi04) {
  if (!phi04)
    return sinusoidalRaw;
  var cotPhi0 = 1 / tan3(phi04);
  function forward(lambda, phi2) {
    var rho = cotPhi0 + phi04 - phi2, e3 = rho ? lambda * cos3(phi2) / rho : rho;
    return [rho * sin3(e3), cotPhi0 - rho * cos3(e3)];
  }
  forward.invert = function(x4, y4) {
    var rho = sqrt3(x4 * x4 + (y4 = cotPhi0 - y4) * y4), phi2 = cotPhi0 + phi04 - rho;
    return [rho / cos3(phi2) * atan23(x4, y4), phi2];
  };
  return forward;
}
function bonne_default() {
  return parallel1_default(bonneRaw).scale(123.082).center([0, 26.1441]).parallel(45);
}
var init_bonne = __esm({
  "node_modules/d3-geo-projection/src/bonne.js"() {
    init_parallel1();
    init_math3();
    init_sinusoidal();
  }
});

// node_modules/d3-geo-projection/src/bottomley.js
function bottomleyRaw(sinPsi) {
  function forward(lambda, phi2) {
    var rho = halfPi3 - phi2, eta = rho ? lambda * sinPsi * sin3(rho) / rho : rho;
    return [rho * sin3(eta) / sinPsi, halfPi3 - rho * cos3(eta)];
  }
  forward.invert = function(x4, y4) {
    var x16 = x4 * sinPsi, y16 = halfPi3 - y4, rho = sqrt3(x16 * x16 + y16 * y16), eta = atan23(x16, y16);
    return [(rho ? rho / sin3(rho) : 1) * eta / sinPsi, halfPi3 - rho];
  };
  return forward;
}
function bottomley_default() {
  var sinPsi = 0.5, m2 = projectionMutator2(bottomleyRaw), p2 = m2(sinPsi);
  p2.fraction = function(_2) {
    return arguments.length ? m2(sinPsi = +_2) : sinPsi;
  };
  return p2.scale(158.837);
}
var init_bottomley = __esm({
  "node_modules/d3-geo-projection/src/bottomley.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/bromley.js
function bromley_default() {
  return projection2(bromleyRaw).scale(152.63);
}
var bromleyRaw;
var init_bromley = __esm({
  "node_modules/d3-geo-projection/src/bromley.js"() {
    init_src2();
    init_math3();
    init_mollweide();
    bromleyRaw = mollweideBromleyRaw(1, 4 / pi3, pi3);
  }
});

// node_modules/d3-geo-projection/src/chamberlin.js
function distance(dPhi, c1, s1, c2, s22, dLambda) {
  var cosdLambda = cos3(dLambda), r2;
  if (abs3(dPhi) > 1 || abs3(dLambda) > 1) {
    r2 = acos3(s1 * s22 + c1 * c2 * cosdLambda);
  } else {
    var sindPhi = sin3(dPhi / 2), sindLambda = sin3(dLambda / 2);
    r2 = 2 * asin3(sqrt3(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda));
  }
  return abs3(r2) > epsilon4 ? [r2, atan23(c2 * sin3(dLambda), c1 * s22 - s1 * c2 * cosdLambda)] : [0, 0];
}
function angle3(b2, c2, a3) {
  return acos3((b2 * b2 + c2 * c2 - a3 * a3) / (2 * b2 * c2));
}
function longitude2(lambda) {
  return lambda - 2 * pi3 * floor((lambda + pi3) / (2 * pi3));
}
function chamberlinRaw(p03, p1, p2) {
  var points2 = [
    [p03[0], p03[1], sin3(p03[1]), cos3(p03[1])],
    [p1[0], p1[1], sin3(p1[1]), cos3(p1[1])],
    [p2[0], p2[1], sin3(p2[1]), cos3(p2[1])]
  ];
  for (var a3 = points2[2], b2, i2 = 0; i2 < 3; ++i2, a3 = b2) {
    b2 = points2[i2];
    a3.v = distance(b2[1] - a3[1], a3[3], a3[2], b2[3], b2[2], b2[0] - a3[0]);
    a3.point = [0, 0];
  }
  var beta0 = angle3(points2[0].v[0], points2[2].v[0], points2[1].v[0]), beta1 = angle3(points2[0].v[0], points2[1].v[0], points2[2].v[0]), beta2 = pi3 - beta0;
  points2[2].point[1] = 0;
  points2[0].point[0] = -(points2[1].point[0] = points2[0].v[0] / 2);
  var mean2 = [
    points2[2].point[0] = points2[0].point[0] + points2[2].v[0] * cos3(beta0),
    2 * (points2[0].point[1] = points2[1].point[1] = points2[2].v[0] * sin3(beta0))
  ];
  function forward(lambda, phi2) {
    var sinPhi = sin3(phi2), cosPhi = cos3(phi2), v2 = new Array(3), i3;
    for (i3 = 0; i3 < 3; ++i3) {
      var p3 = points2[i3];
      v2[i3] = distance(phi2 - p3[1], p3[3], p3[2], cosPhi, sinPhi, lambda - p3[0]);
      if (!v2[i3][0])
        return p3.point;
      v2[i3][1] = longitude2(v2[i3][1] - p3.v[1]);
    }
    var point5 = mean2.slice();
    for (i3 = 0; i3 < 3; ++i3) {
      var j2 = i3 == 2 ? 0 : i3 + 1;
      var a4 = angle3(points2[i3].v[0], v2[i3][0], v2[j2][0]);
      if (v2[i3][1] < 0)
        a4 = -a4;
      if (!i3) {
        point5[0] += v2[i3][0] * cos3(a4);
        point5[1] -= v2[i3][0] * sin3(a4);
      } else if (i3 == 1) {
        a4 = beta1 - a4;
        point5[0] -= v2[i3][0] * cos3(a4);
        point5[1] -= v2[i3][0] * sin3(a4);
      } else {
        a4 = beta2 - a4;
        point5[0] += v2[i3][0] * cos3(a4);
        point5[1] += v2[i3][0] * sin3(a4);
      }
    }
    point5[0] /= 3, point5[1] /= 3;
    return point5;
  }
  return forward;
}
function pointRadians2(p2) {
  return p2[0] *= radians3, p2[1] *= radians3, p2;
}
function chamberlinAfrica() {
  return chamberlin([0, 22], [45, 22], [22.5, -22]).scale(380).center([22.5, 2]);
}
function chamberlin(p03, p1, p2) {
  var c2 = centroid_default3({ type: "MultiPoint", coordinates: [p03, p1, p2] }), R2 = [-c2[0], -c2[1]], r2 = rotation_default2(R2), p3 = projection2(chamberlinRaw(pointRadians2(r2(p03)), pointRadians2(r2(p1)), pointRadians2(r2(p2)))).rotate(R2), center2 = p3.center;
  delete p3.rotate;
  p3.center = function(_2) {
    return arguments.length ? center2(r2(_2)) : r2.invert(center2());
  };
  return p3.clipAngle(90);
}
var init_chamberlin = __esm({
  "node_modules/d3-geo-projection/src/chamberlin.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/collignon.js
function collignonRaw(lambda, phi2) {
  var alpha = sqrt3(1 - sin3(phi2));
  return [2 / sqrtPi * lambda * alpha, sqrtPi * (1 - alpha)];
}
function collignon_default() {
  return projection2(collignonRaw).scale(95.6464).center([0, 30]);
}
var init_collignon = __esm({
  "node_modules/d3-geo-projection/src/collignon.js"() {
    init_src2();
    init_math3();
    collignonRaw.invert = function(x4, y4) {
      var lambda = (lambda = y4 / sqrtPi - 1) * lambda;
      return [lambda > 0 ? x4 * sqrt3(pi3 / lambda) / 2 : 0, asin3(1 - lambda)];
    };
  }
});

// node_modules/d3-geo-projection/src/craig.js
function craigRaw(phi04) {
  var tanPhi0 = tan3(phi04);
  function forward(lambda, phi2) {
    return [lambda, (lambda ? lambda / sin3(lambda) : 1) * (sin3(phi2) * cos3(lambda) - tanPhi0 * cos3(phi2))];
  }
  forward.invert = tanPhi0 ? function(x4, y4) {
    if (x4)
      y4 *= sin3(x4) / x4;
    var cosLambda = cos3(x4);
    return [x4, 2 * atan23(sqrt3(cosLambda * cosLambda + tanPhi0 * tanPhi0 - y4 * y4) - cosLambda, tanPhi0 - y4)];
  } : function(x4, y4) {
    return [x4, asin3(x4 ? y4 * tan3(x4) / x4 : y4)];
  };
  return forward;
}
function craig_default() {
  return parallel1_default(craigRaw).scale(249.828).clipAngle(90);
}
var init_craig = __esm({
  "node_modules/d3-geo-projection/src/craig.js"() {
    init_math3();
    init_parallel1();
  }
});

// node_modules/d3-geo-projection/src/craster.js
function crasterRaw(lambda, phi2) {
  return [sqrt32 * lambda * (2 * cos3(2 * phi2 / 3) - 1) / sqrtPi, sqrt32 * sqrtPi * sin3(phi2 / 3)];
}
function craster_default() {
  return projection2(crasterRaw).scale(156.19);
}
var sqrt32;
var init_craster = __esm({
  "node_modules/d3-geo-projection/src/craster.js"() {
    init_src2();
    init_math3();
    sqrt32 = sqrt3(3);
    crasterRaw.invert = function(x4, y4) {
      var phi2 = 3 * asin3(y4 / (sqrt32 * sqrtPi));
      return [sqrtPi * x4 / (sqrt32 * (2 * cos3(2 * phi2 / 3) - 1)), phi2];
    };
  }
});

// node_modules/d3-geo-projection/src/cylindricalEqualArea.js
function cylindricalEqualAreaRaw3(phi04) {
  var cosPhi04 = cos3(phi04);
  function forward(lambda, phi2) {
    return [lambda * cosPhi04, sin3(phi2) / cosPhi04];
  }
  forward.invert = function(x4, y4) {
    return [x4 / cosPhi04, asin3(y4 * cosPhi04)];
  };
  return forward;
}
function cylindricalEqualArea_default() {
  return parallel1_default(cylindricalEqualAreaRaw3).parallel(38.58).scale(195.044);
}
var init_cylindricalEqualArea3 = __esm({
  "node_modules/d3-geo-projection/src/cylindricalEqualArea.js"() {
    init_math3();
    init_parallel1();
  }
});

// node_modules/d3-geo-projection/src/cylindricalStereographic.js
function cylindricalStereographicRaw(phi04) {
  var cosPhi04 = cos3(phi04);
  function forward(lambda, phi2) {
    return [lambda * cosPhi04, (1 + cosPhi04) * tan3(phi2 / 2)];
  }
  forward.invert = function(x4, y4) {
    return [x4 / cosPhi04, atan4(y4 / (1 + cosPhi04)) * 2];
  };
  return forward;
}
function cylindricalStereographic_default() {
  return parallel1_default(cylindricalStereographicRaw).scale(124.75);
}
var init_cylindricalStereographic = __esm({
  "node_modules/d3-geo-projection/src/cylindricalStereographic.js"() {
    init_math3();
    init_parallel1();
  }
});

// node_modules/d3-geo-projection/src/eckert1.js
function eckert1Raw(lambda, phi2) {
  var alpha = sqrt3(8 / (3 * pi3));
  return [
    alpha * lambda * (1 - abs3(phi2) / pi3),
    alpha * phi2
  ];
}
function eckert1_default() {
  return projection2(eckert1Raw).scale(165.664);
}
var init_eckert1 = __esm({
  "node_modules/d3-geo-projection/src/eckert1.js"() {
    init_src2();
    init_math3();
    eckert1Raw.invert = function(x4, y4) {
      var alpha = sqrt3(8 / (3 * pi3)), phi2 = y4 / alpha;
      return [
        x4 / (alpha * (1 - abs3(phi2) / pi3)),
        phi2
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/eckert2.js
function eckert2Raw(lambda, phi2) {
  var alpha = sqrt3(4 - 3 * sin3(abs3(phi2)));
  return [
    2 / sqrt3(6 * pi3) * lambda * alpha,
    sign3(phi2) * sqrt3(2 * pi3 / 3) * (2 - alpha)
  ];
}
function eckert2_default() {
  return projection2(eckert2Raw).scale(165.664);
}
var init_eckert2 = __esm({
  "node_modules/d3-geo-projection/src/eckert2.js"() {
    init_src2();
    init_math3();
    eckert2Raw.invert = function(x4, y4) {
      var alpha = 2 - abs3(y4) / sqrt3(2 * pi3 / 3);
      return [
        x4 * sqrt3(6 * pi3) / (2 * alpha),
        sign3(y4) * asin3((4 - alpha * alpha) / 3)
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/eckert3.js
function eckert3Raw(lambda, phi2) {
  var k4 = sqrt3(pi3 * (4 + pi3));
  return [
    2 / k4 * lambda * (1 + sqrt3(1 - 4 * phi2 * phi2 / (pi3 * pi3))),
    4 / k4 * phi2
  ];
}
function eckert3_default() {
  return projection2(eckert3Raw).scale(180.739);
}
var init_eckert3 = __esm({
  "node_modules/d3-geo-projection/src/eckert3.js"() {
    init_src2();
    init_math3();
    eckert3Raw.invert = function(x4, y4) {
      var k4 = sqrt3(pi3 * (4 + pi3)) / 2;
      return [
        x4 * k4 / (1 + sqrt3(1 - y4 * y4 * (4 + pi3) / (4 * pi3))),
        y4 * k4 / 2
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/eckert4.js
function eckert4Raw(lambda, phi2) {
  var k4 = (2 + halfPi3) * sin3(phi2);
  phi2 /= 2;
  for (var i2 = 0, delta = Infinity; i2 < 10 && abs3(delta) > epsilon4; i2++) {
    var cosPhi = cos3(phi2);
    phi2 -= delta = (phi2 + sin3(phi2) * (cosPhi + 2) - k4) / (2 * cosPhi * (1 + cosPhi));
  }
  return [
    2 / sqrt3(pi3 * (4 + pi3)) * lambda * (1 + cos3(phi2)),
    2 * sqrt3(pi3 / (4 + pi3)) * sin3(phi2)
  ];
}
function eckert4_default() {
  return projection2(eckert4Raw).scale(180.739);
}
var init_eckert4 = __esm({
  "node_modules/d3-geo-projection/src/eckert4.js"() {
    init_src2();
    init_math3();
    eckert4Raw.invert = function(x4, y4) {
      var A6 = y4 * sqrt3((4 + pi3) / pi3) / 2, k4 = asin3(A6), c2 = cos3(k4);
      return [
        x4 / (2 / sqrt3(pi3 * (4 + pi3)) * (1 + c2)),
        asin3((k4 + A6 * (c2 + 2)) / (2 + halfPi3))
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/eckert5.js
function eckert5Raw(lambda, phi2) {
  return [
    lambda * (1 + cos3(phi2)) / sqrt3(2 + pi3),
    2 * phi2 / sqrt3(2 + pi3)
  ];
}
function eckert5_default() {
  return projection2(eckert5Raw).scale(173.044);
}
var init_eckert5 = __esm({
  "node_modules/d3-geo-projection/src/eckert5.js"() {
    init_src2();
    init_math3();
    eckert5Raw.invert = function(x4, y4) {
      var k4 = sqrt3(2 + pi3), phi2 = y4 * k4 / 2;
      return [
        k4 * x4 / (1 + cos3(phi2)),
        phi2
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/eckert6.js
function eckert6Raw(lambda, phi2) {
  var k4 = (1 + halfPi3) * sin3(phi2);
  for (var i2 = 0, delta = Infinity; i2 < 10 && abs3(delta) > epsilon4; i2++) {
    phi2 -= delta = (phi2 + sin3(phi2) - k4) / (1 + cos3(phi2));
  }
  k4 = sqrt3(2 + pi3);
  return [
    lambda * (1 + cos3(phi2)) / k4,
    2 * phi2 / k4
  ];
}
function eckert6_default() {
  return projection2(eckert6Raw).scale(173.044);
}
var init_eckert6 = __esm({
  "node_modules/d3-geo-projection/src/eckert6.js"() {
    init_src2();
    init_math3();
    eckert6Raw.invert = function(x4, y4) {
      var j2 = 1 + halfPi3, k4 = sqrt3(j2 / 2);
      return [
        x4 * 2 * k4 / (1 + cos3(y4 *= k4)),
        asin3((y4 + sin3(y4)) / j2)
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/eisenlohr.js
function eisenlohrRaw(lambda, phi2) {
  var s0 = sin3(lambda /= 2), c0 = cos3(lambda), k4 = sqrt3(cos3(phi2)), c1 = cos3(phi2 /= 2), t2 = sin3(phi2) / (c1 + sqrt22 * c0 * k4), c2 = sqrt3(2 / (1 + t2 * t2)), v2 = sqrt3((sqrt22 * c1 + (c0 + s0) * k4) / (sqrt22 * c1 + (c0 - s0) * k4));
  return [
    eisenlohrK * (c2 * (v2 - 1 / v2) - 2 * log3(v2)),
    eisenlohrK * (c2 * t2 * (v2 + 1 / v2) - 2 * atan4(t2))
  ];
}
function eisenlohr_default() {
  return projection2(eisenlohrRaw).scale(62.5271);
}
var eisenlohrK;
var init_eisenlohr = __esm({
  "node_modules/d3-geo-projection/src/eisenlohr.js"() {
    init_src2();
    init_august();
    init_math3();
    eisenlohrK = 3 + 2 * sqrt22;
    eisenlohrRaw.invert = function(x4, y4) {
      if (!(p2 = augustRaw.invert(x4 / 1.2, y4 * 1.065)))
        return null;
      var lambda = p2[0], phi2 = p2[1], i2 = 20, p2;
      x4 /= eisenlohrK, y4 /= eisenlohrK;
      do {
        var _0 = lambda / 2, _1 = phi2 / 2, s0 = sin3(_0), c0 = cos3(_0), s1 = sin3(_1), c1 = cos3(_1), cos1 = cos3(phi2), k4 = sqrt3(cos1), t2 = s1 / (c1 + sqrt22 * c0 * k4), t22 = t2 * t2, c2 = sqrt3(2 / (1 + t22)), v0 = sqrt22 * c1 + (c0 + s0) * k4, v1 = sqrt22 * c1 + (c0 - s0) * k4, v2 = v0 / v1, v3 = sqrt3(v2), vm1v = v3 - 1 / v3, vp1v = v3 + 1 / v3, fx = c2 * vm1v - 2 * log3(v3) - x4, fy = c2 * t2 * vp1v - 2 * atan4(t2) - y4, deltatDeltaLambda = s1 && sqrt1_2 * k4 * s0 * t22 / s1, deltatDeltaPhi = (sqrt22 * c0 * c1 + k4) / (2 * (c1 + sqrt22 * c0 * k4) * (c1 + sqrt22 * c0 * k4) * k4), deltacDeltat = -0.5 * t2 * c2 * c2 * c2, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A6 = (A6 = 2 * c1 + sqrt22 * k4 * (c0 - s0)) * A6 * v3, deltavDeltaLambda = (sqrt22 * c0 * c1 * k4 + cos1) / A6, deltavDeltaPhi = -(sqrt22 * s0 * s1) / (k4 * A6), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v3 + c2 * (deltavDeltaLambda + deltavDeltaLambda / v2), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v3 + c2 * (deltavDeltaPhi + deltavDeltaPhi / v2), deltayDeltaLambda = t2 * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t22) + c2 * vp1v * deltatDeltaLambda + c2 * t2 * (deltavDeltaLambda - deltavDeltaLambda / v2), deltayDeltaPhi = t2 * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t22) + c2 * vp1v * deltatDeltaPhi + c2 * t2 * (deltavDeltaPhi - deltavDeltaPhi / v2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
        if (!denominator)
          break;
        var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
        lambda -= deltaLambda;
        phi2 = max(-halfPi3, min(halfPi3, phi2 - deltaPhi));
      } while ((abs3(deltaLambda) > epsilon4 || abs3(deltaPhi) > epsilon4) && --i2 > 0);
      return abs3(abs3(phi2) - halfPi3) < epsilon4 ? [0, phi2] : i2 && [lambda, phi2];
    };
  }
});

// node_modules/d3-geo-projection/src/fahey.js
function faheyRaw(lambda, phi2) {
  var t2 = tan3(phi2 / 2);
  return [lambda * faheyK * sqrt3(1 - t2 * t2), (1 + faheyK) * t2];
}
function fahey_default() {
  return projection2(faheyRaw).scale(137.152);
}
var faheyK;
var init_fahey = __esm({
  "node_modules/d3-geo-projection/src/fahey.js"() {
    init_src2();
    init_math3();
    faheyK = cos3(35 * radians3);
    faheyRaw.invert = function(x4, y4) {
      var t2 = y4 / (1 + faheyK);
      return [x4 && x4 / (faheyK * sqrt3(1 - t2 * t2)), 2 * atan4(t2)];
    };
  }
});

// node_modules/d3-geo-projection/src/foucaut.js
function foucautRaw(lambda, phi2) {
  var k4 = phi2 / 2, cosk = cos3(k4);
  return [2 * lambda / sqrtPi * cos3(phi2) * cosk * cosk, sqrtPi * tan3(k4)];
}
function foucaut_default() {
  return projection2(foucautRaw).scale(135.264);
}
var init_foucaut = __esm({
  "node_modules/d3-geo-projection/src/foucaut.js"() {
    init_src2();
    init_math3();
    foucautRaw.invert = function(x4, y4) {
      var k4 = atan4(y4 / sqrtPi), cosk = cos3(k4), phi2 = 2 * k4;
      return [x4 * sqrtPi / 2 / (cos3(phi2) * cosk * cosk), phi2];
    };
  }
});

// node_modules/d3-geo-projection/src/gilbert.js
function gilbertForward(point5) {
  return [point5[0] / 2, asin3(tan3(point5[1] / 2 * radians3)) * degrees3];
}
function gilbertInvert(point5) {
  return [point5[0] * 2, 2 * atan4(sin3(point5[1] * radians3)) * degrees3];
}
function gilbert_default(projectionType) {
  if (projectionType == null)
    projectionType = orthographic_default2;
  var projection4 = projectionType(), equirectangular = equirectangular_default2().scale(degrees3).precision(0).clipAngle(null).translate([0, 0]);
  function gilbert(point5) {
    return projection4(gilbertForward(point5));
  }
  if (projection4.invert)
    gilbert.invert = function(point5) {
      return gilbertInvert(projection4.invert(point5));
    };
  gilbert.stream = function(stream) {
    var s1 = projection4.stream(stream), s0 = equirectangular.stream({
      point: function(lambda, phi2) {
        s1.point(lambda / 2, asin3(tan3(-phi2 / 2 * radians3)) * degrees3);
      },
      lineStart: function() {
        s1.lineStart();
      },
      lineEnd: function() {
        s1.lineEnd();
      },
      polygonStart: function() {
        s1.polygonStart();
      },
      polygonEnd: function() {
        s1.polygonEnd();
      }
    });
    s0.sphere = s1.sphere;
    return s0;
  };
  function property(name) {
    gilbert[name] = function(_2) {
      return arguments.length ? (projection4[name](_2), gilbert) : projection4[name]();
    };
  }
  gilbert.rotate = function(_2) {
    return arguments.length ? (equirectangular.rotate(_2), gilbert) : equirectangular.rotate();
  };
  gilbert.center = function(_2) {
    return arguments.length ? (projection4.center(gilbertForward(_2)), gilbert) : gilbertInvert(projection4.center());
  };
  property("clipAngle");
  property("clipExtent");
  property("scale");
  property("translate");
  property("precision");
  return gilbert.scale(249.5);
}
var init_gilbert = __esm({
  "node_modules/d3-geo-projection/src/gilbert.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/gingery.js
function gingeryRaw(rho, n2) {
  var k4 = 2 * pi3 / n2, rho2 = rho * rho;
  function forward(lambda, phi2) {
    var p2 = azimuthalEquidistantRaw2(lambda, phi2), x4 = p2[0], y4 = p2[1], r2 = x4 * x4 + y4 * y4;
    if (r2 > rho2) {
      var r3 = sqrt3(r2), theta = atan23(y4, x4), theta0 = k4 * round(theta / k4), alpha = theta - theta0, rhoCosAlpha = rho * cos3(alpha), k_ = (rho * sin3(alpha) - alpha * sin3(rhoCosAlpha)) / (halfPi3 - rhoCosAlpha), s_ = gingeryLength(alpha, k_), e3 = (pi3 - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi3);
      x4 = r3;
      var i2 = 50, delta;
      do {
        x4 -= delta = (rho + gingeryIntegrate(s_, rhoCosAlpha, x4) * e3 - r3) / (s_(x4) * e3);
      } while (abs3(delta) > epsilon4 && --i2 > 0);
      y4 = alpha * sin3(x4);
      if (x4 < halfPi3)
        y4 -= k_ * (x4 - halfPi3);
      var s3 = sin3(theta0), c2 = cos3(theta0);
      p2[0] = x4 * c2 - y4 * s3;
      p2[1] = x4 * s3 + y4 * c2;
    }
    return p2;
  }
  forward.invert = function(x4, y4) {
    var r2 = x4 * x4 + y4 * y4;
    if (r2 > rho2) {
      var r3 = sqrt3(r2), theta = atan23(y4, x4), theta0 = k4 * round(theta / k4), dTheta = theta - theta0;
      x4 = r3 * cos3(dTheta);
      y4 = r3 * sin3(dTheta);
      var x_halfPi = x4 - halfPi3, sinx = sin3(x4), alpha = y4 / sinx, delta = x4 < halfPi3 ? Infinity : 0, i2 = 10;
      while (true) {
        var rhosinAlpha = rho * sin3(alpha), rhoCosAlpha = rho * cos3(alpha), sinRhoCosAlpha = sin3(rhoCosAlpha), halfPi_RhoCosAlpha = halfPi3 - rhoCosAlpha, k_ = (rhosinAlpha - alpha * sinRhoCosAlpha) / halfPi_RhoCosAlpha, s_ = gingeryLength(alpha, k_);
        if (abs3(delta) < epsilon23 || !--i2)
          break;
        alpha -= delta = (alpha * sinx - k_ * x_halfPi - y4) / (sinx - x_halfPi * 2 * (halfPi_RhoCosAlpha * (rhoCosAlpha + alpha * rhosinAlpha * cos3(rhoCosAlpha) - sinRhoCosAlpha) - rhosinAlpha * (rhosinAlpha - alpha * sinRhoCosAlpha)) / (halfPi_RhoCosAlpha * halfPi_RhoCosAlpha));
      }
      r3 = rho + gingeryIntegrate(s_, rhoCosAlpha, x4) * (pi3 - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi3);
      theta = theta0 + alpha;
      x4 = r3 * cos3(theta);
      y4 = r3 * sin3(theta);
    }
    return azimuthalEquidistantRaw2.invert(x4, y4);
  };
  return forward;
}
function gingeryLength(alpha, k4) {
  return function(x4) {
    var y_ = alpha * cos3(x4);
    if (x4 < halfPi3)
      y_ -= k4;
    return sqrt3(1 + y_ * y_);
  };
}
function gingeryIntegrate(f2, a3, b2) {
  var n2 = 50, h2 = (b2 - a3) / n2, s3 = f2(a3) + f2(b2);
  for (var i2 = 1, x4 = a3; i2 < n2; ++i2)
    s3 += 2 * f2(x4 += h2);
  return s3 * 0.5 * h2;
}
function gingery_default() {
  var n2 = 6, rho = 30 * radians3, cRho = cos3(rho), sRho = sin3(rho), m2 = projectionMutator2(gingeryRaw), p2 = m2(rho, n2), stream_ = p2.stream, epsilon12 = 0.01, cr = -cos3(epsilon12 * radians3), sr = sin3(epsilon12 * radians3);
  p2.radius = function(_2) {
    if (!arguments.length)
      return rho * degrees3;
    cRho = cos3(rho = _2 * radians3);
    sRho = sin3(rho);
    return m2(rho, n2);
  };
  p2.lobes = function(_2) {
    if (!arguments.length)
      return n2;
    return m2(rho, n2 = +_2);
  };
  p2.stream = function(stream) {
    var rotate = p2.rotate(), rotateStream = stream_(stream), sphereStream = (p2.rotate([0, 0]), stream_(stream));
    p2.rotate(rotate);
    rotateStream.sphere = function() {
      sphereStream.polygonStart(), sphereStream.lineStart();
      for (var i2 = 0, delta = 2 * pi3 / n2, phi2 = 0; i2 < n2; ++i2, phi2 -= delta) {
        sphereStream.point(atan23(sr * cos3(phi2), cr) * degrees3, asin3(sr * sin3(phi2)) * degrees3);
        sphereStream.point(atan23(sRho * cos3(phi2 - delta / 2), cRho) * degrees3, asin3(sRho * sin3(phi2 - delta / 2)) * degrees3);
      }
      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };
    return rotateStream;
  };
  return p2.rotate([90, -40]).scale(91.7095).clipAngle(180 - 1e-3);
}
var init_gingery = __esm({
  "node_modules/d3-geo-projection/src/gingery.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/ginzburgPolyconic.js
function ginzburgPolyconic_default(a3, b2, c2, d2, e3, f2, g2, h2) {
  if (arguments.length < 8)
    h2 = 0;
  function forward(lambda, phi2) {
    if (!phi2)
      return [a3 * lambda / pi3, 0];
    var phi22 = phi2 * phi2, xB = a3 + phi22 * (b2 + phi22 * (c2 + phi22 * d2)), yB = phi2 * (e3 - 1 + phi22 * (f2 - h2 + phi22 * g2)), m2 = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin3(xB / m2) / pi3;
    return [m2 * sin3(alpha), phi2 * (1 + phi22 * h2) + m2 * (1 - cos3(alpha))];
  }
  forward.invert = function(x4, y4) {
    var lambda = pi3 * x4 / a3, phi2 = y4, deltaLambda, deltaPhi, i2 = 50;
    do {
      var phi22 = phi2 * phi2, xB = a3 + phi22 * (b2 + phi22 * (c2 + phi22 * d2)), yB = phi2 * (e3 - 1 + phi22 * (f2 - h2 + phi22 * g2)), p2 = xB * xB + yB * yB, q2 = 2 * yB, m2 = p2 / q2, m22 = m2 * m2, dAlphadLambda = asin3(xB / m2) / pi3, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b2 + phi22 * (4 * c2 + phi22 * 6 * d2)) * phi2, dyBdPhi = e3 + phi22 * (3 * f2 + phi22 * 5 * g2), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q2 - p2 * dqdPhi) / (q2 * q2), cosAlpha = cos3(alpha), sinAlpha = sin3(alpha), mcosAlpha = m2 * cosAlpha, msinAlpha = m2 * sinAlpha, dAlphadPhi = lambda / pi3 * (1 / sqrt3(1 - xB2 / m22)) * (dxBdPhi * m2 - xB * dmdPhi) / m22, fx = msinAlpha - x4, fy = phi2 * (1 + phi22 * h2) + m2 - mcosAlpha - y4, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
      if (!denominator)
        break;
      lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
      phi2 -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    } while ((abs3(deltaLambda) > epsilon4 || abs3(deltaPhi) > epsilon4) && --i2 > 0);
    return [lambda, phi2];
  };
  return forward;
}
var init_ginzburgPolyconic = __esm({
  "node_modules/d3-geo-projection/src/ginzburgPolyconic.js"() {
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/ginzburg4.js
function ginzburg4_default() {
  return projection2(ginzburg4Raw).scale(149.995);
}
var ginzburg4Raw;
var init_ginzburg4 = __esm({
  "node_modules/d3-geo-projection/src/ginzburg4.js"() {
    init_src2();
    init_ginzburgPolyconic();
    ginzburg4Raw = ginzburgPolyconic_default(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);
  }
});

// node_modules/d3-geo-projection/src/ginzburg5.js
function ginzburg5_default() {
  return projection2(ginzburg5Raw).scale(153.93);
}
var ginzburg5Raw;
var init_ginzburg5 = __esm({
  "node_modules/d3-geo-projection/src/ginzburg5.js"() {
    init_src2();
    init_ginzburgPolyconic();
    ginzburg5Raw = ginzburgPolyconic_default(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);
  }
});

// node_modules/d3-geo-projection/src/ginzburg6.js
function ginzburg6_default() {
  return projection2(ginzburg6Raw).scale(130.945);
}
var ginzburg6Raw;
var init_ginzburg6 = __esm({
  "node_modules/d3-geo-projection/src/ginzburg6.js"() {
    init_src2();
    init_ginzburgPolyconic();
    init_math3();
    ginzburg6Raw = ginzburgPolyconic_default(5 / 6 * pi3, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);
  }
});

// node_modules/d3-geo-projection/src/ginzburg8.js
function ginzburg8Raw(lambda, phi2) {
  var lambda23 = lambda * lambda, phi22 = phi2 * phi2;
  return [
    lambda * (1 - 0.162388 * phi22) * (0.87 - 952426e-9 * lambda23 * lambda23),
    phi2 * (1 + phi22 / 12)
  ];
}
function ginzburg8_default() {
  return projection2(ginzburg8Raw).scale(131.747);
}
var init_ginzburg8 = __esm({
  "node_modules/d3-geo-projection/src/ginzburg8.js"() {
    init_src2();
    init_math3();
    ginzburg8Raw.invert = function(x4, y4) {
      var lambda = x4, phi2 = y4, i2 = 50, delta;
      do {
        var phi22 = phi2 * phi2;
        phi2 -= delta = (phi2 * (1 + phi22 / 12) - y4) / (1 + phi22 / 4);
      } while (abs3(delta) > epsilon4 && --i2 > 0);
      i2 = 50;
      x4 /= 1 - 0.162388 * phi22;
      do {
        var lambda4 = (lambda4 = lambda * lambda) * lambda4;
        lambda -= delta = (lambda * (0.87 - 952426e-9 * lambda4) - x4) / (0.87 - 476213e-8 * lambda4);
      } while (abs3(delta) > epsilon4 && --i2 > 0);
      return [lambda, phi2];
    };
  }
});

// node_modules/d3-geo-projection/src/ginzburg9.js
function ginzburg9_default() {
  return projection2(ginzburg9Raw).scale(131.087);
}
var ginzburg9Raw;
var init_ginzburg9 = __esm({
  "node_modules/d3-geo-projection/src/ginzburg9.js"() {
    init_src2();
    init_ginzburgPolyconic();
    ginzburg9Raw = ginzburgPolyconic_default(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);
  }
});

// node_modules/d3-geo-projection/src/square.js
function square_default(project) {
  var dx = project(halfPi3, 0)[0] - project(-halfPi3, 0)[0];
  function projectSquare(lambda, phi2) {
    var s3 = lambda > 0 ? -0.5 : 0.5, point5 = project(lambda + s3 * pi3, phi2);
    point5[0] -= s3 * dx;
    return point5;
  }
  if (project.invert)
    projectSquare.invert = function(x4, y4) {
      var s3 = x4 > 0 ? -0.5 : 0.5, location = project.invert(x4 + s3 * dx, y4), lambda = location[0] - s3 * pi3;
      if (lambda < -pi3)
        lambda += 2 * pi3;
      else if (lambda > pi3)
        lambda -= 2 * pi3;
      location[0] = lambda;
      return location;
    };
  return projectSquare;
}
var init_square = __esm({
  "node_modules/d3-geo-projection/src/square.js"() {
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/gringorten.js
function gringortenRaw(lambda, phi2) {
  var sLambda = sign3(lambda), sPhi = sign3(phi2), cosPhi = cos3(phi2), x4 = cos3(lambda) * cosPhi, y4 = sin3(lambda) * cosPhi, z2 = sin3(sPhi * phi2);
  lambda = abs3(atan23(y4, z2));
  phi2 = asin3(x4);
  if (abs3(lambda - halfPi3) > epsilon4)
    lambda %= halfPi3;
  var point5 = gringortenHexadecant(lambda > pi3 / 4 ? halfPi3 - lambda : lambda, phi2);
  if (lambda > pi3 / 4)
    z2 = point5[0], point5[0] = -point5[1], point5[1] = -z2;
  return point5[0] *= sLambda, point5[1] *= -sPhi, point5;
}
function gringortenHexadecant(lambda, phi2) {
  if (phi2 === halfPi3)
    return [0, 0];
  var sinPhi = sin3(phi2), r2 = sinPhi * sinPhi, r22 = r2 * r2, j2 = 1 + r22, k4 = 1 + 3 * r22, q2 = 1 - r22, z2 = asin3(1 / sqrt3(j2)), v2 = q2 + r2 * j2 * z2, p2 = (1 - sinPhi) / v2, p3 = sqrt3(p2), a22 = p2 * j2, a3 = sqrt3(a22), h2 = p3 * q2, x4, i2;
  if (lambda === 0)
    return [0, -(h2 + r2 * a3)];
  var cosPhi = cos3(phi2), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r2 + z2 * k4) * drdPhi, dp2dPhi = (-v2 * cosPhi - (1 - sinPhi) * dvdPhi) / (v2 * v2), dpdPhi = 0.5 * dp2dPhi / p3, dhdPhi = q2 * dpdPhi - 2 * r2 * p3 * drdPhi, dra2dPhi = r2 * j2 * dp2dPhi + p2 * k4 * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda13 = 4 * lambda / pi3, delta;
  if (lambda > 0.222 * pi3 || phi2 < pi3 / 4 && lambda > 0.175 * pi3) {
    x4 = (h2 + r2 * sqrt3(a22 * (1 + r22) - h2 * h2)) / (1 + r22);
    if (lambda > pi3 / 4)
      return [x4, x4];
    var x16 = x4, x011 = 0.5 * x4;
    x4 = 0.5 * (x011 + x16), i2 = 50;
    do {
      var g2 = sqrt3(a22 - x4 * x4), f2 = x4 * (zeta + mu * g2) + nu * asin3(x4 / a3) - lambda13;
      if (!f2)
        break;
      if (f2 < 0)
        x011 = x4;
      else
        x16 = x4;
      x4 = 0.5 * (x011 + x16);
    } while (abs3(x16 - x011) > epsilon4 && --i2 > 0);
  } else {
    x4 = epsilon4, i2 = 25;
    do {
      var x22 = x4 * x4, g22 = sqrt3(a22 - x22), zetaMug = zeta + mu * g22, f22 = x4 * zetaMug + nu * asin3(x4 / a3) - lambda13, df = zetaMug + (nu - mu * x22) / g22;
      x4 -= delta = g22 ? f22 / df : 0;
    } while (abs3(delta) > epsilon4 && --i2 > 0);
  }
  return [x4, -h2 - r2 * sqrt3(a22 - x4 * x4)];
}
function gringortenHexadecantInvert(x4, y4) {
  var x011 = 0, x16 = 1, r2 = 0.5, i2 = 50;
  while (true) {
    var r22 = r2 * r2, sinPhi = sqrt3(r2), z2 = asin3(1 / sqrt3(1 + r22)), v2 = 1 - r22 + r2 * (1 + r22) * z2, p2 = (1 - sinPhi) / v2, p3 = sqrt3(p2), a22 = p2 * (1 + r22), h2 = p3 * (1 - r22), g2 = a22 - x4 * x4, g3 = sqrt3(g2), y011 = y4 + h2 + r2 * g3;
    if (abs3(x16 - x011) < epsilon23 || --i2 === 0 || y011 === 0)
      break;
    if (y011 > 0)
      x011 = r2;
    else
      x16 = r2;
    r2 = 0.5 * (x011 + x16);
  }
  if (!i2)
    return null;
  var phi2 = asin3(sinPhi), cosPhi = cos3(phi2), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r2 + z2 * (1 + 3 * r22)) * drdPhi, dp2dPhi = (-v2 * cosPhi - (1 - sinPhi) * dvdPhi) / (v2 * v2), dpdPhi = 0.5 * dp2dPhi / p3, dhdPhi = (1 - r22) * dpdPhi - 2 * r2 * p3 * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r2 * (1 + r22) * dp2dPhi + p2 * (1 + 3 * r22) * drdPhi);
  return [pi3 / 4 * (x4 * (zeta + mu * g3) + nu * asin3(x4 / sqrt3(a22))), phi2];
}
function gringorten_default() {
  return projection2(square_default(gringortenRaw)).scale(239.75);
}
var init_gringorten = __esm({
  "node_modules/d3-geo-projection/src/gringorten.js"() {
    init_src2();
    init_math3();
    init_square();
    gringortenRaw.invert = function(x4, y4) {
      if (abs3(x4) > 1)
        x4 = sign3(x4) * 2 - x4;
      if (abs3(y4) > 1)
        y4 = sign3(y4) * 2 - y4;
      var sx = sign3(x4), sy = sign3(y4), x011 = -sx * x4, y011 = -sy * y4, t2 = y011 / x011 < 1, p2 = gringortenHexadecantInvert(t2 ? y011 : x011, t2 ? x011 : y011), lambda = p2[0], phi2 = p2[1], cosPhi = cos3(phi2);
      if (t2)
        lambda = -halfPi3 - lambda;
      return [sx * (atan23(sin3(lambda) * cosPhi, -sin3(phi2)) + pi3), sy * asin3(cos3(lambda) * cosPhi)];
    };
  }
});

// node_modules/d3-geo-projection/src/elliptic.js
function ellipticJi(u2, v2, m2) {
  var a3, b2, c2;
  if (!u2) {
    b2 = ellipticJ(v2, 1 - m2);
    return [
      [0, b2[0] / b2[1]],
      [1 / b2[1], 0],
      [b2[2] / b2[1], 0]
    ];
  }
  a3 = ellipticJ(u2, m2);
  if (!v2)
    return [[a3[0], 0], [a3[1], 0], [a3[2], 0]];
  b2 = ellipticJ(v2, 1 - m2);
  c2 = b2[1] * b2[1] + m2 * a3[0] * a3[0] * b2[0] * b2[0];
  return [
    [a3[0] * b2[2] / c2, a3[1] * a3[2] * b2[0] * b2[1] / c2],
    [a3[1] * b2[1] / c2, -a3[0] * a3[2] * b2[0] * b2[2] / c2],
    [a3[2] * b2[1] * b2[2] / c2, -m2 * a3[0] * a3[1] * b2[0] / c2]
  ];
}
function ellipticJ(u2, m2) {
  var ai, b2, phi2, t2, twon;
  if (m2 < epsilon4) {
    t2 = sin3(u2);
    b2 = cos3(u2);
    ai = m2 * (u2 - t2 * b2) / 4;
    return [
      t2 - ai * b2,
      b2 + ai * t2,
      1 - m2 * t2 * t2 / 2,
      u2 - ai
    ];
  }
  if (m2 >= 1 - epsilon4) {
    ai = (1 - m2) / 4;
    b2 = cosh(u2);
    t2 = tanh(u2);
    phi2 = 1 / b2;
    twon = b2 * sinh(u2);
    return [
      t2 + ai * (twon - u2) / (b2 * b2),
      phi2 - ai * t2 * phi2 * (twon - u2),
      phi2 + ai * t2 * phi2 * (twon + u2),
      2 * atan4(exp3(u2)) - halfPi3 + ai * (twon - u2) / b2
    ];
  }
  var a3 = [1, 0, 0, 0, 0, 0, 0, 0, 0], c2 = [sqrt3(m2), 0, 0, 0, 0, 0, 0, 0, 0], i2 = 0;
  b2 = sqrt3(1 - m2);
  twon = 1;
  while (abs3(c2[i2] / a3[i2]) > epsilon4 && i2 < 8) {
    ai = a3[i2++];
    c2[i2] = (ai - b2) / 2;
    a3[i2] = (ai + b2) / 2;
    b2 = sqrt3(ai * b2);
    twon *= 2;
  }
  phi2 = twon * a3[i2] * u2;
  do {
    t2 = c2[i2] * sin3(b2 = phi2) / a3[i2];
    phi2 = (asin3(t2) + phi2) / 2;
  } while (--i2);
  return [sin3(phi2), t2 = cos3(phi2), t2 / cos3(phi2 - b2), phi2];
}
function ellipticFi(phi2, psi, m2) {
  var r2 = abs3(phi2), i2 = abs3(psi), sinhPsi = sinh(i2);
  if (r2) {
    var cscPhi = 1 / sin3(r2), cotPhi2 = 1 / (tan3(r2) * tan3(r2)), b2 = -(cotPhi2 + m2 * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m2), c2 = (m2 - 1) * cotPhi2, cotLambda2 = (-b2 + sqrt3(b2 * b2 - 4 * c2)) / 2;
    return [
      ellipticF(atan4(1 / sqrt3(cotLambda2)), m2) * sign3(phi2),
      ellipticF(atan4(sqrt3((cotLambda2 / cotPhi2 - 1) / m2)), 1 - m2) * sign3(psi)
    ];
  }
  return [
    0,
    ellipticF(atan4(sinhPsi), 1 - m2) * sign3(psi)
  ];
}
function ellipticF(phi2, m2) {
  if (!m2)
    return phi2;
  if (m2 === 1)
    return log3(tan3(phi2 / 2 + quarterPi3));
  var a3 = 1, b2 = sqrt3(1 - m2), c2 = sqrt3(m2);
  for (var i2 = 0; abs3(c2) > epsilon4; i2++) {
    if (phi2 % pi3) {
      var dPhi = atan4(b2 * tan3(phi2) / a3);
      if (dPhi < 0)
        dPhi += pi3;
      phi2 += dPhi + ~~(phi2 / pi3) * pi3;
    } else
      phi2 += phi2;
    c2 = (a3 + b2) / 2;
    b2 = sqrt3(a3 * b2);
    c2 = ((a3 = c2) - b2) / 2;
  }
  return phi2 / (pow3(2, i2) * a3);
}
var init_elliptic = __esm({
  "node_modules/d3-geo-projection/src/elliptic.js"() {
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/guyou.js
function guyouRaw(lambda, phi2) {
  var k_ = (sqrt22 - 1) / (sqrt22 + 1), k4 = sqrt3(1 - k_ * k_), K3 = ellipticF(halfPi3, k4 * k4), f2 = -1, psi = log3(tan3(pi3 / 4 + abs3(phi2) / 2)), r2 = exp3(f2 * psi) / sqrt3(k_), at2 = guyouComplexAtan(r2 * cos3(f2 * lambda), r2 * sin3(f2 * lambda)), t2 = ellipticFi(at2[0], at2[1], k4 * k4);
  return [-t2[1], (phi2 >= 0 ? 1 : -1) * (0.5 * K3 - t2[0])];
}
function guyouComplexAtan(x4, y4) {
  var x22 = x4 * x4, y_1 = y4 + 1, t2 = 1 - x22 - y4 * y4;
  return [
    0.5 * ((x4 >= 0 ? halfPi3 : -halfPi3) - atan23(t2, 2 * x4)),
    -0.25 * log3(t2 * t2 + 4 * x22) + 0.5 * log3(y_1 * y_1 + x22)
  ];
}
function guyouComplexDivide(a3, b2) {
  var denominator = b2[0] * b2[0] + b2[1] * b2[1];
  return [
    (a3[0] * b2[0] + a3[1] * b2[1]) / denominator,
    (a3[1] * b2[0] - a3[0] * b2[1]) / denominator
  ];
}
function guyou_default() {
  return projection2(square_default(guyouRaw)).scale(151.496);
}
var init_guyou = __esm({
  "node_modules/d3-geo-projection/src/guyou.js"() {
    init_src2();
    init_elliptic();
    init_math3();
    init_square();
    guyouRaw.invert = function(x4, y4) {
      var k_ = (sqrt22 - 1) / (sqrt22 + 1), k4 = sqrt3(1 - k_ * k_), K3 = ellipticF(halfPi3, k4 * k4), f2 = -1, j2 = ellipticJi(0.5 * K3 - y4, -x4, k4 * k4), tn = guyouComplexDivide(j2[0], j2[1]), lambda = atan23(tn[1], tn[0]) / f2;
      return [
        lambda,
        2 * atan4(exp3(0.5 / f2 * log3(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi3
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/hammer.js
function hammerRaw(A6, B3) {
  if (arguments.length < 2)
    B3 = A6;
  if (B3 === 1)
    return azimuthalEqualAreaRaw2;
  if (B3 === Infinity)
    return hammerQuarticAuthalicRaw;
  function forward(lambda, phi2) {
    var coordinates2 = azimuthalEqualAreaRaw2(lambda / B3, phi2);
    coordinates2[0] *= A6;
    return coordinates2;
  }
  forward.invert = function(x4, y4) {
    var coordinates2 = azimuthalEqualAreaRaw2.invert(x4 / A6, y4);
    coordinates2[0] *= B3;
    return coordinates2;
  };
  return forward;
}
function hammerQuarticAuthalicRaw(lambda, phi2) {
  return [
    lambda * cos3(phi2) / cos3(phi2 /= 2),
    2 * sin3(phi2)
  ];
}
function hammer_default() {
  var B3 = 2, m2 = projectionMutator2(hammerRaw), p2 = m2(B3);
  p2.coefficient = function(_2) {
    if (!arguments.length)
      return B3;
    return m2(B3 = +_2);
  };
  return p2.scale(169.529);
}
var init_hammer = __esm({
  "node_modules/d3-geo-projection/src/hammer.js"() {
    init_src2();
    init_math3();
    hammerQuarticAuthalicRaw.invert = function(x4, y4) {
      var phi2 = 2 * asin3(y4 / 2);
      return [
        x4 * cos3(phi2 / 2) / cos3(phi2),
        phi2
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/hammerRetroazimuthal.js
function hammerRetroazimuthalRaw(phi04) {
  var sinPhi04 = sin3(phi04), cosPhi04 = cos3(phi04), rotate = hammerRetroazimuthalRotation(phi04);
  rotate.invert = hammerRetroazimuthalRotation(-phi04);
  function forward(lambda, phi2) {
    var p2 = rotate(lambda, phi2);
    lambda = p2[0], phi2 = p2[1];
    var sinPhi = sin3(phi2), cosPhi = cos3(phi2), cosLambda = cos3(lambda), z2 = acos3(sinPhi04 * sinPhi + cosPhi04 * cosPhi * cosLambda), sinz = sin3(z2), K3 = abs3(sinz) > epsilon4 ? z2 / sinz : 1;
    return [
      K3 * cosPhi04 * sin3(lambda),
      (abs3(lambda) > halfPi3 ? K3 : -K3) * (sinPhi04 * cosPhi - cosPhi04 * sinPhi * cosLambda)
    ];
  }
  forward.invert = function(x4, y4) {
    var rho = sqrt3(x4 * x4 + y4 * y4), sinz = -sin3(rho), cosz = cos3(rho), a3 = rho * cosz, b2 = -y4 * sinz, c2 = rho * sinPhi04, d2 = sqrt3(a3 * a3 + b2 * b2 - c2 * c2), phi2 = atan23(a3 * c2 + b2 * d2, b2 * c2 - a3 * d2), lambda = (rho > halfPi3 ? -1 : 1) * atan23(x4 * sinz, rho * cos3(phi2) * cosz + y4 * sin3(phi2) * sinz);
    return rotate.invert(lambda, phi2);
  };
  return forward;
}
function hammerRetroazimuthalRotation(phi04) {
  var sinPhi04 = sin3(phi04), cosPhi04 = cos3(phi04);
  return function(lambda, phi2) {
    var cosPhi = cos3(phi2), x4 = cos3(lambda) * cosPhi, y4 = sin3(lambda) * cosPhi, z2 = sin3(phi2);
    return [
      atan23(y4, x4 * cosPhi04 - z2 * sinPhi04),
      asin3(z2 * cosPhi04 + x4 * sinPhi04)
    ];
  };
}
function hammerRetroazimuthal_default() {
  var phi04 = 0, m2 = projectionMutator2(hammerRetroazimuthalRaw), p2 = m2(phi04), rotate_ = p2.rotate, stream_ = p2.stream, circle4 = circle_default3();
  p2.parallel = function(_2) {
    if (!arguments.length)
      return phi04 * degrees3;
    var r2 = p2.rotate();
    return m2(phi04 = _2 * radians3).rotate(r2);
  };
  p2.rotate = function(_2) {
    if (!arguments.length)
      return _2 = rotate_.call(p2), _2[1] += phi04 * degrees3, _2;
    rotate_.call(p2, [_2[0], _2[1] - phi04 * degrees3]);
    circle4.center([-_2[0], -_2[1]]);
    return p2;
  };
  p2.stream = function(stream) {
    stream = stream_(stream);
    stream.sphere = function() {
      stream.polygonStart();
      var epsilon12 = 0.01, ring = circle4.radius(90 - epsilon12)().coordinates[0], n2 = ring.length - 1, i2 = -1, p3;
      stream.lineStart();
      while (++i2 < n2)
        stream.point((p3 = ring[i2])[0], p3[1]);
      stream.lineEnd();
      ring = circle4.radius(90 + epsilon12)().coordinates[0];
      n2 = ring.length - 1;
      stream.lineStart();
      while (--i2 >= 0)
        stream.point((p3 = ring[i2])[0], p3[1]);
      stream.lineEnd();
      stream.polygonEnd();
    };
    return stream;
  };
  return p2.scale(79.4187).parallel(45).clipAngle(180 - 1e-3);
}
var init_hammerRetroazimuthal = __esm({
  "node_modules/d3-geo-projection/src/hammerRetroazimuthal.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/healpix.js
function healpixRaw(H2) {
  var phi04 = healpixParallel * radians3, dx = collignonRaw(pi3, phi04)[0] - collignonRaw(-pi3, phi04)[0], y011 = healpixLambert(0, phi04)[1], y16 = collignonRaw(0, phi04)[1], dy1 = sqrtPi - y16, k4 = tau3 / H2, w3 = 4 / tau3, h2 = y011 + dy1 * dy1 * 4 / tau3;
  function forward(lambda, phi2) {
    var point5, phi22 = abs3(phi2);
    if (phi22 > phi04) {
      var i2 = min(H2 - 1, max(0, floor((lambda + pi3) / k4)));
      lambda += pi3 * (H2 - 1) / H2 - i2 * k4;
      point5 = collignonRaw(lambda, phi22);
      point5[0] = point5[0] * tau3 / dx - tau3 * (H2 - 1) / (2 * H2) + i2 * tau3 / H2;
      point5[1] = y011 + (point5[1] - y16) * 4 * dy1 / tau3;
      if (phi2 < 0)
        point5[1] = -point5[1];
    } else {
      point5 = healpixLambert(lambda, phi2);
    }
    point5[0] *= w3, point5[1] /= h2;
    return point5;
  }
  forward.invert = function(x4, y4) {
    x4 /= w3, y4 *= h2;
    var y22 = abs3(y4);
    if (y22 > y011) {
      var i2 = min(H2 - 1, max(0, floor((x4 + pi3) / k4)));
      x4 = (x4 + pi3 * (H2 - 1) / H2 - i2 * k4) * dx / tau3;
      var point5 = collignonRaw.invert(x4, 0.25 * (y22 - y011) * tau3 / dy1 + y16);
      point5[0] -= pi3 * (H2 - 1) / H2 - i2 * k4;
      if (y4 < 0)
        point5[1] = -point5[1];
      return point5;
    }
    return healpixLambert.invert(x4, y4);
  };
  return forward;
}
function sphere(step) {
  return {
    type: "Polygon",
    coordinates: [
      range_default(-180, 180 + step / 2, step).map(function(x4, i2) {
        return [x4, i2 & 1 ? 90 - 1e-6 : healpixParallel];
      }).concat(range_default(180, -180 - step / 2, -step).map(function(x4, i2) {
        return [x4, i2 & 1 ? -90 + 1e-6 : -healpixParallel];
      }))
    ]
  };
}
function healpix_default() {
  var H2 = 4, m2 = projectionMutator2(healpixRaw), p2 = m2(H2), stream_ = p2.stream;
  p2.lobes = function(_2) {
    return arguments.length ? m2(H2 = +_2) : H2;
  };
  p2.stream = function(stream) {
    var rotate = p2.rotate(), rotateStream = stream_(stream), sphereStream = (p2.rotate([0, 0]), stream_(stream));
    p2.rotate(rotate);
    rotateStream.sphere = function() {
      stream_default2(sphere(180 / H2), sphereStream);
    };
    return rotateStream;
  };
  return p2.scale(239.75);
}
var healpixParallel, healpixLambert;
var init_healpix = __esm({
  "node_modules/d3-geo-projection/src/healpix.js"() {
    init_src();
    init_src2();
    init_collignon();
    init_cylindricalEqualArea3();
    init_math3();
    healpixParallel = 41 + 48 / 36 + 37 / 3600;
    healpixLambert = cylindricalEqualAreaRaw3(0);
  }
});

// node_modules/d3-geo-projection/src/hill.js
function hillRaw(K3) {
  var L2 = 1 + K3, sinBt = sin3(1 / L2), Bt = asin3(sinBt), A6 = 2 * sqrt3(pi3 / (B3 = pi3 + 4 * Bt * L2)), B3, rho0 = 0.5 * A6 * (L2 + sqrt3(K3 * (2 + K3))), K22 = K3 * K3, L22 = L2 * L2;
  function forward(lambda, phi2) {
    var t2 = 1 - sin3(phi2), rho, omega;
    if (t2 && t2 < 2) {
      var theta = halfPi3 - phi2, i2 = 25, delta;
      do {
        var sinTheta = sin3(theta), cosTheta = cos3(theta), Bt_Bt1 = Bt + atan23(sinTheta, L2 - cosTheta), C2 = 1 + L22 - 2 * L2 * cosTheta;
        theta -= delta = (theta - K22 * Bt - L2 * sinTheta + C2 * Bt_Bt1 - 0.5 * t2 * B3) / (2 * L2 * sinTheta * Bt_Bt1);
      } while (abs3(delta) > epsilon23 && --i2 > 0);
      rho = A6 * sqrt3(C2);
      omega = lambda * Bt_Bt1 / pi3;
    } else {
      rho = A6 * (K3 + t2);
      omega = lambda * Bt / pi3;
    }
    return [
      rho * sin3(omega),
      rho0 - rho * cos3(omega)
    ];
  }
  forward.invert = function(x4, y4) {
    var rho2 = x4 * x4 + (y4 -= rho0) * y4, cosTheta = (1 + L22 - rho2 / (A6 * A6)) / (2 * L2), theta = acos3(cosTheta), sinTheta = sin3(theta), Bt_Bt1 = Bt + atan23(sinTheta, L2 - cosTheta);
    return [
      asin3(x4 / sqrt3(rho2)) * pi3 / Bt_Bt1,
      asin3(1 - 2 * (theta - K22 * Bt - L2 * sinTheta + (1 + L22 - 2 * L2 * cosTheta) * Bt_Bt1) / B3)
    ];
  };
  return forward;
}
function hill_default() {
  var K3 = 1, m2 = projectionMutator2(hillRaw), p2 = m2(K3);
  p2.ratio = function(_2) {
    return arguments.length ? m2(K3 = +_2) : K3;
  };
  return p2.scale(167.774).center([0, 18.67]);
}
var init_hill = __esm({
  "node_modules/d3-geo-projection/src/hill.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/sinuMollweide.js
function sinuMollweideRaw(lambda, phi2) {
  return phi2 > -sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi2), lambda[1] += sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi2);
}
function sinuMollweide_default() {
  return projection2(sinuMollweideRaw).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
}
var sinuMollweidePhi, sinuMollweideY;
var init_sinuMollweide = __esm({
  "node_modules/d3-geo-projection/src/sinuMollweide.js"() {
    init_src2();
    init_mollweide();
    init_sinusoidal();
    sinuMollweidePhi = 0.7109889596207567;
    sinuMollweideY = 0.0528035274542;
    sinuMollweideRaw.invert = function(x4, y4) {
      return y4 > -sinuMollweidePhi ? mollweideRaw.invert(x4, y4 - sinuMollweideY) : sinusoidalRaw.invert(x4, y4);
    };
  }
});

// node_modules/d3-geo-projection/src/homolosine.js
function homolosineRaw(lambda, phi2) {
  return abs3(phi2) > sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi2), lambda[1] -= phi2 > 0 ? sinuMollweideY : -sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi2);
}
function homolosine_default() {
  return projection2(homolosineRaw).scale(152.63);
}
var init_homolosine = __esm({
  "node_modules/d3-geo-projection/src/homolosine.js"() {
    init_src2();
    init_math3();
    init_mollweide();
    init_sinusoidal();
    init_sinuMollweide();
    homolosineRaw.invert = function(x4, y4) {
      return abs3(y4) > sinuMollweidePhi ? mollweideRaw.invert(x4, y4 + (y4 > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidalRaw.invert(x4, y4);
    };
  }
});

// node_modules/d3-geo-projection/src/interrupted/index.js
function pointEqual(a3, b2) {
  return abs3(a3[0] - b2[0]) < epsilon4 && abs3(a3[1] - b2[1]) < epsilon4;
}
function interpolateLine(coordinates2, m2) {
  var i2 = -1, n2 = coordinates2.length, p03 = coordinates2[0], p1, dx, dy, resampled = [];
  while (++i2 < n2) {
    p1 = coordinates2[i2];
    dx = (p1[0] - p03[0]) / m2;
    dy = (p1[1] - p03[1]) / m2;
    for (var j2 = 0; j2 < m2; ++j2)
      resampled.push([p03[0] + j2 * dx, p03[1] + j2 * dy]);
    p03 = p1;
  }
  resampled.push(p1);
  return resampled;
}
function interpolateSphere(lobes7) {
  var coordinates2 = [], lobe, lambda06, phi04, phi13, lambda23, phi2, i2, n2 = lobes7[0].length;
  for (i2 = 0; i2 < n2; ++i2) {
    lobe = lobes7[0][i2];
    lambda06 = lobe[0][0], phi04 = lobe[0][1], phi13 = lobe[1][1];
    lambda23 = lobe[2][0], phi2 = lobe[2][1];
    coordinates2.push(interpolateLine([
      [lambda06 + epsilon4, phi04 + epsilon4],
      [lambda06 + epsilon4, phi13 - epsilon4],
      [lambda23 - epsilon4, phi13 - epsilon4],
      [lambda23 - epsilon4, phi2 + epsilon4]
    ], 30));
  }
  for (i2 = lobes7[1].length - 1; i2 >= 0; --i2) {
    lobe = lobes7[1][i2];
    lambda06 = lobe[0][0], phi04 = lobe[0][1], phi13 = lobe[1][1];
    lambda23 = lobe[2][0], phi2 = lobe[2][1];
    coordinates2.push(interpolateLine([
      [lambda23 - epsilon4, phi2 - epsilon4],
      [lambda23 - epsilon4, phi13 + epsilon4],
      [lambda06 + epsilon4, phi13 + epsilon4],
      [lambda06 + epsilon4, phi04 - epsilon4]
    ], 30));
  }
  return {
    type: "Polygon",
    coordinates: [merge_default(coordinates2)]
  };
}
function interrupted_default(project, lobes7) {
  var sphere2 = interpolateSphere(lobes7);
  lobes7 = lobes7.map(function(lobe) {
    return lobe.map(function(l2) {
      return [
        [l2[0][0] * radians3, l2[0][1] * radians3],
        [l2[1][0] * radians3, l2[1][1] * radians3],
        [l2[2][0] * radians3, l2[2][1] * radians3]
      ];
    });
  });
  var bounds = lobes7.map(function(lobe) {
    return lobe.map(function(l2) {
      var x011 = project(l2[0][0], l2[0][1])[0], x16 = project(l2[2][0], l2[2][1])[0], y011 = project(l2[1][0], l2[0][1])[1], y16 = project(l2[1][0], l2[1][1])[1], t2;
      if (y011 > y16)
        t2 = y011, y011 = y16, y16 = t2;
      return [[x011, y011], [x16, y16]];
    });
  });
  function forward(lambda, phi2) {
    var sign6 = phi2 < 0 ? -1 : 1, lobe = lobes7[+(phi2 < 0)];
    for (var i2 = 0, n2 = lobe.length - 1; i2 < n2 && lambda > lobe[i2][2][0]; ++i2)
      ;
    var p3 = project(lambda - lobe[i2][1][0], phi2);
    p3[0] += project(lobe[i2][1][0], sign6 * phi2 > sign6 * lobe[i2][0][1] ? lobe[i2][0][1] : phi2)[0];
    return p3;
  }
  if (project.invert)
    forward.invert = function(x4, y4) {
      var bound = bounds[+(y4 < 0)], lobe = lobes7[+(y4 < 0)];
      for (var i2 = 0, n2 = bound.length; i2 < n2; ++i2) {
        var b2 = bound[i2];
        if (b2[0][0] <= x4 && x4 < b2[1][0] && b2[0][1] <= y4 && y4 < b2[1][1]) {
          var p3 = project.invert(x4 - project(lobe[i2][1][0], 0)[0], y4);
          p3[0] += lobe[i2][1][0];
          return pointEqual(forward(p3[0], p3[1]), [x4, y4]) ? p3 : null;
        }
      }
    };
  var p2 = projection2(forward), stream_ = p2.stream;
  p2.stream = function(stream) {
    var rotate = p2.rotate(), rotateStream = stream_(stream), sphereStream = (p2.rotate([0, 0]), stream_(stream));
    p2.rotate(rotate);
    rotateStream.sphere = function() {
      stream_default2(sphere2, sphereStream);
    };
    return rotateStream;
  };
  return p2;
}
var init_interrupted = __esm({
  "node_modules/d3-geo-projection/src/interrupted/index.js"() {
    init_src();
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/interrupted/boggs.js
function boggs_default2() {
  return interrupted_default(boggsRaw, lobes).scale(160.857);
}
var lobes;
var init_boggs2 = __esm({
  "node_modules/d3-geo-projection/src/interrupted/boggs.js"() {
    init_boggs();
    init_interrupted();
    lobes = [[
      [[-180, 0], [-100, 90], [-40, 0]],
      [[-40, 0], [30, 90], [180, 0]]
    ], [
      [[-180, 0], [-160, -90], [-100, 0]],
      [[-100, 0], [-60, -90], [-20, 0]],
      [[-20, 0], [20, -90], [80, 0]],
      [[80, 0], [140, -90], [180, 0]]
    ]];
  }
});

// node_modules/d3-geo-projection/src/interrupted/homolosine.js
function homolosine_default2() {
  return interrupted_default(homolosineRaw, lobes2).scale(152.63);
}
var lobes2;
var init_homolosine2 = __esm({
  "node_modules/d3-geo-projection/src/interrupted/homolosine.js"() {
    init_homolosine();
    init_interrupted();
    lobes2 = [[
      [[-180, 0], [-100, 90], [-40, 0]],
      [[-40, 0], [30, 90], [180, 0]]
    ], [
      [[-180, 0], [-160, -90], [-100, 0]],
      [[-100, 0], [-60, -90], [-20, 0]],
      [[-20, 0], [20, -90], [80, 0]],
      [[80, 0], [140, -90], [180, 0]]
    ]];
  }
});

// node_modules/d3-geo-projection/src/interrupted/mollweide.js
function mollweide_default2() {
  return interrupted_default(mollweideRaw, lobes3).scale(169.529);
}
var lobes3;
var init_mollweide2 = __esm({
  "node_modules/d3-geo-projection/src/interrupted/mollweide.js"() {
    init_mollweide();
    init_interrupted();
    lobes3 = [[
      [[-180, 0], [-100, 90], [-40, 0]],
      [[-40, 0], [30, 90], [180, 0]]
    ], [
      [[-180, 0], [-160, -90], [-100, 0]],
      [[-100, 0], [-60, -90], [-20, 0]],
      [[-20, 0], [20, -90], [80, 0]],
      [[80, 0], [140, -90], [180, 0]]
    ]];
  }
});

// node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js
function mollweideHemispheres_default() {
  return interrupted_default(mollweideRaw, lobes4).scale(169.529).rotate([20, 0]);
}
var lobes4;
var init_mollweideHemispheres = __esm({
  "node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js"() {
    init_mollweide();
    init_interrupted();
    lobes4 = [[
      [[-180, 0], [-90, 90], [0, 0]],
      [[0, 0], [90, 90], [180, 0]]
    ], [
      [[-180, 0], [-90, -90], [0, 0]],
      [[0, 0], [90, -90], [180, 0]]
    ]];
  }
});

// node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js
function sinuMollweide_default2() {
  return interrupted_default(sinuMollweideRaw, lobes5).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
}
var lobes5;
var init_sinuMollweide2 = __esm({
  "node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js"() {
    init_sinuMollweide();
    init_interrupted();
    lobes5 = [[
      [[-180, 35], [-30, 90], [0, 35]],
      [[0, 35], [30, 90], [180, 35]]
    ], [
      [[-180, -10], [-102, -90], [-65, -10]],
      [[-65, -10], [5, -90], [77, -10]],
      [[77, -10], [103, -90], [180, -10]]
    ]];
  }
});

// node_modules/d3-geo-projection/src/interrupted/sinusoidal.js
function sinusoidal_default2() {
  return interrupted_default(sinusoidalRaw, lobes6).scale(152.63).rotate([-20, 0]);
}
var lobes6;
var init_sinusoidal2 = __esm({
  "node_modules/d3-geo-projection/src/interrupted/sinusoidal.js"() {
    init_sinusoidal();
    init_interrupted();
    lobes6 = [[
      [[-180, 0], [-110, 90], [-40, 0]],
      [[-40, 0], [0, 90], [40, 0]],
      [[40, 0], [110, 90], [180, 0]]
    ], [
      [[-180, 0], [-110, -90], [-40, 0]],
      [[-40, 0], [0, -90], [40, 0]],
      [[40, 0], [110, -90], [180, 0]]
    ]];
  }
});

// node_modules/d3-geo-projection/src/kavrayskiy7.js
function kavrayskiy7Raw(lambda, phi2) {
  return [3 / tau3 * lambda * sqrt3(pi3 * pi3 / 3 - phi2 * phi2), phi2];
}
function kavrayskiy7_default() {
  return projection2(kavrayskiy7Raw).scale(158.837);
}
var init_kavrayskiy7 = __esm({
  "node_modules/d3-geo-projection/src/kavrayskiy7.js"() {
    init_src2();
    init_math3();
    kavrayskiy7Raw.invert = function(x4, y4) {
      return [tau3 / 3 * x4 / sqrt3(pi3 * pi3 / 3 - y4 * y4), y4];
    };
  }
});

// node_modules/d3-geo-projection/src/lagrange.js
function lagrangeRaw(n2) {
  function forward(lambda, phi2) {
    if (abs3(abs3(phi2) - halfPi3) < epsilon4)
      return [0, phi2 < 0 ? -2 : 2];
    var sinPhi = sin3(phi2), v2 = pow3((1 + sinPhi) / (1 - sinPhi), n2 / 2), c2 = 0.5 * (v2 + 1 / v2) + cos3(lambda *= n2);
    return [
      2 * sin3(lambda) / c2,
      (v2 - 1 / v2) / c2
    ];
  }
  forward.invert = function(x4, y4) {
    var y011 = abs3(y4);
    if (abs3(y011 - 2) < epsilon4)
      return x4 ? null : [0, sign3(y4) * halfPi3];
    if (y011 > 2)
      return null;
    x4 /= 2, y4 /= 2;
    var x22 = x4 * x4, y22 = y4 * y4, t2 = 2 * y4 / (1 + x22 + y22);
    t2 = pow3((1 + t2) / (1 - t2), 1 / n2);
    return [
      atan23(2 * x4, 1 - x22 - y22) / n2,
      asin3((t2 - 1) / (t2 + 1))
    ];
  };
  return forward;
}
function lagrange_default() {
  var n2 = 0.5, m2 = projectionMutator2(lagrangeRaw), p2 = m2(n2);
  p2.spacing = function(_2) {
    return arguments.length ? m2(n2 = +_2) : n2;
  };
  return p2.scale(124.75);
}
var init_lagrange = __esm({
  "node_modules/d3-geo-projection/src/lagrange.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/larrivee.js
function larriveeRaw(lambda, phi2) {
  return [
    lambda * (1 + sqrt3(cos3(phi2))) / 2,
    phi2 / (cos3(phi2 / 2) * cos3(lambda / 6))
  ];
}
function larrivee_default() {
  return projection2(larriveeRaw).scale(97.2672);
}
var pi_sqrt2;
var init_larrivee = __esm({
  "node_modules/d3-geo-projection/src/larrivee.js"() {
    init_src2();
    init_math3();
    pi_sqrt2 = pi3 / sqrt22;
    larriveeRaw.invert = function(x4, y4) {
      var x011 = abs3(x4), y011 = abs3(y4), lambda = epsilon4, phi2 = halfPi3;
      if (y011 < pi_sqrt2)
        phi2 *= y011 / pi_sqrt2;
      else
        lambda += 6 * acos3(pi_sqrt2 / y011);
      for (var i2 = 0; i2 < 25; i2++) {
        var sinPhi = sin3(phi2), sqrtcosPhi = sqrt3(cos3(phi2)), sinPhi_2 = sin3(phi2 / 2), cosPhi_2 = cos3(phi2 / 2), sinLambda_6 = sin3(lambda / 6), cosLambda_6 = cos3(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x011, f1 = phi2 / (cosPhi_2 * cosLambda_6) - y011, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi2 * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = phi2 / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
        phi2 -= dPhi;
        lambda -= dLambda;
        if (abs3(dPhi) < epsilon4 && abs3(dLambda) < epsilon4)
          break;
      }
      return [x4 < 0 ? -lambda : lambda, y4 < 0 ? -phi2 : phi2];
    };
  }
});

// node_modules/d3-geo-projection/src/laskowski.js
function laskowskiRaw(lambda, phi2) {
  var lambda23 = lambda * lambda, phi22 = phi2 * phi2;
  return [
    lambda * (0.975534 + phi22 * (-0.119161 + lambda23 * -0.0143059 + phi22 * -0.0547009)),
    phi2 * (1.00384 + lambda23 * (0.0802894 + phi22 * -0.02855 + lambda23 * 199025e-9) + phi22 * (0.0998909 + phi22 * -0.0491032))
  ];
}
function laskowski_default() {
  return projection2(laskowskiRaw).scale(139.98);
}
var init_laskowski = __esm({
  "node_modules/d3-geo-projection/src/laskowski.js"() {
    init_src2();
    init_math3();
    laskowskiRaw.invert = function(x4, y4) {
      var lambda = sign3(x4) * pi3, phi2 = y4 / 2, i2 = 50;
      do {
        var lambda23 = lambda * lambda, phi22 = phi2 * phi2, lambdaPhi = lambda * phi2, fx = lambda * (0.975534 + phi22 * (-0.119161 + lambda23 * -0.0143059 + phi22 * -0.0547009)) - x4, fy = phi2 * (1.00384 + lambda23 * (0.0802894 + phi22 * -0.02855 + lambda23 * 199025e-9) + phi22 * (0.0998909 + phi22 * -0.0491032)) - y4, deltaxDeltaLambda = 0.975534 - phi22 * (0.119161 + 3 * lambda23 * 0.0143059 + phi22 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi22 + 2 * 0.0143059 * lambda23), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 199025e-9 * lambda23 + 2 * -0.02855 * phi22), deltayDeltaPhi = 1.00384 + lambda23 * (0.0802894 + 199025e-9 * lambda23) + phi22 * (3 * (0.0998909 - 0.02855 * lambda23) - 5 * 0.0491032 * phi22), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
        lambda -= deltaLambda, phi2 -= deltaPhi;
      } while ((abs3(deltaLambda) > epsilon4 || abs3(deltaPhi) > epsilon4) && --i2 > 0);
      return i2 && [lambda, phi2];
    };
  }
});

// node_modules/d3-geo-projection/src/littrow.js
function littrowRaw(lambda, phi2) {
  return [
    sin3(lambda) / cos3(phi2),
    tan3(phi2) * cos3(lambda)
  ];
}
function littrow_default() {
  return projection2(littrowRaw).scale(144.049).clipAngle(90 - 1e-3);
}
var init_littrow = __esm({
  "node_modules/d3-geo-projection/src/littrow.js"() {
    init_src2();
    init_math3();
    littrowRaw.invert = function(x4, y4) {
      var x22 = x4 * x4, y22 = y4 * y4, y2_1 = y22 + 1, cosPhi = x4 ? sqrt1_2 * sqrt3((y2_1 - sqrt3(x22 * x22 + 2 * x22 * (y22 - 1) + y2_1 * y2_1)) / x22 + 1) : 1 / sqrt3(y2_1);
      return [
        asin3(x4 * cosPhi),
        sign3(y4) * acos3(cosPhi)
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/loximuthal.js
function loximuthalRaw(phi04) {
  var cosPhi04 = cos3(phi04), tanPhi0 = tan3(quarterPi3 + phi04 / 2);
  function forward(lambda, phi2) {
    var y4 = phi2 - phi04, x4 = abs3(y4) < epsilon4 ? lambda * cosPhi04 : abs3(x4 = quarterPi3 + phi2 / 2) < epsilon4 || abs3(abs3(x4) - halfPi3) < epsilon4 ? 0 : lambda * y4 / log3(tan3(x4) / tanPhi0);
    return [x4, y4];
  }
  forward.invert = function(x4, y4) {
    var lambda, phi2 = y4 + phi04;
    return [
      abs3(y4) < epsilon4 ? x4 / cosPhi04 : abs3(lambda = quarterPi3 + phi2 / 2) < epsilon4 || abs3(abs3(lambda) - halfPi3) < epsilon4 ? 0 : x4 * log3(tan3(lambda) / tanPhi0) / y4,
      phi2
    ];
  };
  return forward;
}
function loximuthal_default() {
  return parallel1_default(loximuthalRaw).parallel(40).scale(158.837);
}
var init_loximuthal = __esm({
  "node_modules/d3-geo-projection/src/loximuthal.js"() {
    init_parallel1();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/miller.js
function millerRaw(lambda, phi2) {
  return [lambda, 1.25 * log3(tan3(quarterPi3 + 0.4 * phi2))];
}
function miller_default() {
  return projection2(millerRaw).scale(108.318);
}
var init_miller = __esm({
  "node_modules/d3-geo-projection/src/miller.js"() {
    init_src2();
    init_math3();
    millerRaw.invert = function(x4, y4) {
      return [x4, 2.5 * atan4(exp3(0.8 * y4)) - 0.625 * pi3];
    };
  }
});

// node_modules/d3-geo-projection/src/modifiedStereographic.js
function modifiedStereographicRaw(C2) {
  var m2 = C2.length - 1;
  function forward(lambda, phi2) {
    var cosPhi = cos3(phi2), k4 = 2 / (1 + cosPhi * cos3(lambda)), zr = k4 * cosPhi * sin3(lambda), zi = k4 * sin3(phi2), i2 = m2, w3 = C2[i2], ar = w3[0], ai = w3[1], t2;
    while (--i2 >= 0) {
      w3 = C2[i2];
      ar = w3[0] + zr * (t2 = ar) - zi * ai;
      ai = w3[1] + zr * ai + zi * t2;
    }
    ar = zr * (t2 = ar) - zi * ai;
    ai = zr * ai + zi * t2;
    return [ar, ai];
  }
  forward.invert = function(x4, y4) {
    var i2 = 20, zr = x4, zi = y4;
    do {
      var j2 = m2, w3 = C2[j2], ar = w3[0], ai = w3[1], br = 0, bi = 0, t2;
      while (--j2 >= 0) {
        w3 = C2[j2];
        br = ar + zr * (t2 = br) - zi * bi;
        bi = ai + zr * bi + zi * t2;
        ar = w3[0] + zr * (t2 = ar) - zi * ai;
        ai = w3[1] + zr * ai + zi * t2;
      }
      br = ar + zr * (t2 = br) - zi * bi;
      bi = ai + zr * bi + zi * t2;
      ar = zr * (t2 = ar) - zi * ai - x4;
      ai = zr * ai + zi * t2 - y4;
      var denominator = br * br + bi * bi, deltar, deltai;
      zr -= deltar = (ar * br + ai * bi) / denominator;
      zi -= deltai = (ai * br - ar * bi) / denominator;
    } while (abs3(deltar) + abs3(deltai) > epsilon4 * epsilon4 && --i2 > 0);
    if (i2) {
      var rho = sqrt3(zr * zr + zi * zi), c2 = 2 * atan4(rho * 0.5), sinc = sin3(c2);
      return [atan23(zr * sinc, rho * cos3(c2)), rho ? asin3(zi * sinc / rho) : 0];
    }
  };
  return forward;
}
function modifiedStereographicAlaska() {
  return modifiedStereographic(alaska, [152, -64]).scale(1500).center([-160.908, 62.4864]).clipAngle(25);
}
function modifiedStereographicGs48() {
  return modifiedStereographic(gs48, [95, -38]).scale(1e3).clipAngle(55).center([-96.5563, 38.8675]);
}
function modifiedStereographicGs50() {
  return modifiedStereographic(gs50, [120, -45]).scale(359.513).clipAngle(55).center([-117.474, 53.0628]);
}
function modifiedStereographicMiller() {
  return modifiedStereographic(miller, [-20, -18]).scale(209.091).center([20, 16.7214]).clipAngle(82);
}
function modifiedStereographicLee() {
  return modifiedStereographic(lee, [165, 10]).scale(250).clipAngle(130).center([-165, -10]);
}
function modifiedStereographic(coefficients, rotate) {
  var p2 = projection2(modifiedStereographicRaw(coefficients)).rotate(rotate).clipAngle(90), r2 = rotation_default2(rotate), center2 = p2.center;
  delete p2.rotate;
  p2.center = function(_2) {
    return arguments.length ? center2(r2(_2)) : r2.invert(center2());
  };
  return p2;
}
var alaska, gs48, gs50, miller, lee;
var init_modifiedStereographic = __esm({
  "node_modules/d3-geo-projection/src/modifiedStereographic.js"() {
    init_src2();
    init_math3();
    alaska = [[0.9972523, 0], [52513e-7, -41175e-7], [74606e-7, 48125e-7], [-0.0153783, -0.1968253], [0.0636871, -0.1408027], [0.3660976, -0.2937382]];
    gs48 = [[0.98879, 0], [0, 0], [-0.050909, 0], [0, 0], [0.075528, 0]];
    gs50 = [[0.984299, 0], [0.0211642, 37608e-7], [-0.1036018, -0.0575102], [-0.0329095, -0.0320119], [0.0499471, 0.1223335], [0.026046, 0.0899805], [7388e-7, -0.1435792], [75848e-7, -0.1334108], [-0.0216473, 0.0776645], [-0.0225161, 0.0853673]];
    miller = [[0.9245, 0], [0, 0], [0.01943, 0]];
    lee = [[0.721316, 0], [0, 0], [-881625e-8, -617325e-8]];
  }
});

// node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js
function mtFlatPolarParabolicRaw(lambda, phi2) {
  var theta = asin3(7 * sin3(phi2) / (3 * sqrt6));
  return [
    sqrt6 * lambda * (2 * cos3(2 * theta / 3) - 1) / sqrt7,
    9 * sin3(theta / 3) / sqrt7
  ];
}
function mtFlatPolarParabolic_default() {
  return projection2(mtFlatPolarParabolicRaw).scale(164.859);
}
var sqrt6, sqrt7;
var init_mtFlatPolarParabolic = __esm({
  "node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js"() {
    init_src2();
    init_math3();
    sqrt6 = sqrt3(6);
    sqrt7 = sqrt3(7);
    mtFlatPolarParabolicRaw.invert = function(x4, y4) {
      var theta = 3 * asin3(y4 * sqrt7 / 9);
      return [
        x4 * sqrt7 / (sqrt6 * (2 * cos3(2 * theta / 3) - 1)),
        asin3(sin3(theta) * 3 * sqrt6 / 7)
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js
function mtFlatPolarQuarticRaw(lambda, phi2) {
  var k4 = (1 + sqrt1_2) * sin3(phi2), theta = phi2;
  for (var i2 = 0, delta; i2 < 25; i2++) {
    theta -= delta = (sin3(theta / 2) + sin3(theta) - k4) / (0.5 * cos3(theta / 2) + cos3(theta));
    if (abs3(delta) < epsilon4)
      break;
  }
  return [
    lambda * (1 + 2 * cos3(theta) / cos3(theta / 2)) / (3 * sqrt22),
    2 * sqrt3(3) * sin3(theta / 2) / sqrt3(2 + sqrt22)
  ];
}
function mtFlatPolarQuartic_default() {
  return projection2(mtFlatPolarQuarticRaw).scale(188.209);
}
var init_mtFlatPolarQuartic = __esm({
  "node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js"() {
    init_src2();
    init_math3();
    mtFlatPolarQuarticRaw.invert = function(x4, y4) {
      var sinTheta_2 = y4 * sqrt3(2 + sqrt22) / (2 * sqrt3(3)), theta = 2 * asin3(sinTheta_2);
      return [
        3 * sqrt22 * x4 / (1 + 2 * cos3(theta) / cos3(theta / 2)),
        asin3((sinTheta_2 + sin3(theta)) / (1 + sqrt1_2))
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js
function mtFlatPolarSinusoidalRaw(lambda, phi2) {
  var A6 = sqrt3(6 / (4 + pi3)), k4 = (1 + pi3 / 4) * sin3(phi2), theta = phi2 / 2;
  for (var i2 = 0, delta; i2 < 25; i2++) {
    theta -= delta = (theta / 2 + sin3(theta) - k4) / (0.5 + cos3(theta));
    if (abs3(delta) < epsilon4)
      break;
  }
  return [
    A6 * (0.5 + cos3(theta)) * lambda / 1.5,
    A6 * theta
  ];
}
function mtFlatPolarSinusoidal_default() {
  return projection2(mtFlatPolarSinusoidalRaw).scale(166.518);
}
var init_mtFlatPolarSinusoidal = __esm({
  "node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js"() {
    init_src2();
    init_math3();
    mtFlatPolarSinusoidalRaw.invert = function(x4, y4) {
      var A6 = sqrt3(6 / (4 + pi3)), theta = y4 / A6;
      if (abs3(abs3(theta) - halfPi3) < epsilon4)
        theta = theta < 0 ? -halfPi3 : halfPi3;
      return [
        1.5 * x4 / (A6 * (0.5 + cos3(theta))),
        asin3((theta / 2 + sin3(theta)) / (1 + pi3 / 4))
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/naturalEarth.js
function naturalEarthRaw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
function naturalEarth_default() {
  return projection2(naturalEarthRaw).scale(175.295);
}
var init_naturalEarth = __esm({
  "node_modules/d3-geo-projection/src/naturalEarth.js"() {
    init_src2();
    init_math3();
    naturalEarthRaw.invert = function(x4, y4) {
      var phi2 = y4, i2 = 25, delta;
      do {
        var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
        phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
      } while (abs3(delta) > epsilon4 && --i2 > 0);
      return [
        x4 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
        phi2
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/naturalEarth2.js
function naturalEarth2Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22, phi6 = phi22 * phi4;
  return [
    lambda * (0.84719 - 0.13063 * phi22 + phi6 * phi6 * (-0.04515 + 0.05494 * phi22 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi2 * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi22 - 396e-5 * phi4))
  ];
}
function naturalEarth2_default() {
  return projection2(naturalEarth2Raw).scale(175.295);
}
var init_naturalEarth2 = __esm({
  "node_modules/d3-geo-projection/src/naturalEarth2.js"() {
    init_src2();
    init_math3();
    naturalEarth2Raw.invert = function(x4, y4) {
      var phi2 = y4, i2 = 25, delta, phi22, phi4, phi6;
      do {
        phi22 = phi2 * phi2;
        phi4 = phi22 * phi22;
        phi2 -= delta = (phi2 * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi22 - 396e-5 * phi4)) - y4) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi22 + 13 * -396e-5 * phi4));
      } while (abs3(delta) > epsilon23 && --i2 > 0);
      phi22 = phi2 * phi2;
      phi4 = phi22 * phi22;
      phi6 = phi22 * phi4;
      return [
        x4 / (0.84719 - 0.13063 * phi22 + phi6 * phi6 * (-0.04515 + 0.05494 * phi22 - 0.02326 * phi4 + 331e-5 * phi6)),
        phi2
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/nellHammer.js
function nellHammerRaw(lambda, phi2) {
  return [
    lambda * (1 + cos3(phi2)) / 2,
    2 * (phi2 - tan3(phi2 / 2))
  ];
}
function nellHammer_default() {
  return projection2(nellHammerRaw).scale(152.63);
}
var init_nellHammer = __esm({
  "node_modules/d3-geo-projection/src/nellHammer.js"() {
    init_src2();
    init_math3();
    nellHammerRaw.invert = function(x4, y4) {
      var p2 = y4 / 2;
      for (var i2 = 0, delta = Infinity; i2 < 10 && abs3(delta) > epsilon4; ++i2) {
        var c2 = cos3(y4 / 2);
        y4 -= delta = (y4 - tan3(y4 / 2) - p2) / (1 - 0.5 / (c2 * c2));
      }
      return [
        2 * x4 / (1 + cos3(y4)),
        y4
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/patterson.js
function pattersonRaw(lambda, phi2) {
  var phi22 = phi2 * phi2;
  return [
    lambda,
    phi2 * (pattersonK1 + phi22 * phi22 * (pattersonK2 + phi22 * (pattersonK3 + pattersonK4 * phi22)))
  ];
}
function patterson_default() {
  return projection2(pattersonRaw).scale(139.319);
}
var pattersonK1, pattersonK2, pattersonK3, pattersonK4, pattersonC1, pattersonC2, pattersonC3, pattersonC4, pattersonYmax;
var init_patterson = __esm({
  "node_modules/d3-geo-projection/src/patterson.js"() {
    init_src2();
    init_math3();
    pattersonK1 = 1.0148;
    pattersonK2 = 0.23185;
    pattersonK3 = -0.14499;
    pattersonK4 = 0.02406;
    pattersonC1 = pattersonK1;
    pattersonC2 = 5 * pattersonK2;
    pattersonC3 = 7 * pattersonK3;
    pattersonC4 = 9 * pattersonK4;
    pattersonYmax = 1.790857183;
    pattersonRaw.invert = function(x4, y4) {
      if (y4 > pattersonYmax)
        y4 = pattersonYmax;
      else if (y4 < -pattersonYmax)
        y4 = -pattersonYmax;
      var yc = y4, delta;
      do {
        var y22 = yc * yc;
        yc -= delta = (yc * (pattersonK1 + y22 * y22 * (pattersonK2 + y22 * (pattersonK3 + pattersonK4 * y22))) - y4) / (pattersonC1 + y22 * y22 * (pattersonC2 + y22 * (pattersonC3 + pattersonC4 * y22)));
      } while (abs3(delta) > epsilon4);
      return [x4, yc];
    };
  }
});

// node_modules/d3-geo-projection/src/polyconic.js
function polyconicRaw(lambda, phi2) {
  if (abs3(phi2) < epsilon4)
    return [lambda, 0];
  var tanPhi = tan3(phi2), k4 = lambda * sin3(phi2);
  return [
    sin3(k4) / tanPhi,
    phi2 + (1 - cos3(k4)) / tanPhi
  ];
}
function polyconic_default() {
  return projection2(polyconicRaw).scale(103.74);
}
var init_polyconic = __esm({
  "node_modules/d3-geo-projection/src/polyconic.js"() {
    init_src2();
    init_math3();
    polyconicRaw.invert = function(x4, y4) {
      if (abs3(y4) < epsilon4)
        return [x4, 0];
      var k4 = x4 * x4 + y4 * y4, phi2 = y4 * 0.5, i2 = 10, delta;
      do {
        var tanPhi = tan3(phi2), secPhi = 1 / cos3(phi2), j2 = k4 - 2 * y4 * phi2 + phi2 * phi2;
        phi2 -= delta = (tanPhi * j2 + 2 * (phi2 - y4)) / (2 + j2 * secPhi * secPhi + 2 * (phi2 - y4) * tanPhi);
      } while (abs3(delta) > epsilon4 && --i2 > 0);
      tanPhi = tan3(phi2);
      return [
        (abs3(y4) < abs3(phi2 + 1 / tanPhi) ? asin3(x4 * tanPhi) : sign3(x4) * (acos3(abs3(x4 * tanPhi)) + halfPi3)) / sin3(phi2),
        phi2
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/polyhedral/matrix.js
function matrix_default(a3, b2) {
  var u2 = subtract(a3[1], a3[0]), v2 = subtract(b2[1], b2[0]), phi2 = angle4(u2, v2), s3 = length(u2) / length(v2);
  return multiply([
    1,
    0,
    a3[0][0],
    0,
    1,
    a3[0][1]
  ], multiply([
    s3,
    0,
    0,
    0,
    s3,
    0
  ], multiply([
    cos3(phi2),
    sin3(phi2),
    0,
    -sin3(phi2),
    cos3(phi2),
    0
  ], [
    1,
    0,
    -b2[0][0],
    0,
    1,
    -b2[0][1]
  ])));
}
function inverse(m2) {
  var k4 = 1 / (m2[0] * m2[4] - m2[1] * m2[3]);
  return [
    k4 * m2[4],
    -k4 * m2[1],
    k4 * (m2[1] * m2[5] - m2[2] * m2[4]),
    -k4 * m2[3],
    k4 * m2[0],
    k4 * (m2[2] * m2[3] - m2[0] * m2[5])
  ];
}
function multiply(a3, b2) {
  return [
    a3[0] * b2[0] + a3[1] * b2[3],
    a3[0] * b2[1] + a3[1] * b2[4],
    a3[0] * b2[2] + a3[1] * b2[5] + a3[2],
    a3[3] * b2[0] + a3[4] * b2[3],
    a3[3] * b2[1] + a3[4] * b2[4],
    a3[3] * b2[2] + a3[4] * b2[5] + a3[5]
  ];
}
function subtract(a3, b2) {
  return [a3[0] - b2[0], a3[1] - b2[1]];
}
function length(v2) {
  return sqrt3(v2[0] * v2[0] + v2[1] * v2[1]);
}
function angle4(a3, b2) {
  return atan23(a3[0] * b2[1] - a3[1] * b2[0], a3[0] * b2[0] + a3[1] * b2[1]);
}
var init_matrix = __esm({
  "node_modules/d3-geo-projection/src/polyhedral/matrix.js"() {
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/polyhedral/index.js
function polyhedral_default(root, face, r2) {
  r2 = r2 == null ? -pi3 / 6 : r2;
  recurse(root, { transform: [
    cos3(r2),
    sin3(r2),
    0,
    -sin3(r2),
    cos3(r2),
    0
  ] });
  function recurse(node, parent) {
    node.edges = faceEdges(node.face);
    if (parent.face) {
      var shared = node.shared = sharedEdge(node.face, parent.face), m2 = matrix_default(shared.map(parent.project), shared.map(node.project));
      node.transform = parent.transform ? multiply(parent.transform, m2) : m2;
      var edges2 = parent.edges;
      for (var i2 = 0, n2 = edges2.length; i2 < n2; ++i2) {
        if (pointEqual2(shared[0], edges2[i2][1]) && pointEqual2(shared[1], edges2[i2][0]))
          edges2[i2] = node;
        if (pointEqual2(shared[0], edges2[i2][0]) && pointEqual2(shared[1], edges2[i2][1]))
          edges2[i2] = node;
      }
      edges2 = node.edges;
      for (i2 = 0, n2 = edges2.length; i2 < n2; ++i2) {
        if (pointEqual2(shared[0], edges2[i2][0]) && pointEqual2(shared[1], edges2[i2][1]))
          edges2[i2] = parent;
        if (pointEqual2(shared[0], edges2[i2][1]) && pointEqual2(shared[1], edges2[i2][0]))
          edges2[i2] = parent;
      }
    } else {
      node.transform = parent.transform;
    }
    if (node.children) {
      node.children.forEach(function(child) {
        recurse(child, node);
      });
    }
    return node;
  }
  function forward(lambda, phi2) {
    var node = face(lambda, phi2), point5 = node.project([lambda * degrees3, phi2 * degrees3]), t2;
    if (t2 = node.transform) {
      return [
        t2[0] * point5[0] + t2[1] * point5[1] + t2[2],
        -(t2[3] * point5[0] + t2[4] * point5[1] + t2[5])
      ];
    }
    point5[1] = -point5[1];
    return point5;
  }
  if (hasInverse(root))
    forward.invert = function(x4, y4) {
      var coordinates2 = faceInvert(root, [x4, -y4]);
      return coordinates2 && (coordinates2[0] *= radians3, coordinates2[1] *= radians3, coordinates2);
    };
  function faceInvert(node, coordinates2) {
    var invert = node.project.invert, t2 = node.transform, point5 = coordinates2;
    if (t2) {
      t2 = inverse(t2);
      point5 = [
        t2[0] * point5[0] + t2[1] * point5[1] + t2[2],
        t2[3] * point5[0] + t2[4] * point5[1] + t2[5]
      ];
    }
    if (invert && node === faceDegrees(p2 = invert(point5)))
      return p2;
    var p2, children = node.children;
    for (var i2 = 0, n2 = children && children.length; i2 < n2; ++i2) {
      if (p2 = faceInvert(children[i2], coordinates2))
        return p2;
    }
  }
  function faceDegrees(coordinates2) {
    return face(coordinates2[0] * radians3, coordinates2[1] * radians3);
  }
  var proj = projection2(forward), stream_ = proj.stream;
  proj.stream = function(stream) {
    var rotate = proj.rotate(), rotateStream = stream_(stream), sphereStream = (proj.rotate([0, 0]), stream_(stream));
    proj.rotate(rotate);
    rotateStream.sphere = function() {
      sphereStream.polygonStart();
      sphereStream.lineStart();
      outline(sphereStream, root);
      sphereStream.lineEnd();
      sphereStream.polygonEnd();
    };
    return rotateStream;
  };
  return proj;
}
function outline(stream, node, parent) {
  var point5, edges2 = node.edges, n2 = edges2.length, edge, multiPoint = { type: "MultiPoint", coordinates: node.face }, notPoles = node.face.filter(function(d2) {
    return abs3(d2[1]) !== 90;
  }), b2 = bounds_default3({ type: "MultiPoint", coordinates: notPoles }), inside = false, j2 = -1, dx = b2[1][0] - b2[0][0];
  var c2 = dx === 180 || dx === 360 ? [(b2[0][0] + b2[1][0]) / 2, (b2[0][1] + b2[1][1]) / 2] : centroid_default3(multiPoint);
  if (parent)
    while (++j2 < n2) {
      if (edges2[j2] === parent)
        break;
    }
  ++j2;
  for (var i2 = 0; i2 < n2; ++i2) {
    edge = edges2[(i2 + j2) % n2];
    if (Array.isArray(edge)) {
      if (!inside) {
        stream.point((point5 = interpolate_default2(edge[0], c2)(epsilon4))[0], point5[1]);
        inside = true;
      }
      stream.point((point5 = interpolate_default2(edge[1], c2)(epsilon4))[0], point5[1]);
    } else {
      inside = false;
      if (edge !== parent)
        outline(stream, edge, node);
    }
  }
}
function pointEqual2(a3, b2) {
  return a3 && b2 && a3[0] === b2[0] && a3[1] === b2[1];
}
function sharedEdge(a3, b2) {
  var x4, y4, n2 = a3.length, found = null;
  for (var i2 = 0; i2 < n2; ++i2) {
    x4 = a3[i2];
    for (var j2 = b2.length; --j2 >= 0; ) {
      y4 = b2[j2];
      if (x4[0] === y4[0] && x4[1] === y4[1]) {
        if (found)
          return [found, x4];
        found = x4;
      }
    }
  }
}
function faceEdges(face) {
  var n2 = face.length, edges2 = [];
  for (var a3 = face[n2 - 1], i2 = 0; i2 < n2; ++i2)
    edges2.push([a3, a3 = face[i2]]);
  return edges2;
}
function hasInverse(node) {
  return node.project.invert || node.children && node.children.some(hasInverse);
}
var init_polyhedral = __esm({
  "node_modules/d3-geo-projection/src/polyhedral/index.js"() {
    init_src2();
    init_math3();
    init_matrix();
  }
});

// node_modules/d3-geo-projection/src/polyhedral/octahedron.js
var octahedron, octahedron_default;
var init_octahedron = __esm({
  "node_modules/d3-geo-projection/src/polyhedral/octahedron.js"() {
    octahedron = [
      [0, 90],
      [-90, 0],
      [0, 0],
      [90, 0],
      [180, 0],
      [0, -90]
    ];
    octahedron_default = [
      [0, 2, 1],
      [0, 3, 2],
      [5, 1, 2],
      [5, 2, 3],
      [0, 1, 4],
      [0, 4, 3],
      [5, 4, 1],
      [5, 3, 4]
    ].map(function(face) {
      return face.map(function(i2) {
        return octahedron[i2];
      });
    });
  }
});

// node_modules/d3-geo-projection/src/polyhedral/butterfly.js
function butterfly_default(faceProjection) {
  faceProjection = faceProjection || function(face) {
    var c2 = centroid_default3({ type: "MultiPoint", coordinates: face });
    return gnomonic_default2().scale(1).translate([0, 0]).rotate([-c2[0], -c2[1]]);
  };
  var faces = octahedron_default.map(function(face) {
    return { face, project: faceProjection(face) };
  });
  [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function(d2, i2) {
    var node = faces[d2];
    node && (node.children || (node.children = [])).push(faces[i2]);
  });
  return polyhedral_default(faces[0], function(lambda, phi2) {
    return faces[lambda < -pi3 / 2 ? phi2 < 0 ? 6 : 4 : lambda < 0 ? phi2 < 0 ? 2 : 0 : lambda < pi3 / 2 ? phi2 < 0 ? 3 : 1 : phi2 < 0 ? 7 : 5];
  }).scale(101.858).center([0, 45]);
}
var init_butterfly = __esm({
  "node_modules/d3-geo-projection/src/polyhedral/butterfly.js"() {
    init_src2();
    init_math3();
    init_polyhedral();
    init_octahedron();
  }
});

// node_modules/d3-geo-projection/src/polyhedral/collignon.js
function collignonK(a3, b2) {
  var p2 = collignonRaw(a3, b2);
  return [p2[0] * kx, p2[1]];
}
function collignon_default2(faceProjection) {
  faceProjection = faceProjection || function(face) {
    var c2 = centroid_default3({ type: "MultiPoint", coordinates: face });
    return projection2(collignonK).translate([0, 0]).scale(1).rotate(c2[1] > 0 ? [-c2[0], 0] : [180 - c2[0], 180]);
  };
  var faces = octahedron_default.map(function(face) {
    return { face, project: faceProjection(face) };
  });
  [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function(d2, i2) {
    var node = faces[d2];
    node && (node.children || (node.children = [])).push(faces[i2]);
  });
  return polyhedral_default(faces[0], function(lambda, phi2) {
    return faces[lambda < -pi3 / 2 ? phi2 < 0 ? 6 : 4 : lambda < 0 ? phi2 < 0 ? 2 : 0 : lambda < pi3 / 2 ? phi2 < 0 ? 3 : 1 : phi2 < 0 ? 7 : 5];
  }).scale(121.906).center([0, 48.5904]);
}
var kx;
var init_collignon2 = __esm({
  "node_modules/d3-geo-projection/src/polyhedral/collignon.js"() {
    init_src2();
    init_collignon();
    init_math3();
    init_polyhedral();
    init_octahedron();
    kx = 2 / sqrt3(3);
    collignonK.invert = function(x4, y4) {
      return collignonRaw.invert(x4 / kx, y4);
    };
  }
});

// node_modules/d3-geo-projection/src/polyhedral/waterman.js
function waterman_default(faceProjection) {
  faceProjection = faceProjection || function(face2) {
    var c2 = face2.length === 6 ? centroid_default3({ type: "MultiPoint", coordinates: face2 }) : face2[0];
    return gnomonic_default2().scale(1).translate([0, 0]).rotate([-c2[0], -c2[1]]);
  };
  var w5 = octahedron_default.map(function(face2) {
    var xyz = face2.map(cartesian3), n2 = xyz.length, a3 = xyz[n2 - 1], b2, hexagon = [];
    for (var i2 = 0; i2 < n2; ++i2) {
      b2 = xyz[i2];
      hexagon.push(spherical3([
        a3[0] * 0.9486832980505138 + b2[0] * 0.31622776601683794,
        a3[1] * 0.9486832980505138 + b2[1] * 0.31622776601683794,
        a3[2] * 0.9486832980505138 + b2[2] * 0.31622776601683794
      ]), spherical3([
        b2[0] * 0.9486832980505138 + a3[0] * 0.31622776601683794,
        b2[1] * 0.9486832980505138 + a3[1] * 0.31622776601683794,
        b2[2] * 0.9486832980505138 + a3[2] * 0.31622776601683794
      ]));
      a3 = b2;
    }
    return hexagon;
  });
  var cornerNormals = [];
  var parents = [-1, 0, 0, 1, 0, 1, 4, 5];
  w5.forEach(function(hexagon, j2) {
    var face2 = octahedron_default[j2], n2 = face2.length, normals = cornerNormals[j2] = [];
    for (var i2 = 0; i2 < n2; ++i2) {
      w5.push([
        face2[i2],
        hexagon[(i2 * 2 + 2) % (2 * n2)],
        hexagon[(i2 * 2 + 1) % (2 * n2)]
      ]);
      parents.push(j2);
      normals.push(cross(cartesian3(hexagon[(i2 * 2 + 2) % (2 * n2)]), cartesian3(hexagon[(i2 * 2 + 1) % (2 * n2)])));
    }
  });
  var faces = w5.map(function(face2) {
    return {
      project: faceProjection(face2),
      face: face2
    };
  });
  parents.forEach(function(d2, i2) {
    var parent = faces[d2];
    parent && (parent.children || (parent.children = [])).push(faces[i2]);
  });
  function face(lambda, phi2) {
    var cosphi = cos3(phi2), p2 = [cosphi * cos3(lambda), cosphi * sin3(lambda), sin3(phi2)];
    var hexagon = lambda < -pi3 / 2 ? phi2 < 0 ? 6 : 4 : lambda < 0 ? phi2 < 0 ? 2 : 0 : lambda < pi3 / 2 ? phi2 < 0 ? 3 : 1 : phi2 < 0 ? 7 : 5;
    var n2 = cornerNormals[hexagon];
    return faces[dot(n2[0], p2) < 0 ? 8 + 3 * hexagon : dot(n2[1], p2) < 0 ? 8 + 3 * hexagon + 1 : dot(n2[2], p2) < 0 ? 8 + 3 * hexagon + 2 : hexagon];
  }
  return polyhedral_default(faces[0], face).scale(110.625).center([0, 45]);
}
function dot(a3, b2) {
  for (var i2 = 0, n2 = a3.length, s3 = 0; i2 < n2; ++i2)
    s3 += a3[i2] * b2[i2];
  return s3;
}
function cross(a3, b2) {
  return [
    a3[1] * b2[2] - a3[2] * b2[1],
    a3[2] * b2[0] - a3[0] * b2[2],
    a3[0] * b2[1] - a3[1] * b2[0]
  ];
}
function spherical3(cartesian5) {
  return [
    atan23(cartesian5[1], cartesian5[0]) * degrees3,
    asin3(max(-1, min(1, cartesian5[2]))) * degrees3
  ];
}
function cartesian3(coordinates2) {
  var lambda = coordinates2[0] * radians3, phi2 = coordinates2[1] * radians3, cosphi = cos3(phi2);
  return [
    cosphi * cos3(lambda),
    cosphi * sin3(lambda),
    sin3(phi2)
  ];
}
var init_waterman = __esm({
  "node_modules/d3-geo-projection/src/polyhedral/waterman.js"() {
    init_src2();
    init_math3();
    init_polyhedral();
    init_octahedron();
  }
});

// node_modules/d3-geo-projection/src/noop.js
function noop_default() {
}
var init_noop3 = __esm({
  "node_modules/d3-geo-projection/src/noop.js"() {
  }
});

// node_modules/d3-geo-projection/src/project/clockwise.js
function clockwise_default(ring) {
  if ((n2 = ring.length) < 4)
    return false;
  var i2 = 0, n2, area = ring[n2 - 1][1] * ring[0][0] - ring[n2 - 1][0] * ring[0][1];
  while (++i2 < n2)
    area += ring[i2 - 1][1] * ring[i2][0] - ring[i2 - 1][0] * ring[i2][1];
  return area <= 0;
}
var init_clockwise = __esm({
  "node_modules/d3-geo-projection/src/project/clockwise.js"() {
  }
});

// node_modules/d3-geo-projection/src/project/contains.js
function contains_default3(ring, point5) {
  var x4 = point5[0], y4 = point5[1], contains = false;
  for (var i2 = 0, n2 = ring.length, j2 = n2 - 1; i2 < n2; j2 = i2++) {
    var pi8 = ring[i2], xi = pi8[0], yi = pi8[1], pj = ring[j2], xj = pj[0], yj = pj[1];
    if (yi > y4 ^ yj > y4 && x4 < (xj - xi) * (y4 - yi) / (yj - yi) + xi)
      contains = !contains;
  }
  return contains;
}
var init_contains3 = __esm({
  "node_modules/d3-geo-projection/src/project/contains.js"() {
  }
});

// node_modules/d3-geo-projection/src/project/index.js
function project_default(object3, projection4) {
  var stream = projection4.stream, project;
  if (!stream)
    throw new Error("invalid projection");
  switch (object3 && object3.type) {
    case "Feature":
      project = projectFeature;
      break;
    case "FeatureCollection":
      project = projectFeatureCollection;
      break;
    default:
      project = projectGeometry;
      break;
  }
  return project(object3, stream);
}
function projectFeatureCollection(o2, stream) {
  return {
    type: "FeatureCollection",
    features: o2.features.map(function(f2) {
      return projectFeature(f2, stream);
    })
  };
}
function projectFeature(o2, stream) {
  return {
    type: "Feature",
    id: o2.id,
    properties: o2.properties,
    geometry: projectGeometry(o2.geometry, stream)
  };
}
function projectGeometryCollection(o2, stream) {
  return {
    type: "GeometryCollection",
    geometries: o2.geometries.map(function(o3) {
      return projectGeometry(o3, stream);
    })
  };
}
function projectGeometry(o2, stream) {
  if (!o2)
    return null;
  if (o2.type === "GeometryCollection")
    return projectGeometryCollection(o2, stream);
  var sink;
  switch (o2.type) {
    case "Point":
      sink = sinkPoint;
      break;
    case "MultiPoint":
      sink = sinkPoint;
      break;
    case "LineString":
      sink = sinkLine;
      break;
    case "MultiLineString":
      sink = sinkLine;
      break;
    case "Polygon":
      sink = sinkPolygon;
      break;
    case "MultiPolygon":
      sink = sinkPolygon;
      break;
    case "Sphere":
      sink = sinkPolygon;
      break;
    default:
      return null;
  }
  stream_default2(o2, stream(sink));
  return sink.result();
}
var points, lines, sinkPoint, sinkLine, sinkPolygon;
var init_project = __esm({
  "node_modules/d3-geo-projection/src/project/index.js"() {
    init_src2();
    init_noop3();
    init_clockwise();
    init_contains3();
    points = [];
    lines = [];
    sinkPoint = {
      point: function(x4, y4) {
        points.push([x4, y4]);
      },
      result: function() {
        var result = !points.length ? null : points.length < 2 ? { type: "Point", coordinates: points[0] } : { type: "MultiPoint", coordinates: points };
        points = [];
        return result;
      }
    };
    sinkLine = {
      lineStart: noop_default,
      point: function(x4, y4) {
        points.push([x4, y4]);
      },
      lineEnd: function() {
        if (points.length)
          lines.push(points), points = [];
      },
      result: function() {
        var result = !lines.length ? null : lines.length < 2 ? { type: "LineString", coordinates: lines[0] } : { type: "MultiLineString", coordinates: lines };
        lines = [];
        return result;
      }
    };
    sinkPolygon = {
      polygonStart: noop_default,
      lineStart: noop_default,
      point: function(x4, y4) {
        points.push([x4, y4]);
      },
      lineEnd: function() {
        var n2 = points.length;
        if (n2) {
          do
            points.push(points[0].slice());
          while (++n2 < 4);
          lines.push(points), points = [];
        }
      },
      polygonEnd: noop_default,
      result: function() {
        if (!lines.length)
          return null;
        var polygons = [], holes = [];
        lines.forEach(function(ring) {
          if (clockwise_default(ring))
            polygons.push([ring]);
          else
            holes.push(ring);
        });
        holes.forEach(function(hole) {
          var point5 = hole[0];
          polygons.some(function(polygon) {
            if (contains_default3(polygon[0], point5)) {
              polygon.push(hole);
              return true;
            }
          }) || polygons.push([hole]);
        });
        lines = [];
        return !polygons.length ? null : polygons.length > 1 ? { type: "MultiPolygon", coordinates: polygons } : { type: "Polygon", coordinates: polygons[0] };
      }
    };
  }
});

// node_modules/d3-geo-projection/src/quincuncial/index.js
function quincuncial_default(project) {
  var dx = project(halfPi3, 0)[0] - project(-halfPi3, 0)[0];
  function projectQuincuncial(lambda, phi2) {
    var t2 = abs3(lambda) < halfPi3, p2 = project(t2 ? lambda : lambda > 0 ? lambda - pi3 : lambda + pi3, phi2), x4 = (p2[0] - p2[1]) * sqrt1_2, y4 = (p2[0] + p2[1]) * sqrt1_2;
    if (t2)
      return [x4, y4];
    var d2 = dx * sqrt1_2, s3 = x4 > 0 ^ y4 > 0 ? -1 : 1;
    return [s3 * x4 - sign3(y4) * d2, s3 * y4 - sign3(x4) * d2];
  }
  if (project.invert)
    projectQuincuncial.invert = function(x011, y011) {
      var x4 = (x011 + y011) * sqrt1_2, y4 = (y011 - x011) * sqrt1_2, t2 = abs3(x4) < 0.5 * dx && abs3(y4) < 0.5 * dx;
      if (!t2) {
        var d2 = dx * sqrt1_2, s3 = x4 > 0 ^ y4 > 0 ? -1 : 1, x16 = -s3 * x011 + (y4 > 0 ? 1 : -1) * d2, y16 = -s3 * y011 + (x4 > 0 ? 1 : -1) * d2;
        x4 = (-x16 - y16) * sqrt1_2;
        y4 = (x16 - y16) * sqrt1_2;
      }
      var p2 = project.invert(x4, y4);
      if (!t2)
        p2[0] += x4 > 0 ? pi3 : -pi3;
      return p2;
    };
  return projection2(projectQuincuncial).rotate([-90, -90, 45]).clipAngle(180 - 1e-3);
}
var init_quincuncial = __esm({
  "node_modules/d3-geo-projection/src/quincuncial/index.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/quincuncial/gringorten.js
function gringorten_default2() {
  return quincuncial_default(gringortenRaw).scale(176.423);
}
var init_gringorten2 = __esm({
  "node_modules/d3-geo-projection/src/quincuncial/gringorten.js"() {
    init_gringorten();
    init_quincuncial();
  }
});

// node_modules/d3-geo-projection/src/quincuncial/peirce.js
function peirce_default() {
  return quincuncial_default(guyouRaw).scale(111.48);
}
var init_peirce = __esm({
  "node_modules/d3-geo-projection/src/quincuncial/peirce.js"() {
    init_guyou();
    init_quincuncial();
  }
});

// node_modules/d3-geo-projection/src/quantize.js
function quantize_default(input, digits) {
  if (!(0 <= (digits = +digits) && digits <= 20))
    throw new Error("invalid digits");
  function quantizePoint(input2) {
    var n2 = input2.length, i2 = 2, output2 = new Array(n2);
    output2[0] = +input2[0].toFixed(digits);
    output2[1] = +input2[1].toFixed(digits);
    while (i2 < n2)
      output2[i2] = input2[i2], ++i2;
    return output2;
  }
  function quantizePoints(input2) {
    return input2.map(quantizePoint);
  }
  function quantizePolygon(input2) {
    return input2.map(quantizePoints);
  }
  function quantizeGeometry(input2) {
    if (input2 == null)
      return input2;
    var output2;
    switch (input2.type) {
      case "GeometryCollection":
        output2 = { type: "GeometryCollection", geometries: input2.geometries.map(quantizeGeometry) };
        break;
      case "Point":
        output2 = { type: "Point", coordinates: quantizePoint(input2.coordinates) };
        break;
      case "MultiPoint":
      case "LineString":
        output2 = { type: input2.type, coordinates: quantizePoints(input2.coordinates) };
        break;
      case "MultiLineString":
      case "Polygon":
        output2 = { type: input2.type, coordinates: quantizePolygon(input2.coordinates) };
        break;
      case "MultiPolygon":
        output2 = { type: "MultiPolygon", coordinates: input2.coordinates.map(quantizePolygon) };
        break;
      default:
        return input2;
    }
    if (input2.bbox != null)
      output2.bbox = input2.bbox;
    return output2;
  }
  function quantizeFeature(input2) {
    var output2 = { type: "Feature", properties: input2.properties, geometry: quantizeGeometry(input2.geometry) };
    if (input2.id != null)
      output2.id = input2.id;
    if (input2.bbox != null)
      output2.bbox = input2.bbox;
    return output2;
  }
  if (input != null)
    switch (input.type) {
      case "Feature":
        return quantizeFeature(input);
      case "FeatureCollection": {
        var output = { type: "FeatureCollection", features: input.features.map(quantizeFeature) };
        if (input.bbox != null)
          output.bbox = input.bbox;
        return output;
      }
      default:
        return quantizeGeometry(input);
    }
  return input;
}
var init_quantize = __esm({
  "node_modules/d3-geo-projection/src/quantize.js"() {
  }
});

// node_modules/d3-geo-projection/src/rectangularPolyconic.js
function rectangularPolyconicRaw(phi04) {
  var sinPhi04 = sin3(phi04);
  function forward(lambda, phi2) {
    var A6 = sinPhi04 ? tan3(lambda * sinPhi04 / 2) / sinPhi04 : lambda / 2;
    if (!phi2)
      return [2 * A6, -phi04];
    var E2 = 2 * atan4(A6 * sin3(phi2)), cotPhi = 1 / tan3(phi2);
    return [
      sin3(E2) * cotPhi,
      phi2 + (1 - cos3(E2)) * cotPhi - phi04
    ];
  }
  forward.invert = function(x4, y4) {
    if (abs3(y4 += phi04) < epsilon4)
      return [sinPhi04 ? 2 * atan4(sinPhi04 * x4 / 2) / sinPhi04 : x4, 0];
    var k4 = x4 * x4 + y4 * y4, phi2 = 0, i2 = 10, delta;
    do {
      var tanPhi = tan3(phi2), secPhi = 1 / cos3(phi2), j2 = k4 - 2 * y4 * phi2 + phi2 * phi2;
      phi2 -= delta = (tanPhi * j2 + 2 * (phi2 - y4)) / (2 + j2 * secPhi * secPhi + 2 * (phi2 - y4) * tanPhi);
    } while (abs3(delta) > epsilon4 && --i2 > 0);
    var E2 = x4 * (tanPhi = tan3(phi2)), A6 = tan3(abs3(y4) < abs3(phi2 + 1 / tanPhi) ? asin3(E2) * 0.5 : acos3(E2) * 0.5 + pi3 / 4) / sin3(phi2);
    return [
      sinPhi04 ? 2 * atan4(sinPhi04 * A6) / sinPhi04 : 2 * A6,
      phi2
    ];
  };
  return forward;
}
function rectangularPolyconic_default() {
  return parallel1_default(rectangularPolyconicRaw).scale(131.215);
}
var init_rectangularPolyconic = __esm({
  "node_modules/d3-geo-projection/src/rectangularPolyconic.js"() {
    init_math3();
    init_parallel1();
  }
});

// node_modules/d3-geo-projection/src/robinson.js
function robinsonRaw(lambda, phi2) {
  var i2 = min(18, abs3(phi2) * 36 / pi3), i0 = floor(i2), di = i2 - i0, ax = (k4 = K[i0])[0], ay = k4[1], bx = (k4 = K[++i0])[0], by = k4[1], cx = (k4 = K[min(19, ++i0)])[0], cy = k4[1], k4;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    (phi2 > 0 ? halfPi3 : -halfPi3) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}
function robinson_default() {
  return projection2(robinsonRaw).scale(152.63);
}
var K;
var init_robinson = __esm({
  "node_modules/d3-geo-projection/src/robinson.js"() {
    init_src2();
    init_math3();
    K = [
      [0.9986, -0.062],
      [1, 0],
      [0.9986, 0.062],
      [0.9954, 0.124],
      [0.99, 0.186],
      [0.9822, 0.248],
      [0.973, 0.31],
      [0.96, 0.372],
      [0.9427, 0.434],
      [0.9216, 0.4958],
      [0.8962, 0.5571],
      [0.8679, 0.6176],
      [0.835, 0.6769],
      [0.7986, 0.7346],
      [0.7597, 0.7903],
      [0.7186, 0.8435],
      [0.6732, 0.8936],
      [0.6213, 0.9394],
      [0.5722, 0.9761],
      [0.5322, 1]
    ];
    K.forEach(function(d2) {
      d2[1] *= 1.0144;
    });
    robinsonRaw.invert = function(x4, y4) {
      var yy = y4 / halfPi3, phi2 = yy * 90, i2 = min(18, abs3(phi2 / 5)), i0 = max(0, floor(i2));
      do {
        var ay = K[i0][1], by = K[i0 + 1][1], cy = K[min(19, i0 + 2)][1], u2 = cy - ay, v2 = cy - 2 * by + ay, t2 = 2 * (abs3(yy) - by) / u2, c2 = v2 / u2, di = t2 * (1 - c2 * t2 * (1 - 2 * c2 * t2));
        if (di >= 0 || i0 === 1) {
          phi2 = (y4 >= 0 ? 5 : -5) * (di + i2);
          var j2 = 50, delta;
          do {
            i2 = min(18, abs3(phi2) / 5);
            i0 = floor(i2);
            di = i2 - i0;
            ay = K[i0][1];
            by = K[i0 + 1][1];
            cy = K[min(19, i0 + 2)][1];
            phi2 -= (delta = (y4 >= 0 ? halfPi3 : -halfPi3) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y4) * degrees3;
          } while (abs3(delta) > epsilon23 && --j2 > 0);
          break;
        }
      } while (--i0 >= 0);
      var ax = K[i0][0], bx = K[i0 + 1][0], cx = K[min(19, i0 + 2)][0];
      return [
        x4 / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
        phi2 * radians3
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/satellite.js
function satelliteVerticalRaw(P2) {
  function forward(lambda, phi2) {
    var cosPhi = cos3(phi2), k4 = (P2 - 1) / (P2 - cosPhi * cos3(lambda));
    return [
      k4 * cosPhi * sin3(lambda),
      k4 * sin3(phi2)
    ];
  }
  forward.invert = function(x4, y4) {
    var rho2 = x4 * x4 + y4 * y4, rho = sqrt3(rho2), sinc = (P2 - sqrt3(1 - rho2 * (P2 + 1) / (P2 - 1))) / ((P2 - 1) / rho + rho / (P2 - 1));
    return [
      atan23(x4 * sinc, rho * sqrt3(1 - sinc * sinc)),
      rho ? asin3(y4 * sinc / rho) : 0
    ];
  };
  return forward;
}
function satelliteRaw(P2, omega) {
  var vertical = satelliteVerticalRaw(P2);
  if (!omega)
    return vertical;
  var cosOmega = cos3(omega), sinOmega = sin3(omega);
  function forward(lambda, phi2) {
    var coordinates2 = vertical(lambda, phi2), y4 = coordinates2[1], A6 = y4 * sinOmega / (P2 - 1) + cosOmega;
    return [
      coordinates2[0] * cosOmega / A6,
      y4 / A6
    ];
  }
  forward.invert = function(x4, y4) {
    var k4 = (P2 - 1) / (P2 - 1 - y4 * sinOmega);
    return vertical.invert(k4 * x4, k4 * y4 * cosOmega);
  };
  return forward;
}
function satellite_default() {
  var distance2 = 2, omega = 0, m2 = projectionMutator2(satelliteRaw), p2 = m2(distance2, omega);
  p2.distance = function(_2) {
    if (!arguments.length)
      return distance2;
    return m2(distance2 = +_2, omega);
  };
  p2.tilt = function(_2) {
    if (!arguments.length)
      return omega * degrees3;
    return m2(distance2, omega = _2 * radians3);
  };
  return p2.scale(432.147).clipAngle(acos3(1 / distance2) * degrees3 - 1e-6);
}
var init_satellite = __esm({
  "node_modules/d3-geo-projection/src/satellite.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/stitch.js
function nonempty(coordinates2) {
  return coordinates2.length > 0;
}
function quantize(x4) {
  return Math.floor(x4 * epsilonInverse) / epsilonInverse;
}
function normalizePoint(y4) {
  return y4 === y08 || y4 === y13 ? [0, y4] : [x08, quantize(y4)];
}
function clampPoint(p2) {
  var x4 = p2[0], y4 = p2[1], clamped = false;
  if (x4 <= x0e)
    x4 = x08, clamped = true;
  else if (x4 >= x1e)
    x4 = x13, clamped = true;
  if (y4 <= y0e)
    y4 = y08, clamped = true;
  else if (y4 >= y1e)
    y4 = y13, clamped = true;
  return clamped ? [x4, y4] : p2;
}
function clampPoints(points2) {
  return points2.map(clampPoint);
}
function extractFragments(rings, polygon, fragments) {
  for (var j2 = 0, m2 = rings.length; j2 < m2; ++j2) {
    var ring = rings[j2].slice();
    fragments.push({ index: -1, polygon, ring });
    for (var i2 = 0, n2 = ring.length; i2 < n2; ++i2) {
      var point5 = ring[i2], x4 = point5[0], y4 = point5[1];
      if (x4 <= x0e || x4 >= x1e || y4 <= y0e || y4 >= y1e) {
        ring[i2] = clampPoint(point5);
        for (var k4 = i2 + 1; k4 < n2; ++k4) {
          var pointk = ring[k4], xk = pointk[0], yk = pointk[1];
          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e)
            break;
        }
        if (k4 === i2 + 1)
          continue;
        if (i2) {
          var fragmentBefore = { index: -1, polygon, ring: ring.slice(0, i2 + 1) };
          fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y4);
          fragments[fragments.length - 1] = fragmentBefore;
        } else
          fragments.pop();
        if (k4 >= n2)
          break;
        fragments.push({ index: -1, polygon, ring: ring = ring.slice(k4 - 1) });
        ring[0] = normalizePoint(ring[0][1]);
        i2 = -1;
        n2 = ring.length;
      }
    }
  }
}
function stitchFragments(fragments) {
  var i2, n2 = fragments.length;
  var fragmentByStart = {}, fragmentByEnd = {}, fragment, start, startFragment, end, endFragment;
  for (i2 = 0; i2 < n2; ++i2) {
    fragment = fragments[i2];
    start = fragment.ring[0];
    end = fragment.ring[fragment.ring.length - 1];
    if (start[0] === end[0] && start[1] === end[1]) {
      fragment.polygon.push(fragment.ring);
      fragments[i2] = null;
      continue;
    }
    fragment.index = i2;
    fragmentByStart[start] = fragmentByEnd[end] = fragment;
  }
  for (i2 = 0; i2 < n2; ++i2) {
    fragment = fragments[i2];
    if (fragment) {
      start = fragment.ring[0];
      end = fragment.ring[fragment.ring.length - 1];
      startFragment = fragmentByEnd[start];
      endFragment = fragmentByStart[end];
      delete fragmentByStart[start];
      delete fragmentByEnd[end];
      if (start[0] === end[0] && start[1] === end[1]) {
        fragment.polygon.push(fragment.ring);
        continue;
      }
      if (startFragment) {
        delete fragmentByEnd[start];
        delete fragmentByStart[startFragment.ring[0]];
        startFragment.ring.pop();
        fragments[startFragment.index] = null;
        fragment = { index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring) };
        if (startFragment === endFragment) {
          fragment.polygon.push(fragment.ring);
        } else {
          fragment.index = n2++;
          fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);
        }
      } else if (endFragment) {
        delete fragmentByStart[end];
        delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];
        fragment.ring.pop();
        fragment = { index: n2++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring) };
        fragments[endFragment.index] = null;
        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);
      } else {
        fragment.ring.push(fragment.ring[0]);
        fragment.polygon.push(fragment.ring);
      }
    }
  }
}
function stitchFeature(input) {
  var output = { type: "Feature", geometry: stitchGeometry(input.geometry) };
  if (input.id != null)
    output.id = input.id;
  if (input.bbox != null)
    output.bbox = input.bbox;
  if (input.properties != null)
    output.properties = input.properties;
  return output;
}
function stitchGeometry(input) {
  if (input == null)
    return input;
  var output, fragments, i2, n2;
  switch (input.type) {
    case "GeometryCollection":
      output = { type: "GeometryCollection", geometries: input.geometries.map(stitchGeometry) };
      break;
    case "Point":
      output = { type: "Point", coordinates: clampPoint(input.coordinates) };
      break;
    case "MultiPoint":
    case "LineString":
      output = { type: input.type, coordinates: clampPoints(input.coordinates) };
      break;
    case "MultiLineString":
      output = { type: "MultiLineString", coordinates: input.coordinates.map(clampPoints) };
      break;
    case "Polygon": {
      var polygon = [];
      extractFragments(input.coordinates, polygon, fragments = []);
      stitchFragments(fragments);
      output = { type: "Polygon", coordinates: polygon };
      break;
    }
    case "MultiPolygon": {
      fragments = [], i2 = -1, n2 = input.coordinates.length;
      var polygons = new Array(n2);
      while (++i2 < n2)
        extractFragments(input.coordinates[i2], polygons[i2] = [], fragments);
      stitchFragments(fragments);
      output = { type: "MultiPolygon", coordinates: polygons.filter(nonempty) };
      break;
    }
    default:
      return input;
  }
  if (input.bbox != null)
    output.bbox = input.bbox;
  return output;
}
function stitch_default(input) {
  if (input == null)
    return input;
  switch (input.type) {
    case "Feature":
      return stitchFeature(input);
    case "FeatureCollection": {
      var output = { type: "FeatureCollection", features: input.features.map(stitchFeature) };
      if (input.bbox != null)
        output.bbox = input.bbox;
      return output;
    }
    default:
      return stitchGeometry(input);
  }
}
var epsilon5, epsilonInverse, x08, x0e, x13, x1e, y08, y0e, y13, y1e;
var init_stitch = __esm({
  "node_modules/d3-geo-projection/src/stitch.js"() {
    epsilon5 = 1e-4;
    epsilonInverse = 1e4;
    x08 = -180;
    x0e = x08 + epsilon5;
    x13 = 180;
    x1e = x13 - epsilon5;
    y08 = -90;
    y0e = y08 + epsilon5;
    y13 = 90;
    y1e = y13 - epsilon5;
  }
});

// node_modules/d3-geo-projection/src/times.js
function timesRaw(lambda, phi2) {
  var t2 = tan3(phi2 / 2), s3 = sin3(quarterPi3 * t2);
  return [
    lambda * (0.74482 - 0.34588 * s3 * s3),
    1.70711 * t2
  ];
}
function times_default() {
  return projection2(timesRaw).scale(146.153);
}
var init_times = __esm({
  "node_modules/d3-geo-projection/src/times.js"() {
    init_src2();
    init_math3();
    timesRaw.invert = function(x4, y4) {
      var t2 = y4 / 1.70711, s3 = sin3(quarterPi3 * t2);
      return [
        x4 / (0.74482 - 0.34588 * s3 * s3),
        2 * atan4(t2)
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/twoPoint.js
function twoPoint_default(raw, p03, p1) {
  var i2 = interpolate_default2(p03, p1), o2 = i2(0.5), a3 = rotation_default2([-o2[0], -o2[1]])(p03), b2 = i2.distance / 2, y4 = -asin3(sin3(a3[1] * radians3) / sin3(b2)), R2 = [-o2[0], -o2[1], -(a3[0] > 0 ? pi3 - y4 : y4) * degrees3], p2 = projection2(raw(b2)).rotate(R2), r2 = rotation_default2(R2), center2 = p2.center;
  delete p2.rotate;
  p2.center = function(_2) {
    return arguments.length ? center2(r2(_2)) : r2.invert(center2());
  };
  return p2.clipAngle(90);
}
var init_twoPoint = __esm({
  "node_modules/d3-geo-projection/src/twoPoint.js"() {
    init_src2();
    init_math3();
  }
});

// node_modules/d3-geo-projection/src/twoPointAzimuthal.js
function twoPointAzimuthalRaw(d2) {
  var cosd = cos3(d2);
  function forward(lambda, phi2) {
    var coordinates2 = gnomonicRaw2(lambda, phi2);
    coordinates2[0] *= cosd;
    return coordinates2;
  }
  forward.invert = function(x4, y4) {
    return gnomonicRaw2.invert(x4 / cosd, y4);
  };
  return forward;
}
function twoPointAzimuthalUsa() {
  return twoPointAzimuthal([-158, 21.5], [-77, 39]).clipAngle(60).scale(400);
}
function twoPointAzimuthal(p03, p1) {
  return twoPoint_default(twoPointAzimuthalRaw, p03, p1);
}
var init_twoPointAzimuthal = __esm({
  "node_modules/d3-geo-projection/src/twoPointAzimuthal.js"() {
    init_src2();
    init_math3();
    init_twoPoint();
  }
});

// node_modules/d3-geo-projection/src/twoPointEquidistant.js
function twoPointEquidistantRaw(z03) {
  if (!(z03 *= 2))
    return azimuthalEquidistantRaw2;
  var lambdaa = -z03 / 2, lambdab = -lambdaa, z022 = z03 * z03, tanLambda0 = tan3(lambdab), S2 = 0.5 / sin3(lambdab);
  function forward(lambda, phi2) {
    var za = acos3(cos3(phi2) * cos3(lambda - lambdaa)), zb = acos3(cos3(phi2) * cos3(lambda - lambdab)), ys = phi2 < 0 ? -1 : 1;
    za *= za, zb *= zb;
    return [
      (za - zb) / (2 * z03),
      ys * sqrt3(4 * z022 * zb - (z022 - za + zb) * (z022 - za + zb)) / (2 * z03)
    ];
  }
  forward.invert = function(x4, y4) {
    var y22 = y4 * y4, cosza = cos3(sqrt3(y22 + (t2 = x4 + lambdaa) * t2)), coszb = cos3(sqrt3(y22 + (t2 = x4 + lambdab) * t2)), t2, d2;
    return [
      atan23(d2 = cosza - coszb, t2 = (cosza + coszb) * tanLambda0),
      (y4 < 0 ? -1 : 1) * acos3(sqrt3(t2 * t2 + d2 * d2) * S2)
    ];
  };
  return forward;
}
function twoPointEquidistantUsa() {
  return twoPointEquidistant([-158, 21.5], [-77, 39]).clipAngle(130).scale(122.571);
}
function twoPointEquidistant(p03, p1) {
  return twoPoint_default(twoPointEquidistantRaw, p03, p1);
}
var init_twoPointEquidistant = __esm({
  "node_modules/d3-geo-projection/src/twoPointEquidistant.js"() {
    init_src2();
    init_math3();
    init_twoPoint();
  }
});

// node_modules/d3-geo-projection/src/vanDerGrinten.js
function vanDerGrintenRaw(lambda, phi2) {
  if (abs3(phi2) < epsilon4)
    return [lambda, 0];
  var sinTheta = abs3(phi2 / halfPi3), theta = asin3(sinTheta);
  if (abs3(lambda) < epsilon4 || abs3(abs3(phi2) - halfPi3) < epsilon4)
    return [0, sign3(phi2) * pi3 * tan3(theta / 2)];
  var cosTheta = cos3(theta), A6 = abs3(pi3 / lambda - lambda / pi3) / 2, A23 = A6 * A6, G2 = cosTheta / (sinTheta + cosTheta - 1), P2 = G2 * (2 / sinTheta - 1), P22 = P2 * P2, P2_A2 = P22 + A23, G_P2 = G2 - P22, Q2 = A23 + G2;
  return [
    sign3(lambda) * pi3 * (A6 * G_P2 + sqrt3(A23 * G_P2 * G_P2 - P2_A2 * (G2 * G2 - P22))) / P2_A2,
    sign3(phi2) * pi3 * (P2 * Q2 - A6 * sqrt3((A23 + 1) * P2_A2 - Q2 * Q2)) / P2_A2
  ];
}
function vanDerGrinten_default() {
  return projection2(vanDerGrintenRaw).scale(79.4183);
}
var init_vanDerGrinten = __esm({
  "node_modules/d3-geo-projection/src/vanDerGrinten.js"() {
    init_src2();
    init_math3();
    vanDerGrintenRaw.invert = function(x4, y4) {
      if (abs3(y4) < epsilon4)
        return [x4, 0];
      if (abs3(x4) < epsilon4)
        return [0, halfPi3 * sin3(2 * atan4(y4 / pi3))];
      var x22 = (x4 /= pi3) * x4, y22 = (y4 /= pi3) * y4, x2_y2 = x22 + y22, z2 = x2_y2 * x2_y2, c1 = -abs3(y4) * (1 + x2_y2), c2 = c1 - 2 * y22 + x22, c3 = -2 * c1 + 1 + 2 * y22 + z2, d2 = y22 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * sqrt3(-a1 / 3), theta1 = acos3(3 * d2 / (a1 * m1)) / 3;
      return [
        pi3 * (x2_y2 - 1 + sqrt3(1 + 2 * (x22 - y22) + z2)) / (2 * x4),
        sign3(y4) * pi3 * (-m1 * cos3(theta1 + pi3 / 3) - c2 / (3 * c3))
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/vanDerGrinten2.js
function vanDerGrinten2Raw(lambda, phi2) {
  if (abs3(phi2) < epsilon4)
    return [lambda, 0];
  var sinTheta = abs3(phi2 / halfPi3), theta = asin3(sinTheta);
  if (abs3(lambda) < epsilon4 || abs3(abs3(phi2) - halfPi3) < epsilon4)
    return [0, sign3(phi2) * pi3 * tan3(theta / 2)];
  var cosTheta = cos3(theta), A6 = abs3(pi3 / lambda - lambda / pi3) / 2, A23 = A6 * A6, x16 = cosTheta * (sqrt3(1 + A23) - A6 * cosTheta) / (1 + A23 * sinTheta * sinTheta);
  return [
    sign3(lambda) * pi3 * x16,
    sign3(phi2) * pi3 * sqrt3(1 - x16 * (2 * A6 + x16))
  ];
}
function vanDerGrinten2_default() {
  return projection2(vanDerGrinten2Raw).scale(79.4183);
}
var init_vanDerGrinten2 = __esm({
  "node_modules/d3-geo-projection/src/vanDerGrinten2.js"() {
    init_src2();
    init_math3();
    vanDerGrinten2Raw.invert = function(x4, y4) {
      if (!x4)
        return [0, halfPi3 * sin3(2 * atan4(y4 / pi3))];
      var x16 = abs3(x4 / pi3), A6 = (1 - x16 * x16 - (y4 /= pi3) * y4) / (2 * x16), A23 = A6 * A6, B3 = sqrt3(A23 + 1);
      return [
        sign3(x4) * pi3 * (B3 - A6),
        sign3(y4) * halfPi3 * sin3(2 * atan23(sqrt3((1 - 2 * A6 * x16) * (A6 + B3) - x16), sqrt3(B3 + A6 + x16)))
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/vanDerGrinten3.js
function vanDerGrinten3Raw(lambda, phi2) {
  if (abs3(phi2) < epsilon4)
    return [lambda, 0];
  var sinTheta = phi2 / halfPi3, theta = asin3(sinTheta);
  if (abs3(lambda) < epsilon4 || abs3(abs3(phi2) - halfPi3) < epsilon4)
    return [0, pi3 * tan3(theta / 2)];
  var A6 = (pi3 / lambda - lambda / pi3) / 2, y16 = sinTheta / (1 + cos3(theta));
  return [
    pi3 * (sign3(lambda) * sqrt3(A6 * A6 + 1 - y16 * y16) - A6),
    pi3 * y16
  ];
}
function vanDerGrinten3_default() {
  return projection2(vanDerGrinten3Raw).scale(79.4183);
}
var init_vanDerGrinten3 = __esm({
  "node_modules/d3-geo-projection/src/vanDerGrinten3.js"() {
    init_src2();
    init_math3();
    vanDerGrinten3Raw.invert = function(x4, y4) {
      if (!y4)
        return [x4, 0];
      var y16 = y4 / pi3, A6 = (pi3 * pi3 * (1 - y16 * y16) - x4 * x4) / (2 * pi3 * x4);
      return [
        x4 ? pi3 * (sign3(x4) * sqrt3(A6 * A6 + 1) - A6) : 0,
        halfPi3 * sin3(2 * atan4(y16))
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/vanDerGrinten4.js
function vanDerGrinten4Raw(lambda, phi2) {
  if (!phi2)
    return [lambda, 0];
  var phi04 = abs3(phi2);
  if (!lambda || phi04 === halfPi3)
    return [0, phi2];
  var B3 = phi04 / halfPi3, B22 = B3 * B3, C2 = (8 * B3 - B22 * (B22 + 2) - 5) / (2 * B22 * (B3 - 1)), C22 = C2 * C2, BC = B3 * C2, B_C2 = B22 + C22 + 2 * BC, B_3C = B3 + 3 * C2, lambda06 = lambda / halfPi3, lambda13 = lambda06 + 1 / lambda06, D2 = sign3(abs3(lambda) - halfPi3) * sqrt3(lambda13 * lambda13 - 4), D22 = D2 * D2, F2 = B_C2 * (B22 + C22 * D22 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C22) + 12 * BC * C22 + 4 * C22 * C22), x16 = (D2 * (B_C2 + C22 - 1) + 2 * sqrt3(F2)) / (4 * B_C2 + D22);
  return [
    sign3(lambda) * halfPi3 * x16,
    sign3(phi2) * halfPi3 * sqrt3(1 + D2 * abs3(x16) - x16 * x16)
  ];
}
function vanDerGrinten4_default() {
  return projection2(vanDerGrinten4Raw).scale(127.16);
}
var init_vanDerGrinten4 = __esm({
  "node_modules/d3-geo-projection/src/vanDerGrinten4.js"() {
    init_src2();
    init_math3();
    vanDerGrinten4Raw.invert = function(x4, y4) {
      var delta;
      if (!x4 || !y4)
        return [x4, y4];
      y4 /= pi3;
      var x16 = sign3(x4) * x4 / halfPi3, D2 = (x16 * x16 - 1 + 4 * y4 * y4) / abs3(x16), D22 = D2 * D2, B3 = 2 * y4, i2 = 50;
      do {
        var B22 = B3 * B3, C2 = (8 * B3 - B22 * (B22 + 2) - 5) / (2 * B22 * (B3 - 1)), C_ = (3 * B3 - B22 * B3 - 10) / (2 * B22 * B3), C22 = C2 * C2, BC = B3 * C2, B_C = B3 + C2, B_C2 = B_C * B_C, B_3C = B3 + 3 * C2, F2 = B_C2 * (B22 + C22 * D22 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C22) + C22 * (12 * BC + 4 * C22)), F_ = -2 * B_C * (4 * BC * C22 + (1 - 4 * B22 + 3 * B22 * B22) * (1 + C_) + C22 * (-6 + 14 * B22 - D22 + (-8 + 8 * B22 - 2 * D22) * C_) + BC * (-8 + 12 * B22 + (-10 + 10 * B22 - D22) * C_)), sqrtF = sqrt3(F2), f2 = D2 * (B_C2 + C22 - 1) + 2 * sqrtF - x16 * (4 * B_C2 + D22), f_ = D2 * (2 * C2 * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D2 * (-1 + C22 + B_C2) + 2 * sqrtF) * (1 + C_) / (D22 + 4 * B_C2);
        B3 -= delta = f2 / f_;
      } while (delta > epsilon4 && --i2 > 0);
      return [
        sign3(x4) * (sqrt3(D2 * D2 + 4) + D2) * pi3 / 4,
        halfPi3 * B3
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/wagner4.js
function wagner4_default() {
  return projection2(wagner4Raw).scale(176.84);
}
var A, B, wagner4Raw;
var init_wagner4 = __esm({
  "node_modules/d3-geo-projection/src/wagner4.js"() {
    init_src2();
    init_math3();
    init_mollweide();
    A = 4 * pi3 + 3 * sqrt3(3);
    B = 2 * sqrt3(2 * pi3 * sqrt3(3) / A);
    wagner4Raw = mollweideBromleyRaw(B * sqrt3(3) / pi3, B, A / 6);
  }
});

// node_modules/d3-geo-projection/src/wagner6.js
function wagner6Raw(lambda, phi2) {
  return [lambda * sqrt3(1 - 3 * phi2 * phi2 / (pi3 * pi3)), phi2];
}
function wagner6_default() {
  return projection2(wagner6Raw).scale(152.63);
}
var init_wagner6 = __esm({
  "node_modules/d3-geo-projection/src/wagner6.js"() {
    init_src2();
    init_math3();
    wagner6Raw.invert = function(x4, y4) {
      return [x4 / sqrt3(1 - 3 * y4 * y4 / (pi3 * pi3)), y4];
    };
  }
});

// node_modules/d3-geo-projection/src/wagner7.js
function wagner7Raw(lambda, phi2) {
  var s3 = 0.90631 * sin3(phi2), c0 = sqrt3(1 - s3 * s3), c1 = sqrt3(2 / (1 + c0 * cos3(lambda /= 3)));
  return [
    2.66723 * c0 * c1 * sin3(lambda),
    1.24104 * s3 * c1
  ];
}
function wagner7_default() {
  return projection2(wagner7Raw).scale(172.632);
}
var init_wagner7 = __esm({
  "node_modules/d3-geo-projection/src/wagner7.js"() {
    init_src2();
    init_math3();
    wagner7Raw.invert = function(x4, y4) {
      var t1 = x4 / 2.66723, t2 = y4 / 1.24104, p2 = sqrt3(t1 * t1 + t2 * t2), c2 = 2 * asin3(p2 / 2);
      return [
        3 * atan23(x4 * tan3(c2), 2.66723 * p2),
        p2 && asin3(y4 * sin3(c2) / (1.24104 * 0.90631 * p2))
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/wiechel.js
function wiechelRaw(lambda, phi2) {
  var cosPhi = cos3(phi2), sinPhi = cos3(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos3(lambda = atan23(sin3(lambda) * cosPhi, -sin3(phi2))), sinLambda = sin3(lambda);
  cosPhi = sqrt3(1 - sinPhi * sinPhi);
  return [
    sinLambda * cosPhi - cosLambda * sin1_Phi,
    -cosLambda * cosPhi - sinLambda * sin1_Phi
  ];
}
function wiechel_default() {
  return projection2(wiechelRaw).rotate([0, -90, 45]).scale(124.75).clipAngle(180 - 1e-3);
}
var init_wiechel = __esm({
  "node_modules/d3-geo-projection/src/wiechel.js"() {
    init_src2();
    init_math3();
    wiechelRaw.invert = function(x4, y4) {
      var w3 = (x4 * x4 + y4 * y4) / -2, k4 = sqrt3(-w3 * (2 + w3)), b2 = y4 * w3 + x4 * k4, a3 = x4 * w3 - y4 * k4, D2 = sqrt3(a3 * a3 + b2 * b2);
      return [
        atan23(k4 * b2, D2 * (1 + w3)),
        D2 ? -asin3(k4 * a3 / D2) : 0
      ];
    };
  }
});

// node_modules/d3-geo-projection/src/winkel3.js
function winkel3Raw(lambda, phi2) {
  var coordinates2 = aitoffRaw(lambda, phi2);
  return [
    (coordinates2[0] + lambda / halfPi3) / 2,
    (coordinates2[1] + phi2) / 2
  ];
}
function winkel3_default() {
  return projection2(winkel3Raw).scale(158.837);
}
var init_winkel3 = __esm({
  "node_modules/d3-geo-projection/src/winkel3.js"() {
    init_src2();
    init_aitoff();
    init_math3();
    winkel3Raw.invert = function(x4, y4) {
      var lambda = x4, phi2 = y4, i2 = 25;
      do {
        var cosphi = cos3(phi2), sinphi = sin3(phi2), sin_2phi = sin3(2 * phi2), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin3(lambda), coslambda_2 = cos3(lambda / 2), sinlambda_2 = sin3(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C2 = 1 - cos2phi * coslambda_2 * coslambda_2, E2 = C2 ? acos3(cosphi * coslambda_2) * sqrt3(F2 = 1 / C2) : F2 = 0, F2, fx = 0.5 * (2 * E2 * cosphi * sinlambda_2 + lambda / halfPi3) - x4, fy = 0.5 * (E2 * sinphi + phi2) - y4, dxdlambda = 0.5 * F2 * (cos2phi * sin2lambda_2 + E2 * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi3, dxdphi = F2 * (sinlambda * sin_2phi / 4 - E2 * sinphi * sinlambda_2), dydlambda = 0.125 * F2 * (sin_2phi * sinlambda_2 - E2 * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F2 * (sin2phi * coslambda_2 + E2 * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
        lambda -= dlambda, phi2 -= dphi;
      } while ((abs3(dlambda) > epsilon4 || abs3(dphi) > epsilon4) && --i2 > 0);
      return [lambda, phi2];
    };
  }
});

// node_modules/d3-geo-projection/index.js
var d3_geo_projection_exports = {};
__export(d3_geo_projection_exports, {
  geoAiry: () => airy_default,
  geoAiryRaw: () => airyRaw,
  geoAitoff: () => aitoff_default,
  geoAitoffRaw: () => aitoffRaw,
  geoArmadillo: () => armadillo_default,
  geoArmadilloRaw: () => armadilloRaw,
  geoAugust: () => august_default,
  geoAugustRaw: () => augustRaw,
  geoBaker: () => baker_default,
  geoBakerRaw: () => bakerRaw,
  geoBerghaus: () => berghaus_default,
  geoBerghausRaw: () => berghausRaw,
  geoBoggs: () => boggs_default,
  geoBoggsRaw: () => boggsRaw,
  geoBonne: () => bonne_default,
  geoBonneRaw: () => bonneRaw,
  geoBottomley: () => bottomley_default,
  geoBottomleyRaw: () => bottomleyRaw,
  geoBromley: () => bromley_default,
  geoBromleyRaw: () => bromleyRaw,
  geoChamberlin: () => chamberlin,
  geoChamberlinAfrica: () => chamberlinAfrica,
  geoChamberlinRaw: () => chamberlinRaw,
  geoCollignon: () => collignon_default,
  geoCollignonRaw: () => collignonRaw,
  geoCraig: () => craig_default,
  geoCraigRaw: () => craigRaw,
  geoCraster: () => craster_default,
  geoCrasterRaw: () => crasterRaw,
  geoCylindricalEqualArea: () => cylindricalEqualArea_default,
  geoCylindricalEqualAreaRaw: () => cylindricalEqualAreaRaw3,
  geoCylindricalStereographic: () => cylindricalStereographic_default,
  geoCylindricalStereographicRaw: () => cylindricalStereographicRaw,
  geoEckert1: () => eckert1_default,
  geoEckert1Raw: () => eckert1Raw,
  geoEckert2: () => eckert2_default,
  geoEckert2Raw: () => eckert2Raw,
  geoEckert3: () => eckert3_default,
  geoEckert3Raw: () => eckert3Raw,
  geoEckert4: () => eckert4_default,
  geoEckert4Raw: () => eckert4Raw,
  geoEckert5: () => eckert5_default,
  geoEckert5Raw: () => eckert5Raw,
  geoEckert6: () => eckert6_default,
  geoEckert6Raw: () => eckert6Raw,
  geoEisenlohr: () => eisenlohr_default,
  geoEisenlohrRaw: () => eisenlohrRaw,
  geoFahey: () => fahey_default,
  geoFaheyRaw: () => faheyRaw,
  geoFoucaut: () => foucaut_default,
  geoFoucautRaw: () => foucautRaw,
  geoGilbert: () => gilbert_default,
  geoGingery: () => gingery_default,
  geoGingeryRaw: () => gingeryRaw,
  geoGinzburg4: () => ginzburg4_default,
  geoGinzburg4Raw: () => ginzburg4Raw,
  geoGinzburg5: () => ginzburg5_default,
  geoGinzburg5Raw: () => ginzburg5Raw,
  geoGinzburg6: () => ginzburg6_default,
  geoGinzburg6Raw: () => ginzburg6Raw,
  geoGinzburg8: () => ginzburg8_default,
  geoGinzburg8Raw: () => ginzburg8Raw,
  geoGinzburg9: () => ginzburg9_default,
  geoGinzburg9Raw: () => ginzburg9Raw,
  geoGringorten: () => gringorten_default,
  geoGringortenQuincuncial: () => gringorten_default2,
  geoGringortenRaw: () => gringortenRaw,
  geoGuyou: () => guyou_default,
  geoGuyouRaw: () => guyouRaw,
  geoHammer: () => hammer_default,
  geoHammerRaw: () => hammerRaw,
  geoHammerRetroazimuthal: () => hammerRetroazimuthal_default,
  geoHammerRetroazimuthalRaw: () => hammerRetroazimuthalRaw,
  geoHealpix: () => healpix_default,
  geoHealpixRaw: () => healpixRaw,
  geoHill: () => hill_default,
  geoHillRaw: () => hillRaw,
  geoHomolosine: () => homolosine_default,
  geoHomolosineRaw: () => homolosineRaw,
  geoInterrupt: () => interrupted_default,
  geoInterruptedBoggs: () => boggs_default2,
  geoInterruptedHomolosine: () => homolosine_default2,
  geoInterruptedMollweide: () => mollweide_default2,
  geoInterruptedMollweideHemispheres: () => mollweideHemispheres_default,
  geoInterruptedSinuMollweide: () => sinuMollweide_default2,
  geoInterruptedSinusoidal: () => sinusoidal_default2,
  geoKavrayskiy7: () => kavrayskiy7_default,
  geoKavrayskiy7Raw: () => kavrayskiy7Raw,
  geoLagrange: () => lagrange_default,
  geoLagrangeRaw: () => lagrangeRaw,
  geoLarrivee: () => larrivee_default,
  geoLarriveeRaw: () => larriveeRaw,
  geoLaskowski: () => laskowski_default,
  geoLaskowskiRaw: () => laskowskiRaw,
  geoLittrow: () => littrow_default,
  geoLittrowRaw: () => littrowRaw,
  geoLoximuthal: () => loximuthal_default,
  geoLoximuthalRaw: () => loximuthalRaw,
  geoMiller: () => miller_default,
  geoMillerRaw: () => millerRaw,
  geoModifiedStereographic: () => modifiedStereographic,
  geoModifiedStereographicAlaska: () => modifiedStereographicAlaska,
  geoModifiedStereographicGs48: () => modifiedStereographicGs48,
  geoModifiedStereographicGs50: () => modifiedStereographicGs50,
  geoModifiedStereographicLee: () => modifiedStereographicLee,
  geoModifiedStereographicMiller: () => modifiedStereographicMiller,
  geoModifiedStereographicRaw: () => modifiedStereographicRaw,
  geoMollweide: () => mollweide_default,
  geoMollweideRaw: () => mollweideRaw,
  geoMtFlatPolarParabolic: () => mtFlatPolarParabolic_default,
  geoMtFlatPolarParabolicRaw: () => mtFlatPolarParabolicRaw,
  geoMtFlatPolarQuartic: () => mtFlatPolarQuartic_default,
  geoMtFlatPolarQuarticRaw: () => mtFlatPolarQuarticRaw,
  geoMtFlatPolarSinusoidal: () => mtFlatPolarSinusoidal_default,
  geoMtFlatPolarSinusoidalRaw: () => mtFlatPolarSinusoidalRaw,
  geoNaturalEarth: () => naturalEarth_default,
  geoNaturalEarth2: () => naturalEarth2_default,
  geoNaturalEarth2Raw: () => naturalEarth2Raw,
  geoNaturalEarthRaw: () => naturalEarthRaw,
  geoNellHammer: () => nellHammer_default,
  geoNellHammerRaw: () => nellHammerRaw,
  geoPatterson: () => patterson_default,
  geoPattersonRaw: () => pattersonRaw,
  geoPeirceQuincuncial: () => peirce_default,
  geoPierceQuincuncial: () => peirce_default,
  geoPolyconic: () => polyconic_default,
  geoPolyconicRaw: () => polyconicRaw,
  geoPolyhedral: () => polyhedral_default,
  geoPolyhedralButterfly: () => butterfly_default,
  geoPolyhedralCollignon: () => collignon_default2,
  geoPolyhedralWaterman: () => waterman_default,
  geoProject: () => project_default,
  geoQuantize: () => quantize_default,
  geoQuincuncial: () => quincuncial_default,
  geoRectangularPolyconic: () => rectangularPolyconic_default,
  geoRectangularPolyconicRaw: () => rectangularPolyconicRaw,
  geoRobinson: () => robinson_default,
  geoRobinsonRaw: () => robinsonRaw,
  geoSatellite: () => satellite_default,
  geoSatelliteRaw: () => satelliteRaw,
  geoSinuMollweide: () => sinuMollweide_default,
  geoSinuMollweideRaw: () => sinuMollweideRaw,
  geoSinusoidal: () => sinusoidal_default,
  geoSinusoidalRaw: () => sinusoidalRaw,
  geoStitch: () => stitch_default,
  geoTimes: () => times_default,
  geoTimesRaw: () => timesRaw,
  geoTwoPointAzimuthal: () => twoPointAzimuthal,
  geoTwoPointAzimuthalRaw: () => twoPointAzimuthalRaw,
  geoTwoPointAzimuthalUsa: () => twoPointAzimuthalUsa,
  geoTwoPointEquidistant: () => twoPointEquidistant,
  geoTwoPointEquidistantRaw: () => twoPointEquidistantRaw,
  geoTwoPointEquidistantUsa: () => twoPointEquidistantUsa,
  geoVanDerGrinten: () => vanDerGrinten_default,
  geoVanDerGrinten2: () => vanDerGrinten2_default,
  geoVanDerGrinten2Raw: () => vanDerGrinten2Raw,
  geoVanDerGrinten3: () => vanDerGrinten3_default,
  geoVanDerGrinten3Raw: () => vanDerGrinten3Raw,
  geoVanDerGrinten4: () => vanDerGrinten4_default,
  geoVanDerGrinten4Raw: () => vanDerGrinten4Raw,
  geoVanDerGrintenRaw: () => vanDerGrintenRaw,
  geoWagner4: () => wagner4_default,
  geoWagner4Raw: () => wagner4Raw,
  geoWagner6: () => wagner6_default,
  geoWagner6Raw: () => wagner6Raw,
  geoWagner7: () => wagner7_default,
  geoWagner7Raw: () => wagner7Raw,
  geoWiechel: () => wiechel_default,
  geoWiechelRaw: () => wiechelRaw,
  geoWinkel3: () => winkel3_default,
  geoWinkel3Raw: () => winkel3Raw
});
var init_d3_geo_projection = __esm({
  "node_modules/d3-geo-projection/index.js"() {
    init_airy();
    init_aitoff();
    init_armadillo();
    init_august();
    init_baker();
    init_berghaus();
    init_boggs();
    init_bonne();
    init_bottomley();
    init_bromley();
    init_chamberlin();
    init_collignon();
    init_craig();
    init_craster();
    init_cylindricalEqualArea3();
    init_cylindricalStereographic();
    init_eckert1();
    init_eckert2();
    init_eckert3();
    init_eckert4();
    init_eckert5();
    init_eckert6();
    init_eisenlohr();
    init_fahey();
    init_foucaut();
    init_gilbert();
    init_gingery();
    init_ginzburg4();
    init_ginzburg5();
    init_ginzburg6();
    init_ginzburg8();
    init_ginzburg9();
    init_gringorten();
    init_guyou();
    init_hammer();
    init_hammerRetroazimuthal();
    init_healpix();
    init_hill();
    init_homolosine();
    init_interrupted();
    init_boggs2();
    init_homolosine2();
    init_mollweide2();
    init_mollweideHemispheres();
    init_sinuMollweide2();
    init_sinusoidal2();
    init_kavrayskiy7();
    init_lagrange();
    init_larrivee();
    init_laskowski();
    init_littrow();
    init_loximuthal();
    init_miller();
    init_modifiedStereographic();
    init_mollweide();
    init_mtFlatPolarParabolic();
    init_mtFlatPolarQuartic();
    init_mtFlatPolarSinusoidal();
    init_naturalEarth();
    init_naturalEarth2();
    init_nellHammer();
    init_patterson();
    init_polyconic();
    init_polyhedral();
    init_butterfly();
    init_collignon2();
    init_waterman();
    init_project();
    init_gringorten2();
    init_peirce();
    init_peirce();
    init_quantize();
    init_quincuncial();
    init_rectangularPolyconic();
    init_robinson();
    init_satellite();
    init_sinuMollweide();
    init_sinusoidal();
    init_stitch();
    init_times();
    init_twoPointAzimuthal();
    init_twoPointEquidistant();
    init_vanDerGrinten();
    init_vanDerGrinten2();
    init_vanDerGrinten3();
    init_vanDerGrinten4();
    init_wagner4();
    init_wagner6();
    init_wagner7();
    init_wiechel();
    init_winkel3();
  }
});

// node_modules/wolfy87-eventemitter/EventEmitter.js
var require_EventEmitter = __commonJS({
  "node_modules/wolfy87-eventemitter/EventEmitter.js"(exports, module) {
    (function(exports2) {
      "use strict";
      function EventEmitter() {
      }
      var proto2 = EventEmitter.prototype;
      var originalGlobalValue = exports2.EventEmitter;
      function indexOfListener(listeners, listener) {
        var i2 = listeners.length;
        while (i2--) {
          if (listeners[i2].listener === listener) {
            return i2;
          }
        }
        return -1;
      }
      function alias(name) {
        return function aliasClosure() {
          return this[name].apply(this, arguments);
        };
      }
      proto2.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;
        if (evt instanceof RegExp) {
          response = {};
          for (key in events) {
            if (events.hasOwnProperty(key) && evt.test(key)) {
              response[key] = events[key];
            }
          }
        } else {
          response = events[evt] || (events[evt] = []);
        }
        return response;
      };
      proto2.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i2;
        for (i2 = 0; i2 < listeners.length; i2 += 1) {
          flatListeners.push(listeners[i2].listener);
        }
        return flatListeners;
      };
      proto2.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;
        if (listeners instanceof Array) {
          response = {};
          response[evt] = listeners;
        }
        return response || listeners;
      };
      function isValidListener(listener) {
        if (typeof listener === "function" || listener instanceof RegExp) {
          return true;
        } else if (listener && typeof listener === "object") {
          return isValidListener(listener.listener);
        } else {
          return false;
        }
      }
      proto2.addListener = function addListener(evt, listener) {
        if (!isValidListener(listener)) {
          throw new TypeError("listener must be a function");
        }
        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === "object";
        var key;
        for (key in listeners) {
          if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
            listeners[key].push(listenerIsWrapped ? listener : {
              listener,
              once: false
            });
          }
        }
        return this;
      };
      proto2.on = alias("addListener");
      proto2.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
          listener,
          once: true
        });
      };
      proto2.once = alias("addOnceListener");
      proto2.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
      };
      proto2.defineEvents = function defineEvents(evts) {
        for (var i2 = 0; i2 < evts.length; i2 += 1) {
          this.defineEvent(evts[i2]);
        }
        return this;
      };
      proto2.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index2;
        var key;
        for (key in listeners) {
          if (listeners.hasOwnProperty(key)) {
            index2 = indexOfListener(listeners[key], listener);
            if (index2 !== -1) {
              listeners[key].splice(index2, 1);
            }
          }
        }
        return this;
      };
      proto2.off = alias("removeListener");
      proto2.addListeners = function addListeners(evt, listeners) {
        return this.manipulateListeners(false, evt, listeners);
      };
      proto2.removeListeners = function removeListeners(evt, listeners) {
        return this.manipulateListeners(true, evt, listeners);
      };
      proto2.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i2;
        var value2;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;
        if (typeof evt === "object" && !(evt instanceof RegExp)) {
          for (i2 in evt) {
            if (evt.hasOwnProperty(i2) && (value2 = evt[i2])) {
              if (typeof value2 === "function") {
                single.call(this, i2, value2);
              } else {
                multiple.call(this, i2, value2);
              }
            }
          }
        } else {
          i2 = listeners.length;
          while (i2--) {
            single.call(this, evt, listeners[i2]);
          }
        }
        return this;
      };
      proto2.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;
        if (type === "string") {
          delete events[evt];
        } else if (evt instanceof RegExp) {
          for (key in events) {
            if (events.hasOwnProperty(key) && evt.test(key)) {
              delete events[key];
            }
          }
        } else {
          delete this._events;
        }
        return this;
      };
      proto2.removeAllListeners = alias("removeEvent");
      proto2.emitEvent = function emitEvent(evt, args) {
        var listenersMap = this.getListenersAsObject(evt);
        var listeners;
        var listener;
        var i2;
        var key;
        var response;
        for (key in listenersMap) {
          if (listenersMap.hasOwnProperty(key)) {
            listeners = listenersMap[key].slice(0);
            for (i2 = 0; i2 < listeners.length; i2++) {
              listener = listeners[i2];
              if (listener.once === true) {
                this.removeListener(evt, listener.listener);
              }
              response = listener.listener.apply(this, args || []);
              if (response === this._getOnceReturnValue()) {
                this.removeListener(evt, listener.listener);
              }
            }
          }
        }
        return this;
      };
      proto2.trigger = alias("emitEvent");
      proto2.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
      };
      proto2.setOnceReturnValue = function setOnceReturnValue(value2) {
        this._onceReturnValue = value2;
        return this;
      };
      proto2._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty("_onceReturnValue")) {
          return this._onceReturnValue;
        } else {
          return true;
        }
      };
      proto2._getEvents = function _getEvents() {
        return this._events || (this._events = {});
      };
      EventEmitter.noConflict = function noConflict() {
        exports2.EventEmitter = originalGlobalValue;
        return EventEmitter;
      };
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter;
        });
      } else if (typeof module === "object" && module.exports) {
        module.exports = EventEmitter;
      } else {
        exports2.EventEmitter = EventEmitter;
      }
    })(typeof window !== "undefined" ? window : exports || {});
  }
});

// node_modules/@antv/data-set/lib/view.js
var require_view = __commonJS({
  "node_modules/@antv/data-set/lib/view.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.View = void 0;
    var tslib_1 = require_tslib();
    var wolfy87_eventemitter_1 = tslib_1.__importDefault(require_EventEmitter());
    var util_1 = (init_esm(), esm_exports);
    function cloneOptions(options) {
      var result = {};
      util_1.forIn(options, function(value2, key) {
        if (util_1.isObject(value2) && value2.isView) {
          result[key] = value2;
        } else if (util_1.isArray(value2)) {
          result[key] = value2.concat([]);
        } else if (util_1.isPlainObject(value2)) {
          result[key] = util_1.clone(value2);
        } else {
          result[key] = value2;
        }
      });
      return result;
    }
    var View = function(_super) {
      tslib_1.__extends(View2, _super);
      function View2(dataSet, options) {
        var _this = _super.call(this) || this;
        _this.isView = true;
        _this.isDataView = true;
        _this.watchingStates = null;
        _this.dataType = "table";
        _this.transforms = [];
        _this.origin = [];
        _this.rows = [];
        if (dataSet && dataSet.isDataSet) {
          _this.dataSet = dataSet;
        } else {
          _this.dataSet = null;
          options = dataSet;
        }
        _this.loose = !_this.dataSet;
        if (options) {
          _this.watchingStates = options.watchingStates;
        }
        if (!_this.loose) {
          var watchingStates_1 = _this.watchingStates;
          dataSet.on("statechange", function(name) {
            if (util_1.isArray(watchingStates_1)) {
              if (watchingStates_1.indexOf(name) > -1) {
                _this._reExecute();
              }
            } else {
              _this._reExecute();
            }
          });
        }
        return _this;
      }
      View2.prototype._parseStateExpression = function(expr) {
        var dataSet = this.dataSet;
        if (dataSet === null)
          return void 0;
        var matched = /^\$state\.(\w+)/.exec(expr);
        if (matched) {
          return dataSet.state[matched[1]];
        }
        return expr;
      };
      View2.prototype._preparseOptions = function(options) {
        var _this = this;
        var optionsCloned = cloneOptions(options);
        if (this.loose) {
          return optionsCloned;
        }
        util_1.forIn(optionsCloned, function(value2, key) {
          if (util_1.isString(value2) && /^\$state\./.test(value2)) {
            optionsCloned[key] = _this._parseStateExpression(value2);
          }
        });
        return optionsCloned;
      };
      View2.prototype._prepareSource = function(source, options) {
        this._source = { source, options };
        if (!options) {
          if (source instanceof View2 || util_1.isString(source)) {
            this.origin = View2.DataSet.getConnector("default")(source, this.dataSet);
          } else if (util_1.isArray(source)) {
            this.origin = source;
          } else if (util_1.isObject(source) && source.type) {
            var opts = this._preparseOptions(source);
            this.origin = View2.DataSet.getConnector(opts.type)(opts, this);
          } else {
            throw new TypeError("Invalid source");
          }
        } else {
          var opts = this._preparseOptions(options);
          this.origin = View2.DataSet.getConnector(opts.type)(source, opts, this);
        }
        this.rows = util_1.deepMix([], this.origin);
        return this;
      };
      View2.prototype.source = function(source, options) {
        this._prepareSource(source, options)._reExecuteTransforms();
        this.trigger("change", []);
        return this;
      };
      View2.prototype.transform = function(options) {
        if (options && options.type) {
          this.transforms.push(options);
          this._executeTransform(options);
        }
        return this;
      };
      View2.prototype._executeTransform = function(options) {
        options = this._preparseOptions(options);
        var transform = View2.DataSet.getTransform(options.type);
        transform(this, options);
      };
      View2.prototype._reExecuteTransforms = function() {
        var _this = this;
        this.transforms.forEach(function(options) {
          _this._executeTransform(options);
        });
      };
      View2.prototype.addRow = function(row) {
        this.rows.push(row);
      };
      View2.prototype.removeRow = function(index2) {
        this.rows.splice(index2, 1);
      };
      View2.prototype.updateRow = function(index2, newRow) {
        util_1.assign(this.rows[index2], newRow);
      };
      View2.prototype.findRows = function(query) {
        return this.rows.filter(function(row) {
          return util_1.isMatch(row, query);
        });
      };
      View2.prototype.findRow = function(query) {
        return util_1.find(this.rows, query);
      };
      View2.prototype.getColumnNames = function() {
        var firstRow = this.rows[0];
        if (firstRow) {
          return util_1.keys(firstRow);
        }
        return [];
      };
      View2.prototype.getColumnName = function(index2) {
        return this.getColumnNames()[index2];
      };
      View2.prototype.getColumnIndex = function(columnName) {
        var columnNames = this.getColumnNames();
        return columnNames.indexOf(columnName);
      };
      View2.prototype.getColumn = function(columnName) {
        return this.rows.map(function(row) {
          return row[columnName];
        });
      };
      View2.prototype.getColumnData = function(columnName) {
        return this.getColumn(columnName);
      };
      View2.prototype.getSubset = function(startRowIndex, endRowIndex, columnNames) {
        var subset2 = [];
        for (var i2 = startRowIndex; i2 <= endRowIndex; i2++) {
          subset2.push(util_1.pick(this.rows[i2], columnNames));
        }
        return subset2;
      };
      View2.prototype.toString = function(prettyPrint) {
        if (prettyPrint === void 0) {
          prettyPrint = false;
        }
        if (prettyPrint) {
          return JSON.stringify(this.rows, null, 2);
        }
        return JSON.stringify(this.rows);
      };
      View2.prototype._reExecute = function() {
        var _a = this._source, source = _a.source, options = _a.options;
        this._prepareSource(source, options);
        this._reExecuteTransforms();
        this.trigger("change", []);
      };
      return View2;
    }(wolfy87_eventemitter_1.default);
    exports.View = View;
  }
});

// node_modules/d3-composite-projections/src/math.js
var epsilon6;
var init_math4 = __esm({
  "node_modules/d3-composite-projections/src/math.js"() {
    epsilon6 = 1e-6;
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/ascending.js
function ascending_default2(a3, b2) {
  return a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
}
var init_ascending2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/ascending.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/bisector.js
function bisector_default2(f2) {
  let delta = f2;
  let compare = f2;
  if (f2.length === 1) {
    delta = (d2, x4) => f2(d2) - x4;
    compare = ascendingComparator2(f2);
  }
  function left2(a3, x4, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a3.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a3[mid], x4) < 0)
        lo = mid + 1;
      else
        hi = mid;
    }
    return lo;
  }
  function right2(a3, x4, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a3.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a3[mid], x4) > 0)
        hi = mid;
      else
        lo = mid + 1;
    }
    return lo;
  }
  function center2(a3, x4, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a3.length;
    const i2 = left2(a3, x4, lo, hi - 1);
    return i2 > lo && delta(a3[i2 - 1], x4) > -delta(a3[i2], x4) ? i2 - 1 : i2;
  }
  return { left: left2, center: center2, right: right2 };
}
function ascendingComparator2(f2) {
  return (d2, x4) => ascending_default2(f2(d2), x4);
}
var init_bisector2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/bisector.js"() {
    init_ascending2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/number.js
function number_default2(x4) {
  return x4 === null ? NaN : +x4;
}
var init_number2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/number.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/bisect.js
var ascendingBisect2, bisectRight2, bisectLeft2, bisectCenter;
var init_bisect2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/bisect.js"() {
    init_ascending2();
    init_bisector2();
    init_number2();
    ascendingBisect2 = bisector_default2(ascending_default2);
    bisectRight2 = ascendingBisect2.right;
    bisectLeft2 = ascendingBisect2.left;
    bisectCenter = bisector_default2(number_default2).center;
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/count.js
var init_count = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/count.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/cross.js
var init_cross2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/cross.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/cumsum.js
var init_cumsum = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/cumsum.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/descending.js
var init_descending2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/descending.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/variance.js
var init_variance2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/variance.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/deviation.js
var init_deviation2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/deviation.js"() {
    init_variance2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/extent.js
var init_extent4 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/extent.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/fsum.js
var Adder3;
var init_fsum = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/fsum.js"() {
    Adder3 = class {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x4) {
        const p2 = this._partials;
        let i2 = 0;
        for (let j2 = 0; j2 < this._n && j2 < 32; j2++) {
          const y4 = p2[j2], hi = x4 + y4, lo = Math.abs(x4) < Math.abs(y4) ? x4 - (hi - y4) : y4 - (hi - x4);
          if (lo)
            p2[i2++] = lo;
          x4 = hi;
        }
        p2[i2] = x4;
        this._n = i2 + 1;
        return this;
      }
      valueOf() {
        const p2 = this._partials;
        let n2 = this._n, x4, y4, lo, hi = 0;
        if (n2 > 0) {
          hi = p2[--n2];
          while (n2 > 0) {
            x4 = hi;
            y4 = p2[--n2];
            hi = x4 + y4;
            lo = y4 - (hi - x4);
            if (lo)
              break;
          }
          if (n2 > 0 && (lo < 0 && p2[n2 - 1] < 0 || lo > 0 && p2[n2 - 1] > 0)) {
            y4 = lo * 2;
            x4 = hi + y4;
            if (y4 == x4 - hi)
              hi = x4;
          }
        }
        return hi;
      }
    };
  }
});

// node_modules/internmap/src/index.js
var init_src3 = __esm({
  "node_modules/internmap/src/index.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/identity.js
var init_identity6 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/identity.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/group.js
var init_group = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/group.js"() {
    init_src3();
    init_identity6();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/permute.js
var init_permute2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/permute.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/sort.js
var init_sort = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/sort.js"() {
    init_ascending2();
    init_permute2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/groupSort.js
var init_groupSort = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/groupSort.js"() {
    init_ascending2();
    init_group();
    init_sort();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/array.js
var array2, slice2, map2;
var init_array2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/array.js"() {
    array2 = Array.prototype;
    slice2 = array2.slice;
    map2 = array2.map;
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/constant.js
var init_constant4 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/constant.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/ticks.js
var e102, e52, e22;
var init_ticks2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/ticks.js"() {
    e102 = Math.sqrt(50);
    e52 = Math.sqrt(10);
    e22 = Math.sqrt(2);
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/nice.js
var init_nice = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/nice.js"() {
    init_ticks2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/threshold/sturges.js
var init_sturges2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/threshold/sturges.js"() {
    init_count();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/bin.js
var init_bin = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/bin.js"() {
    init_array2();
    init_bisect2();
    init_constant4();
    init_extent4();
    init_identity6();
    init_nice();
    init_ticks2();
    init_sturges2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/max.js
var init_max2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/max.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/min.js
var init_min2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/min.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/quickselect.js
var init_quickselect = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/quickselect.js"() {
    init_ascending2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/quantile.js
var init_quantile2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/quantile.js"() {
    init_max2();
    init_min2();
    init_quickselect();
    init_number2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/threshold/freedmanDiaconis.js
var init_freedmanDiaconis2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/threshold/freedmanDiaconis.js"() {
    init_count();
    init_quantile2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/threshold/scott.js
var init_scott2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/threshold/scott.js"() {
    init_count();
    init_deviation2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/maxIndex.js
var init_maxIndex = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/maxIndex.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/mean.js
var init_mean2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/mean.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/median.js
var init_median2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/median.js"() {
    init_quantile2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array3 of arrays) {
    yield* array3;
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}
var init_merge2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/merge.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/minIndex.js
var init_minIndex = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/minIndex.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/pairs.js
var init_pairs2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/pairs.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/range.js
var init_range2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/range.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/least.js
var init_least = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/least.js"() {
    init_ascending2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/leastIndex.js
var init_leastIndex = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/leastIndex.js"() {
    init_ascending2();
    init_minIndex();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/greatest.js
var init_greatest = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/greatest.js"() {
    init_ascending2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/greatestIndex.js
var init_greatestIndex = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/greatestIndex.js"() {
    init_ascending2();
    init_maxIndex();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/scan.js
var init_scan2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/scan.js"() {
    init_leastIndex();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/shuffle.js
function shuffler(random) {
  return function shuffle2(array3, i0 = 0, i1 = array3.length) {
    let m2 = i1 - (i0 = +i0);
    while (m2) {
      const i2 = random() * m2-- | 0, t2 = array3[m2 + i0];
      array3[m2 + i0] = array3[i2 + i0];
      array3[i2 + i0] = t2;
    }
    return array3;
  };
}
var shuffle_default2;
var init_shuffle2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/shuffle.js"() {
    shuffle_default2 = shuffler(Math.random);
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/sum.js
var init_sum2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/sum.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/transpose.js
var init_transpose2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/transpose.js"() {
    init_min2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/zip.js
var init_zip2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/zip.js"() {
    init_transpose2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/every.js
var init_every = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/every.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/some.js
var init_some = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/some.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/filter.js
var init_filter = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/filter.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/map.js
var init_map = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/map.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/reduce.js
var init_reduce = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/reduce.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/reverse.js
var init_reverse = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/reverse.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/difference.js
var init_difference = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/difference.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/disjoint.js
var init_disjoint = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/disjoint.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/set.js
var init_set = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/set.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/intersection.js
var init_intersection = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/intersection.js"() {
    init_set();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/superset.js
var init_superset = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/superset.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/subset.js
var init_subset = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/subset.js"() {
    init_superset();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/union.js
var init_union = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/union.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-array/src/index.js
var init_src4 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-array/src/index.js"() {
    init_bisect2();
    init_ascending2();
    init_bisector2();
    init_count();
    init_cross2();
    init_cumsum();
    init_descending2();
    init_deviation2();
    init_extent4();
    init_fsum();
    init_group();
    init_groupSort();
    init_bin();
    init_freedmanDiaconis2();
    init_scott2();
    init_sturges2();
    init_max2();
    init_maxIndex();
    init_mean2();
    init_median2();
    init_merge2();
    init_min2();
    init_minIndex();
    init_nice();
    init_pairs2();
    init_permute2();
    init_quantile2();
    init_quickselect();
    init_range2();
    init_least();
    init_leastIndex();
    init_greatest();
    init_greatestIndex();
    init_scan2();
    init_shuffle2();
    init_sum2();
    init_ticks2();
    init_transpose2();
    init_variance2();
    init_zip2();
    init_every();
    init_some();
    init_filter();
    init_map();
    init_reduce();
    init_reverse();
    init_sort();
    init_difference();
    init_disjoint();
    init_intersection();
    init_subset();
    init_superset();
    init_union();
    init_src3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/math.js
function acos4(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi4 : Math.acos(x4);
}
function asin4(x4) {
  return x4 > 1 ? halfPi4 : x4 < -1 ? -halfPi4 : Math.asin(x4);
}
var epsilon7, epsilon24, pi4, halfPi4, quarterPi4, tau4, degrees4, radians4, abs4, atan5, atan24, cos4, exp4, log4, pow4, sin4, sign4, sqrt4, tan4;
var init_math5 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/math.js"() {
    epsilon7 = 1e-6;
    epsilon24 = 1e-12;
    pi4 = Math.PI;
    halfPi4 = pi4 / 2;
    quarterPi4 = pi4 / 4;
    tau4 = pi4 * 2;
    degrees4 = 180 / pi4;
    radians4 = pi4 / 180;
    abs4 = Math.abs;
    atan5 = Math.atan;
    atan24 = Math.atan2;
    cos4 = Math.cos;
    exp4 = Math.exp;
    log4 = Math.log;
    pow4 = Math.pow;
    sin4 = Math.sin;
    sign4 = Math.sign || function(x4) {
      return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;
    };
    sqrt4 = Math.sqrt;
    tan4 = Math.tan;
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/noop.js
function noop3() {
}
var init_noop4 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/noop.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/stream.js
function streamGeometry3(geometry, stream) {
  if (geometry && streamGeometryType3.hasOwnProperty(geometry.type)) {
    streamGeometryType3[geometry.type](geometry, stream);
  }
}
function streamLine3(coordinates2, stream, closed) {
  var i2 = -1, n2 = coordinates2.length - closed, coordinate;
  stream.lineStart();
  while (++i2 < n2)
    coordinate = coordinates2[i2], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon3(coordinates2, stream) {
  var i2 = -1, n2 = coordinates2.length;
  stream.polygonStart();
  while (++i2 < n2)
    streamLine3(coordinates2[i2], stream, 1);
  stream.polygonEnd();
}
function stream_default3(object3, stream) {
  if (object3 && streamObjectType3.hasOwnProperty(object3.type)) {
    streamObjectType3[object3.type](object3, stream);
  } else {
    streamGeometry3(object3, stream);
  }
}
var streamObjectType3, streamGeometryType3;
var init_stream3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/stream.js"() {
    streamObjectType3 = {
      Feature: function(object3, stream) {
        streamGeometry3(object3.geometry, stream);
      },
      FeatureCollection: function(object3, stream) {
        var features = object3.features, i2 = -1, n2 = features.length;
        while (++i2 < n2)
          streamGeometry3(features[i2].geometry, stream);
      }
    };
    streamGeometryType3 = {
      Sphere: function(object3, stream) {
        stream.sphere();
      },
      Point: function(object3, stream) {
        object3 = object3.coordinates;
        stream.point(object3[0], object3[1], object3[2]);
      },
      MultiPoint: function(object3, stream) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          object3 = coordinates2[i2], stream.point(object3[0], object3[1], object3[2]);
      },
      LineString: function(object3, stream) {
        streamLine3(object3.coordinates, stream, 0);
      },
      MultiLineString: function(object3, stream) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          streamLine3(coordinates2[i2], stream, 0);
      },
      Polygon: function(object3, stream) {
        streamPolygon3(object3.coordinates, stream);
      },
      MultiPolygon: function(object3, stream) {
        var coordinates2 = object3.coordinates, i2 = -1, n2 = coordinates2.length;
        while (++i2 < n2)
          streamPolygon3(coordinates2[i2], stream);
      },
      GeometryCollection: function(object3, stream) {
        var geometries = object3.geometries, i2 = -1, n2 = geometries.length;
        while (++i2 < n2)
          streamGeometry3(geometries[i2], stream);
      }
    };
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/area.js
var areaRingSum5, areaSum5;
var init_area5 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/area.js"() {
    init_src4();
    init_math5();
    init_noop4();
    init_stream3();
    areaRingSum5 = new Adder3();
    areaSum5 = new Adder3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/cartesian.js
function spherical4(cartesian5) {
  return [atan24(cartesian5[1], cartesian5[0]), asin4(cartesian5[2])];
}
function cartesian4(spherical5) {
  var lambda = spherical5[0], phi2 = spherical5[1], cosPhi = cos4(phi2);
  return [cosPhi * cos4(lambda), cosPhi * sin4(lambda), sin4(phi2)];
}
function cartesianDot3(a3, b2) {
  return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
}
function cartesianCross3(a3, b2) {
  return [a3[1] * b2[2] - a3[2] * b2[1], a3[2] * b2[0] - a3[0] * b2[2], a3[0] * b2[1] - a3[1] * b2[0]];
}
function cartesianAddInPlace3(a3, b2) {
  a3[0] += b2[0], a3[1] += b2[1], a3[2] += b2[2];
}
function cartesianScale3(vector, k4) {
  return [vector[0] * k4, vector[1] * k4, vector[2] * k4];
}
function cartesianNormalizeInPlace3(d2) {
  var l2 = sqrt4(d2[0] * d2[0] + d2[1] * d2[1] + d2[2] * d2[2]);
  d2[0] /= l2, d2[1] /= l2, d2[2] /= l2;
}
var init_cartesian3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/cartesian.js"() {
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/bounds.js
var init_bounds5 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/bounds.js"() {
    init_src4();
    init_area5();
    init_cartesian3();
    init_math5();
    init_stream3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/centroid.js
var init_centroid5 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/centroid.js"() {
    init_src4();
    init_math5();
    init_noop4();
    init_stream3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/constant.js
var init_constant5 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/constant.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/compose.js
function compose_default3(a3, b2) {
  function compose(x4, y4) {
    return x4 = a3(x4, y4), b2(x4[0], x4[1]);
  }
  if (a3.invert && b2.invert)
    compose.invert = function(x4, y4) {
      return x4 = b2.invert(x4, y4), x4 && a3.invert(x4[0], x4[1]);
    };
  return compose;
}
var init_compose3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/compose.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/rotation.js
function rotationIdentity3(lambda, phi2) {
  return [abs4(lambda) > pi4 ? lambda + Math.round(-lambda / tau4) * tau4 : lambda, phi2];
}
function rotateRadians3(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau4) ? deltaPhi || deltaGamma ? compose_default3(rotationLambda3(deltaLambda), rotationPhiGamma3(deltaPhi, deltaGamma)) : rotationLambda3(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma3(deltaPhi, deltaGamma) : rotationIdentity3;
}
function forwardRotationLambda3(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi4 ? lambda - tau4 : lambda < -pi4 ? lambda + tau4 : lambda, phi2];
  };
}
function rotationLambda3(deltaLambda) {
  var rotation = forwardRotationLambda3(deltaLambda);
  rotation.invert = forwardRotationLambda3(-deltaLambda);
  return rotation;
}
function rotationPhiGamma3(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos4(deltaPhi), sinDeltaPhi = sin4(deltaPhi), cosDeltaGamma = cos4(deltaGamma), sinDeltaGamma = sin4(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos4(phi2), x4 = cos4(lambda) * cosPhi, y4 = sin4(lambda) * cosPhi, z2 = sin4(phi2), k4 = z2 * cosDeltaPhi + x4 * sinDeltaPhi;
    return [
      atan24(y4 * cosDeltaGamma - k4 * sinDeltaGamma, x4 * cosDeltaPhi - z2 * sinDeltaPhi),
      asin4(k4 * cosDeltaGamma + y4 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos4(phi2), x4 = cos4(lambda) * cosPhi, y4 = sin4(lambda) * cosPhi, z2 = sin4(phi2), k4 = z2 * cosDeltaGamma - y4 * sinDeltaGamma;
    return [
      atan24(y4 * cosDeltaGamma + z2 * sinDeltaGamma, x4 * cosDeltaPhi + k4 * sinDeltaPhi),
      asin4(k4 * cosDeltaPhi - x4 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default3(rotate) {
  rotate = rotateRadians3(rotate[0] * radians4, rotate[1] * radians4, rotate.length > 2 ? rotate[2] * radians4 : 0);
  function forward(coordinates2) {
    coordinates2 = rotate(coordinates2[0] * radians4, coordinates2[1] * radians4);
    return coordinates2[0] *= degrees4, coordinates2[1] *= degrees4, coordinates2;
  }
  forward.invert = function(coordinates2) {
    coordinates2 = rotate.invert(coordinates2[0] * radians4, coordinates2[1] * radians4);
    return coordinates2[0] *= degrees4, coordinates2[1] *= degrees4, coordinates2;
  };
  return forward;
}
var init_rotation3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/rotation.js"() {
    init_compose3();
    init_math5();
    rotationIdentity3.invert = rotationIdentity3;
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/circle.js
function circleStream3(stream, radius, delta, direction, t0, t1) {
  if (!delta)
    return;
  var cosRadius = cos4(radius), sinRadius = sin4(radius), step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau4;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius3(cosRadius, t0);
    t1 = circleRadius3(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1)
      t0 += direction * tau4;
  }
  for (var point5, t2 = t0; direction > 0 ? t2 > t1 : t2 < t1; t2 -= step) {
    point5 = spherical4([cosRadius, -sinRadius * cos4(t2), -sinRadius * sin4(t2)]);
    stream.point(point5[0], point5[1]);
  }
}
function circleRadius3(cosRadius, point5) {
  point5 = cartesian4(point5), point5[0] -= cosRadius;
  cartesianNormalizeInPlace3(point5);
  var radius = acos4(-point5[1]);
  return ((-point5[2] < 0 ? -radius : radius) + tau4 - epsilon7) % tau4;
}
var init_circle5 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/circle.js"() {
    init_cartesian3();
    init_constant5();
    init_math5();
    init_rotation3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/buffer.js
function buffer_default3() {
  var lines2 = [], line;
  return {
    point: function(x4, y4, m2) {
      line.push([x4, y4, m2]);
    },
    lineStart: function() {
      lines2.push(line = []);
    },
    lineEnd: noop3,
    rejoin: function() {
      if (lines2.length > 1)
        lines2.push(lines2.pop().concat(lines2.shift()));
    },
    result: function() {
      var result = lines2;
      lines2 = [];
      line = null;
      return result;
    }
  };
}
var init_buffer3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/buffer.js"() {
    init_noop4();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/pointEqual.js
function pointEqual_default3(a3, b2) {
  return abs4(a3[0] - b2[0]) < epsilon7 && abs4(a3[1] - b2[1]) < epsilon7;
}
var init_pointEqual3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/pointEqual.js"() {
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/rejoin.js
function Intersection3(point5, points2, other, entry) {
  this.x = point5;
  this.z = points2;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default2(segments, compareIntersection4, startInside, interpolate, stream) {
  var subject = [], clip = [], i2, n2;
  segments.forEach(function(segment) {
    if ((n3 = segment.length - 1) <= 0)
      return;
    var n3, p03 = segment[0], p1 = segment[n3], x4;
    if (pointEqual_default3(p03, p1)) {
      if (!p03[2] && !p1[2]) {
        stream.lineStart();
        for (i2 = 0; i2 < n3; ++i2)
          stream.point((p03 = segment[i2])[0], p03[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon7;
    }
    subject.push(x4 = new Intersection3(p03, segment, null, true));
    clip.push(x4.o = new Intersection3(p03, null, x4, false));
    subject.push(x4 = new Intersection3(p1, segment, null, false));
    clip.push(x4.o = new Intersection3(p1, null, x4, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection4);
  link3(subject);
  link3(clip);
  for (i2 = 0, n2 = clip.length; i2 < n2; ++i2) {
    clip[i2].e = startInside = !startInside;
  }
  var start = subject[0], points2, point5;
  while (1) {
    var current = start, isSubject = true;
    while (current.v)
      if ((current = current.n) === start)
        return;
    points2 = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i2 = 0, n2 = points2.length; i2 < n2; ++i2)
            stream.point((point5 = points2[i2])[0], point5[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points2 = current.p.z;
          for (i2 = points2.length - 1; i2 >= 0; --i2)
            stream.point((point5 = points2[i2])[0], point5[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points2 = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link3(array3) {
  if (!(n2 = array3.length))
    return;
  var n2, i2 = 0, a3 = array3[0], b2;
  while (++i2 < n2) {
    a3.n = b2 = array3[i2];
    b2.p = a3;
    a3 = b2;
  }
  a3.n = b2 = array3[0];
  b2.p = a3;
}
var init_rejoin2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/rejoin.js"() {
    init_pointEqual3();
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/polygonContains.js
function longitude3(point5) {
  if (abs4(point5[0]) <= pi4)
    return point5[0];
  else
    return sign4(point5[0]) * ((abs4(point5[0]) + pi4) % tau4 - pi4);
}
function polygonContains_default3(polygon, point5) {
  var lambda = longitude3(point5), phi2 = point5[1], sinPhi = sin4(phi2), normal = [sin4(lambda), -cos4(lambda), 0], angle5 = 0, winding = 0;
  var sum5 = new Adder3();
  if (sinPhi === 1)
    phi2 = halfPi4 + epsilon7;
  else if (sinPhi === -1)
    phi2 = -halfPi4 - epsilon7;
  for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
    if (!(m2 = (ring = polygon[i2]).length))
      continue;
    var ring, m2, point0 = ring[m2 - 1], lambda06 = longitude3(point0), phi04 = point0[1] / 2 + quarterPi4, sinPhi04 = sin4(phi04), cosPhi04 = cos4(phi04);
    for (var j2 = 0; j2 < m2; ++j2, lambda06 = lambda13, sinPhi04 = sinPhi1, cosPhi04 = cosPhi1, point0 = point1) {
      var point1 = ring[j2], lambda13 = longitude3(point1), phi13 = point1[1] / 2 + quarterPi4, sinPhi1 = sin4(phi13), cosPhi1 = cos4(phi13), delta = lambda13 - lambda06, sign6 = delta >= 0 ? 1 : -1, absDelta = sign6 * delta, antimeridian = absDelta > pi4, k4 = sinPhi04 * sinPhi1;
      sum5.add(atan24(k4 * sign6 * sin4(absDelta), cosPhi04 * cosPhi1 + k4 * cos4(absDelta)));
      angle5 += antimeridian ? delta + sign6 * tau4 : delta;
      if (antimeridian ^ lambda06 >= lambda ^ lambda13 >= lambda) {
        var arc = cartesianCross3(cartesian4(point0), cartesian4(point1));
        cartesianNormalizeInPlace3(arc);
        var intersection2 = cartesianCross3(normal, arc);
        cartesianNormalizeInPlace3(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin4(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle5 < -epsilon7 || angle5 < epsilon7 && sum5 < -epsilon24) ^ winding & 1;
}
var init_polygonContains3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/polygonContains.js"() {
    init_src4();
    init_cartesian3();
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/index.js
function clip_default3(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default3(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point5;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default3(polygon, start);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default2(segments, compareIntersection3, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point5(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point5;
      line.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i2, n2 = ringSegments.length, m2, segment, point6;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n2)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i2 = 0; i2 < m2; ++i2)
            sink.point((point6 = segment[i2])[0], point6[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n2 > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment3));
    }
    return clip;
  };
}
function validSegment3(segment) {
  return segment.length > 1;
}
function compareIntersection3(a3, b2) {
  return ((a3 = a3.x)[0] < 0 ? a3[1] - halfPi4 - epsilon7 : halfPi4 - a3[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi4 - epsilon7 : halfPi4 - b2[1]);
}
var init_clip3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/index.js"() {
    init_buffer3();
    init_rejoin2();
    init_math5();
    init_polygonContains3();
    init_src4();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/antimeridian.js
function clipAntimeridianLine3(stream) {
  var lambda06 = NaN, phi04 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda13, phi13) {
      var sign1 = lambda13 > 0 ? pi4 : -pi4, delta = abs4(lambda13 - lambda06);
      if (abs4(delta - pi4) < epsilon7) {
        stream.point(lambda06, phi04 = (phi04 + phi13) / 2 > 0 ? halfPi4 : -halfPi4);
        stream.point(sign0, phi04);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi04);
        stream.point(lambda13, phi04);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi4) {
        if (abs4(lambda06 - sign0) < epsilon7)
          lambda06 -= sign0 * epsilon7;
        if (abs4(lambda13 - sign1) < epsilon7)
          lambda13 -= sign1 * epsilon7;
        phi04 = clipAntimeridianIntersect3(lambda06, phi04, lambda13, phi13);
        stream.point(sign0, phi04);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi04);
        clean = 0;
      }
      stream.point(lambda06 = lambda13, phi04 = phi13);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda06 = phi04 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect3(lambda06, phi04, lambda13, phi13) {
  var cosPhi04, cosPhi1, sinLambda0Lambda1 = sin4(lambda06 - lambda13);
  return abs4(sinLambda0Lambda1) > epsilon7 ? atan5((sin4(phi04) * (cosPhi1 = cos4(phi13)) * sin4(lambda13) - sin4(phi13) * (cosPhi04 = cos4(phi04)) * sin4(lambda06)) / (cosPhi04 * cosPhi1 * sinLambda0Lambda1)) : (phi04 + phi13) / 2;
}
function clipAntimeridianInterpolate3(from, to, direction, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi4;
    stream.point(-pi4, phi2);
    stream.point(0, phi2);
    stream.point(pi4, phi2);
    stream.point(pi4, 0);
    stream.point(pi4, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi4, -phi2);
    stream.point(-pi4, 0);
    stream.point(-pi4, phi2);
  } else if (abs4(from[0] - to[0]) > epsilon7) {
    var lambda = from[0] < to[0] ? pi4 : -pi4;
    phi2 = direction * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}
var antimeridian_default3;
var init_antimeridian3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/antimeridian.js"() {
    init_clip3();
    init_math5();
    antimeridian_default3 = clip_default3(function() {
      return true;
    }, clipAntimeridianLine3, clipAntimeridianInterpolate3, [-pi4, -halfPi4]);
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/circle.js
function circle_default5(radius) {
  var cr = cos4(radius), delta = 6 * radians4, smallRadius = cr > 0, notHemisphere = abs4(cr) > epsilon7;
  function interpolate(from, to, direction, stream) {
    circleStream3(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos4(lambda) * cos4(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v2 = visible(lambda, phi2), c2 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi4 : -pi4), phi2) : 0;
        if (!point0 && (v00 = v0 = v2))
          stream.lineStart();
        if (v2 !== v0) {
          point22 = intersect(point0, point1);
          if (!point22 || pointEqual_default3(point0, point22) || pointEqual_default3(point1, point22))
            point1[2] = 1;
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream.lineStart();
            point22 = intersect(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t2;
          if (!(c2 & c0) && (t2 = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t2[0][0], t2[0][1]);
              stream.point(t2[1][0], t2[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t2[1][0], t2[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t2[0][0], t2[0][1], 3);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default3(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c2;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect(a3, b2, two) {
    var pa = cartesian4(a3), pb = cartesian4(b2);
    var n1 = [1, 0, 0], n2 = cartesianCross3(pa, pb), n2n2 = cartesianDot3(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a3;
    var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross3(n1, n2), A6 = cartesianScale3(n1, c1), B3 = cartesianScale3(n2, c2);
    cartesianAddInPlace3(A6, B3);
    var u2 = n1xn2, w3 = cartesianDot3(A6, u2), uu = cartesianDot3(u2, u2), t2 = w3 * w3 - uu * (cartesianDot3(A6, A6) - 1);
    if (t2 < 0)
      return;
    var t3 = sqrt4(t2), q2 = cartesianScale3(u2, (-w3 - t3) / uu);
    cartesianAddInPlace3(q2, A6);
    q2 = spherical4(q2);
    if (!two)
      return q2;
    var lambda06 = a3[0], lambda13 = b2[0], phi04 = a3[1], phi13 = b2[1], z2;
    if (lambda13 < lambda06)
      z2 = lambda06, lambda06 = lambda13, lambda13 = z2;
    var delta2 = lambda13 - lambda06, polar = abs4(delta2 - pi4) < epsilon7, meridian = polar || delta2 < epsilon7;
    if (!polar && phi13 < phi04)
      z2 = phi04, phi04 = phi13, phi13 = z2;
    if (meridian ? polar ? phi04 + phi13 > 0 ^ q2[1] < (abs4(q2[0] - lambda06) < epsilon7 ? phi04 : phi13) : phi04 <= q2[1] && q2[1] <= phi13 : delta2 > pi4 ^ (lambda06 <= q2[0] && q2[0] <= lambda13)) {
      var q1 = cartesianScale3(u2, (-w3 + t3) / uu);
      cartesianAddInPlace3(q1, A6);
      return [q2, spherical4(q1)];
    }
  }
  function code(lambda, phi2) {
    var r2 = smallRadius ? radius : pi4 - radius, code2 = 0;
    if (lambda < -r2)
      code2 |= 1;
    else if (lambda > r2)
      code2 |= 2;
    if (phi2 < -r2)
      code2 |= 4;
    else if (phi2 > r2)
      code2 |= 8;
    return code2;
  }
  return clip_default3(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi4, radius - pi4]);
}
var init_circle6 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/circle.js"() {
    init_cartesian3();
    init_circle5();
    init_math5();
    init_pointEqual3();
    init_clip3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/line.js
function line_default3(a3, b2, x011, y011, x16, y16) {
  var ax = a3[0], ay = a3[1], bx = b2[0], by = b2[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x011 - ax;
  if (!dx && r2 > 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  } else if (dx > 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  }
  r2 = x16 - ax;
  if (!dx && r2 < 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  } else if (dx > 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  }
  r2 = y011 - ay;
  if (!dy && r2 > 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  } else if (dy > 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  }
  r2 = y16 - ay;
  if (!dy && r2 < 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  } else if (dy > 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  }
  if (t0 > 0)
    a3[0] = ax + t0 * dx, a3[1] = ay + t0 * dy;
  if (t1 < 1)
    b2[0] = ax + t1 * dx, b2[1] = ay + t1 * dy;
  return true;
}
var init_line3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/line.js"() {
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/rectangle.js
function clipRectangle2(x011, y011, x16, y16) {
  function visible(x4, y4) {
    return x011 <= x4 && x4 <= x16 && y011 <= y4 && y4 <= y16;
  }
  function interpolate(from, to, direction, stream) {
    var a3 = 0, a1 = 0;
    if (from == null || (a3 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a3 === 0 || a3 === 3 ? x011 : x16, a3 > 1 ? y16 : y011);
      while ((a3 = (a3 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p2, direction) {
    return abs4(p2[0] - x011) < epsilon7 ? direction > 0 ? 0 : 3 : abs4(p2[0] - x16) < epsilon7 ? direction > 0 ? 2 : 1 : abs4(p2[1] - y011) < epsilon7 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection4(a3, b2) {
    return comparePoint(a3.x, b2.x);
  }
  function comparePoint(a3, b2) {
    var ca = corner(a3, 1), cb = corner(b2, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a3[1] : ca === 1 ? a3[0] - b2[0] : ca === 2 ? a3[1] - b2[1] : b2[0] - a3[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default3(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point5(x4, y4) {
      if (visible(x4, y4))
        activeStream.point(x4, y4);
    }
    function polygonInside() {
      var winding = 0;
      for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
        for (var ring2 = polygon[i2], j2 = 1, m2 = ring2.length, point6 = ring2[0], a0, a1, b0 = point6[0], b1 = point6[1]; j2 < m2; ++j2) {
          a0 = b0, a1 = b1, point6 = ring2[j2], b0 = point6[0], b1 = point6[1];
          if (a1 <= y16) {
            if (b1 > y16 && (b0 - a0) * (y16 - a1) > (b1 - a1) * (x011 - a0))
              ++winding;
          } else {
            if (b1 <= y16 && (b0 - a0) * (y16 - a1) < (b1 - a1) * (x011 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default2(segments, compareIntersection4, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint3;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint3(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point5;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint3(x4, y4) {
      var v2 = visible(x4, y4);
      if (polygon)
        ring.push([x4, y4]);
      if (first) {
        x__ = x4, y__ = y4, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x4, y4);
        }
      } else {
        if (v2 && v_)
          activeStream.point(x4, y4);
        else {
          var a3 = [x_ = Math.max(clipMin3, Math.min(clipMax3, x_)), y_ = Math.max(clipMin3, Math.min(clipMax3, y_))], b2 = [x4 = Math.max(clipMin3, Math.min(clipMax3, x4)), y4 = Math.max(clipMin3, Math.min(clipMax3, y4))];
          if (line_default3(a3, b2, x011, y011, x16, y16)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a3[0], a3[1]);
            }
            activeStream.point(b2[0], b2[1]);
            if (!v2)
              activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x4, y4);
            clean = false;
          }
        }
      }
      x_ = x4, y_ = y4, v_ = v2;
    }
    return clipStream;
  };
}
var clipMax3, clipMin3;
var init_rectangle2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/rectangle.js"() {
    init_math5();
    init_buffer3();
    init_line3();
    init_rejoin2();
    init_src4();
    clipMax3 = 1e9;
    clipMin3 = -clipMax3;
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/extent.js
var init_extent5 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/clip/extent.js"() {
    init_rectangle2();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/length.js
var init_length3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/length.js"() {
    init_src4();
    init_math5();
    init_noop4();
    init_stream3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/distance.js
var init_distance3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/distance.js"() {
    init_length3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/contains.js
var init_contains4 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/contains.js"() {
    init_polygonContains3();
    init_distance3();
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/graticule.js
var init_graticule3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/graticule.js"() {
    init_src4();
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/interpolate.js
var init_interpolate3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/interpolate.js"() {
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/identity.js
var identity_default7;
var init_identity7 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/identity.js"() {
    identity_default7 = (x4) => x4;
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/path/area.js
var areaSum6, areaRingSum6;
var init_area6 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/path/area.js"() {
    init_src4();
    init_math5();
    init_noop4();
    areaSum6 = new Adder3();
    areaRingSum6 = new Adder3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/path/bounds.js
function boundsPoint5(x4, y4) {
  if (x4 < x09)
    x09 = x4;
  if (x4 > x14)
    x14 = x4;
  if (y4 < y09)
    y09 = y4;
  if (y4 > y14)
    y14 = y4;
}
var x09, y09, x14, y14, boundsStream5, bounds_default5;
var init_bounds6 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/path/bounds.js"() {
    init_noop4();
    x09 = Infinity;
    y09 = x09;
    x14 = -x09;
    y14 = x14;
    boundsStream5 = {
      point: boundsPoint5,
      lineStart: noop3,
      lineEnd: noop3,
      polygonStart: noop3,
      polygonEnd: noop3,
      result: function() {
        var bounds = [[x09, y09], [x14, y14]];
        x14 = y14 = -(y09 = x09 = Infinity);
        return bounds;
      }
    };
    bounds_default5 = boundsStream5;
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/path/centroid.js
var init_centroid6 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/path/centroid.js"() {
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/path/context.js
function PathContext3(context) {
  this._context = context;
}
var init_context3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/path/context.js"() {
    init_math5();
    init_noop4();
    PathContext3.prototype = {
      _radius: 4.5,
      pointRadius: function(_2) {
        return this._radius = _2, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._context.closePath();
        this._point = NaN;
      },
      point: function(x4, y4) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x4, y4);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x4, y4);
            break;
          }
          default: {
            this._context.moveTo(x4 + this._radius, y4);
            this._context.arc(x4, y4, this._radius, 0, tau4);
            break;
          }
        }
      },
      result: noop3
    };
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/path/measure.js
var lengthSum5;
var init_measure3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/path/measure.js"() {
    init_src4();
    init_math5();
    init_noop4();
    lengthSum5 = new Adder3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/path/string.js
function PathString3() {
  this._string = [];
}
function circle3(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}
var init_string3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/path/string.js"() {
    PathString3.prototype = {
      _radius: 4.5,
      _circle: circle3(4.5),
      pointRadius: function(_2) {
        if ((_2 = +_2) !== this._radius)
          this._radius = _2, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._string.push("Z");
        this._point = NaN;
      },
      point: function(x4, y4) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x4, ",", y4);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x4, ",", y4);
            break;
          }
          default: {
            if (this._circle == null)
              this._circle = circle3(this._radius);
            this._string.push("M", x4, ",", y4, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/path/index.js
var init_path3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/path/index.js"() {
    init_identity7();
    init_stream3();
    init_area6();
    init_bounds6();
    init_centroid6();
    init_context3();
    init_measure3();
    init_string3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/transform.js
function transformer3(methods) {
  return function(stream) {
    var s3 = new TransformStream3();
    for (var key in methods)
      s3[key] = methods[key];
    s3.stream = stream;
    return s3;
  };
}
function TransformStream3() {
}
var init_transform3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/transform.js"() {
    TransformStream3.prototype = {
      constructor: TransformStream3,
      point: function(x4, y4) {
        this.stream.point(x4, y4);
      },
      sphere: function() {
        this.stream.sphere();
      },
      lineStart: function() {
        this.stream.lineStart();
      },
      lineEnd: function() {
        this.stream.lineEnd();
      },
      polygonStart: function() {
        this.stream.polygonStart();
      },
      polygonEnd: function() {
        this.stream.polygonEnd();
      }
    };
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/fit.js
function fit2(projection4, fitBounds, object3) {
  var clip = projection4.clipExtent && projection4.clipExtent();
  projection4.scale(150).translate([0, 0]);
  if (clip != null)
    projection4.clipExtent(null);
  stream_default3(object3, projection4.stream(bounds_default5));
  fitBounds(bounds_default5.result());
  if (clip != null)
    projection4.clipExtent(clip);
  return projection4;
}
function fitExtent3(projection4, extent, object3) {
  return fit2(projection4, function(b2) {
    var w3 = extent[1][0] - extent[0][0], h2 = extent[1][1] - extent[0][1], k4 = Math.min(w3 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x4 = +extent[0][0] + (w3 - k4 * (b2[1][0] + b2[0][0])) / 2, y4 = +extent[0][1] + (h2 - k4 * (b2[1][1] + b2[0][1])) / 2;
    projection4.scale(150 * k4).translate([x4, y4]);
  }, object3);
}
function fitSize3(projection4, size, object3) {
  return fitExtent3(projection4, [[0, 0], size], object3);
}
function fitWidth2(projection4, width, object3) {
  return fit2(projection4, function(b2) {
    var w3 = +width, k4 = w3 / (b2[1][0] - b2[0][0]), x4 = (w3 - k4 * (b2[1][0] + b2[0][0])) / 2, y4 = -k4 * b2[0][1];
    projection4.scale(150 * k4).translate([x4, y4]);
  }, object3);
}
function fitHeight2(projection4, height, object3) {
  return fit2(projection4, function(b2) {
    var h2 = +height, k4 = h2 / (b2[1][1] - b2[0][1]), x4 = -k4 * b2[0][0], y4 = (h2 - k4 * (b2[1][1] + b2[0][1])) / 2;
    projection4.scale(150 * k4).translate([x4, y4]);
  }, object3);
}
var init_fit3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/fit.js"() {
    init_stream3();
    init_bounds6();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/resample.js
function resample_default3(project, delta2) {
  return +delta2 ? resample3(project, delta2) : resampleNone3(project);
}
function resampleNone3(project) {
  return transformer3({
    point: function(x4, y4) {
      x4 = project(x4, y4);
      this.stream.point(x4[0], x4[1]);
    }
  });
}
function resample3(project, delta2) {
  function resampleLineTo(x011, y011, lambda06, a0, b0, c0, x16, y16, lambda13, a1, b1, c1, depth, stream) {
    var dx = x16 - x011, dy = y16 - y011, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a3 = a0 + a1, b2 = b0 + b1, c2 = c0 + c1, m2 = sqrt4(a3 * a3 + b2 * b2 + c2 * c2), phi2 = asin4(c2 /= m2), lambda23 = abs4(abs4(c2) - 1) < epsilon7 || abs4(lambda06 - lambda13) < epsilon7 ? (lambda06 + lambda13) / 2 : atan24(b2, a3), p2 = project(lambda23, phi2), x22 = p2[0], y22 = p2[1], dx2 = x22 - x011, dy2 = y22 - y011, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs4((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance3) {
        resampleLineTo(x011, y011, lambda06, a0, b0, c0, x22, y22, lambda23, a3 /= m2, b2 /= m2, c2, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda23, a3, b2, c2, x16, y16, lambda13, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda007, x004, y004, a00, b00, c00, lambda06, x011, y011, a0, b0, c0;
    var resampleStream = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point5(x4, y4) {
      x4 = project(x4, y4);
      stream.point(x4[0], x4[1]);
    }
    function lineStart() {
      x011 = NaN;
      resampleStream.point = linePoint3;
      stream.lineStart();
    }
    function linePoint3(lambda, phi2) {
      var c2 = cartesian4([lambda, phi2]), p2 = project(lambda, phi2);
      resampleLineTo(x011, y011, lambda06, a0, b0, c0, x011 = p2[0], y011 = p2[1], lambda06 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth3, stream);
      stream.point(x011, y011);
    }
    function lineEnd() {
      resampleStream.point = point5;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint3(lambda007 = lambda, phi2), x004 = x011, y004 = y011, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint3;
    }
    function ringEnd() {
      resampleLineTo(x011, y011, lambda06, a0, b0, c0, x004, y004, lambda007, a00, b00, c00, maxDepth3, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}
var maxDepth3, cosMinDistance3;
var init_resample3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/resample.js"() {
    init_cartesian3();
    init_math5();
    init_transform3();
    maxDepth3 = 16;
    cosMinDistance3 = cos4(30 * radians4);
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/index.js
function transformRotate2(rotate) {
  return transformer3({
    point: function(x4, y4) {
      var r2 = rotate(x4, y4);
      return this.stream.point(r2[0], r2[1]);
    }
  });
}
function scaleTranslate3(k4, dx, dy, sx, sy) {
  function transform(x4, y4) {
    x4 *= sx;
    y4 *= sy;
    return [dx + k4 * x4, dy - k4 * y4];
  }
  transform.invert = function(x4, y4) {
    return [(x4 - dx) / k4 * sx, (dy - y4) / k4 * sy];
  };
  return transform;
}
function scaleTranslateRotate2(k4, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate3(k4, dx, dy, sx, sy);
  var cosAlpha = cos4(alpha), sinAlpha = sin4(alpha), a3 = cosAlpha * k4, b2 = sinAlpha * k4, ai = cosAlpha / k4, bi = sinAlpha / k4, ci = (sinAlpha * dy - cosAlpha * dx) / k4, fi = (sinAlpha * dx + cosAlpha * dy) / k4;
  function transform(x4, y4) {
    x4 *= sx;
    y4 *= sy;
    return [a3 * x4 - b2 * y4 + dx, dy - b2 * x4 - a3 * y4];
  }
  transform.invert = function(x4, y4) {
    return [sx * (ai * x4 - bi * y4 + ci), sy * (fi - bi * x4 - ai * y4)];
  };
  return transform;
}
function projection3(project) {
  return projectionMutator3(function() {
    return project;
  })();
}
function projectionMutator3(projectAt) {
  var project, k4 = 150, x4 = 480, y4 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default3, x011 = null, y011, x16, y16, postclip = identity_default7, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection4(point5) {
    return projectRotateTransform(point5[0] * radians4, point5[1] * radians4);
  }
  function invert(point5) {
    point5 = projectRotateTransform.invert(point5[0], point5[1]);
    return point5 && [point5[0] * degrees4, point5[1] * degrees4];
  }
  projection4.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians3(transformRotate2(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection4.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
  };
  projection4.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x011 = y011 = x16 = y16 = null, reset()) : postclip;
  };
  projection4.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? circle_default5(theta = _2 * radians4) : (theta = null, antimeridian_default3), reset()) : theta * degrees4;
  };
  projection4.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x011 = y011 = x16 = y16 = null, identity_default7) : clipRectangle2(x011 = +_2[0][0], y011 = +_2[0][1], x16 = +_2[1][0], y16 = +_2[1][1]), reset()) : x011 == null ? null : [[x011, y011], [x16, y16]];
  };
  projection4.scale = function(_2) {
    return arguments.length ? (k4 = +_2, recenter()) : k4;
  };
  projection4.translate = function(_2) {
    return arguments.length ? (x4 = +_2[0], y4 = +_2[1], recenter()) : [x4, y4];
  };
  projection4.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians4, phi2 = _2[1] % 360 * radians4, recenter()) : [lambda * degrees4, phi2 * degrees4];
  };
  projection4.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians4, deltaPhi = _2[1] % 360 * radians4, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians4 : 0, recenter()) : [deltaLambda * degrees4, deltaPhi * degrees4, deltaGamma * degrees4];
  };
  projection4.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians4, recenter()) : alpha * degrees4;
  };
  projection4.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection4.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection4.precision = function(_2) {
    return arguments.length ? (projectResample = resample_default3(projectTransform, delta2 = _2 * _2), reset()) : sqrt4(delta2);
  };
  projection4.fitExtent = function(extent, object3) {
    return fitExtent3(projection4, extent, object3);
  };
  projection4.fitSize = function(size, object3) {
    return fitSize3(projection4, size, object3);
  };
  projection4.fitWidth = function(width, object3) {
    return fitWidth2(projection4, width, object3);
  };
  projection4.fitHeight = function(height, object3) {
    return fitHeight2(projection4, height, object3);
  };
  function recenter() {
    var center2 = scaleTranslateRotate2(k4, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform = scaleTranslateRotate2(k4, x4 - center2[0], y4 - center2[1], sx, sy, alpha);
    rotate = rotateRadians3(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default3(project, transform);
    projectRotateTransform = compose_default3(rotate, projectTransform);
    projectResample = resample_default3(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection4;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection4.invert = project.invert && invert;
    return recenter();
  };
}
var transformRadians3;
var init_projection3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/index.js"() {
    init_antimeridian3();
    init_circle6();
    init_rectangle2();
    init_compose3();
    init_identity7();
    init_math5();
    init_rotation3();
    init_transform3();
    init_fit3();
    init_resample3();
    transformRadians3 = transformer3({
      point: function(x4, y4) {
        this.stream.point(x4 * radians4, y4 * radians4);
      }
    });
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/conic.js
function conicProjection3(projectAt) {
  var phi04 = 0, phi13 = pi4 / 3, m2 = projectionMutator3(projectAt), p2 = m2(phi04, phi13);
  p2.parallels = function(_2) {
    return arguments.length ? m2(phi04 = _2[0] * radians4, phi13 = _2[1] * radians4) : [phi04 * degrees4, phi13 * degrees4];
  };
  return p2;
}
var init_conic3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/conic.js"() {
    init_math5();
    init_projection3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw4(phi04) {
  var cosPhi04 = cos4(phi04);
  function forward(lambda, phi2) {
    return [lambda * cosPhi04, sin4(phi2) / cosPhi04];
  }
  forward.invert = function(x4, y4) {
    return [x4 / cosPhi04, asin4(y4 * cosPhi04)];
  };
  return forward;
}
var init_cylindricalEqualArea4 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/cylindricalEqualArea.js"() {
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw3(y011, y16) {
  var sy0 = sin4(y011), n2 = (sy0 + sin4(y16)) / 2;
  if (abs4(n2) < epsilon7)
    return cylindricalEqualAreaRaw4(y011);
  var c2 = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt4(c2) / n2;
  function project(x4, y4) {
    var r2 = sqrt4(c2 - 2 * n2 * sin4(y4)) / n2;
    return [r2 * sin4(x4 *= n2), r0 - r2 * cos4(x4)];
  }
  project.invert = function(x4, y4) {
    var r0y = r0 - y4, l2 = atan24(x4, abs4(r0y)) * sign4(r0y);
    if (r0y * n2 < 0)
      l2 -= pi4 * sign4(x4) * sign4(r0y);
    return [l2 / n2, asin4((c2 - (x4 * x4 + r0y * r0y) * n2 * n2) / (2 * n2))];
  };
  return project;
}
function conicEqualArea_default3() {
  return conicProjection3(conicEqualAreaRaw3).scale(155.424).center([0, 33.6442]);
}
var init_conicEqualArea3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/conicEqualArea.js"() {
    init_math5();
    init_conic3();
    init_cylindricalEqualArea4();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/albers.js
function albers_default3() {
  return conicEqualArea_default3().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
var init_albers3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/albers.js"() {
    init_conicEqualArea3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/albersUsa.js
var init_albersUsa3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/albersUsa.js"() {
    init_math5();
    init_albers3();
    init_conicEqualArea3();
    init_fit3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw3(scale) {
  return function(x4, y4) {
    var cx = cos4(x4), cy = cos4(y4), k4 = scale(cx * cy);
    if (k4 === Infinity)
      return [2, 0];
    return [
      k4 * cy * sin4(x4),
      k4 * sin4(y4)
    ];
  };
}
function azimuthalInvert3(angle5) {
  return function(x4, y4) {
    var z2 = sqrt4(x4 * x4 + y4 * y4), c2 = angle5(z2), sc = sin4(c2), cc = cos4(c2);
    return [
      atan24(x4 * sc, z2 * cc),
      asin4(z2 && y4 * sc / z2)
    ];
  };
}
var init_azimuthal3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/azimuthal.js"() {
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw3;
var init_azimuthalEqualArea3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/azimuthalEqualArea.js"() {
    init_math5();
    init_azimuthal3();
    init_projection3();
    azimuthalEqualAreaRaw3 = azimuthalRaw3(function(cxcy) {
      return sqrt4(2 / (1 + cxcy));
    });
    azimuthalEqualAreaRaw3.invert = azimuthalInvert3(function(z2) {
      return 2 * asin4(z2 / 2);
    });
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw3;
var init_azimuthalEquidistant3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/azimuthalEquidistant.js"() {
    init_math5();
    init_azimuthal3();
    init_projection3();
    azimuthalEquidistantRaw3 = azimuthalRaw3(function(c2) {
      return (c2 = acos4(c2)) && c2 / sin4(c2);
    });
    azimuthalEquidistantRaw3.invert = azimuthalInvert3(function(z2) {
      return z2;
    });
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw3(lambda, phi2) {
  return [lambda, log4(tan4((halfPi4 + phi2) / 2))];
}
function mercator_default3() {
  return mercatorProjection3(mercatorRaw3).scale(961 / tau4);
}
function mercatorProjection3(project) {
  var m2 = projection3(project), center2 = m2.center, scale = m2.scale, translate = m2.translate, clipExtent2 = m2.clipExtent, x011 = null, y011, x16, y16;
  m2.scale = function(_2) {
    return arguments.length ? (scale(_2), reclip()) : scale();
  };
  m2.translate = function(_2) {
    return arguments.length ? (translate(_2), reclip()) : translate();
  };
  m2.center = function(_2) {
    return arguments.length ? (center2(_2), reclip()) : center2();
  };
  m2.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x011 = y011 = x16 = y16 = null : (x011 = +_2[0][0], y011 = +_2[0][1], x16 = +_2[1][0], y16 = +_2[1][1]), reclip()) : x011 == null ? null : [[x011, y011], [x16, y16]];
  };
  function reclip() {
    var k4 = pi4 * scale(), t2 = m2(rotation_default3(m2.rotate()).invert([0, 0]));
    return clipExtent2(x011 == null ? [[t2[0] - k4, t2[1] - k4], [t2[0] + k4, t2[1] + k4]] : project === mercatorRaw3 ? [[Math.max(t2[0] - k4, x011), y011], [Math.min(t2[0] + k4, x16), y16]] : [[x011, Math.max(t2[1] - k4, y011)], [x16, Math.min(t2[1] + k4, y16)]]);
  }
  return reclip();
}
var init_mercator3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/mercator.js"() {
    init_math5();
    init_rotation3();
    init_projection3();
    mercatorRaw3.invert = function(x4, y4) {
      return [x4, 2 * atan5(exp4(y4)) - halfPi4];
    };
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/conicConformal.js
function tany2(y4) {
  return tan4((halfPi4 + y4) / 2);
}
function conicConformalRaw3(y011, y16) {
  var cy0 = cos4(y011), n2 = y011 === y16 ? sin4(y011) : log4(cy0 / cos4(y16)) / log4(tany2(y16) / tany2(y011)), f2 = cy0 * pow4(tany2(y011), n2) / n2;
  if (!n2)
    return mercatorRaw3;
  function project(x4, y4) {
    if (f2 > 0) {
      if (y4 < -halfPi4 + epsilon7)
        y4 = -halfPi4 + epsilon7;
    } else {
      if (y4 > halfPi4 - epsilon7)
        y4 = halfPi4 - epsilon7;
    }
    var r2 = f2 / pow4(tany2(y4), n2);
    return [r2 * sin4(n2 * x4), f2 - r2 * cos4(n2 * x4)];
  }
  project.invert = function(x4, y4) {
    var fy = f2 - y4, r2 = sign4(n2) * sqrt4(x4 * x4 + fy * fy), l2 = atan24(x4, abs4(fy)) * sign4(fy);
    if (fy * n2 < 0)
      l2 -= pi4 * sign4(x4) * sign4(fy);
    return [l2 / n2, 2 * atan5(pow4(f2 / r2, 1 / n2)) - halfPi4];
  };
  return project;
}
function conicConformal_default3() {
  return conicProjection3(conicConformalRaw3).scale(109.5).parallels([30, 30]);
}
var init_conicConformal3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/conicConformal.js"() {
    init_math5();
    init_conic3();
    init_mercator3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw3(lambda, phi2) {
  return [lambda, phi2];
}
function equirectangular_default3() {
  return projection3(equirectangularRaw3).scale(152.63);
}
var init_equirectangular3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/equirectangular.js"() {
    init_projection3();
    equirectangularRaw3.invert = equirectangularRaw3;
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw3(y011, y16) {
  var cy0 = cos4(y011), n2 = y011 === y16 ? sin4(y011) : (cy0 - cos4(y16)) / (y16 - y011), g2 = cy0 / n2 + y011;
  if (abs4(n2) < epsilon7)
    return equirectangularRaw3;
  function project(x4, y4) {
    var gy = g2 - y4, nx = n2 * x4;
    return [gy * sin4(nx), g2 - gy * cos4(nx)];
  }
  project.invert = function(x4, y4) {
    var gy = g2 - y4, l2 = atan24(x4, abs4(gy)) * sign4(gy);
    if (gy * n2 < 0)
      l2 -= pi4 * sign4(x4) * sign4(gy);
    return [l2 / n2, g2 - sign4(n2) * sqrt4(x4 * x4 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default3() {
  return conicProjection3(conicEquidistantRaw3).scale(131.154).center([0, 13.9389]);
}
var init_conicEquidistant3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/conicEquidistant.js"() {
    init_math5();
    init_conic3();
    init_equirectangular3();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/equalEarth.js
function equalEarthRaw2(lambda, phi2) {
  var l2 = asin4(M2 * sin4(phi2)), l22 = l2 * l2, l6 = l22 * l22 * l22;
  return [
    lambda * cos4(l2) / (M2 * (A12 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A42 * l22))),
    l2 * (A12 + A22 * l22 + l6 * (A32 + A42 * l22))
  ];
}
var A12, A22, A32, A42, M2, iterations2;
var init_equalEarth2 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/equalEarth.js"() {
    init_projection3();
    init_math5();
    A12 = 1.340264;
    A22 = -0.081106;
    A32 = 893e-6;
    A42 = 3796e-6;
    M2 = sqrt4(3) / 2;
    iterations2 = 12;
    equalEarthRaw2.invert = function(x4, y4) {
      var l2 = y4, l22 = l2 * l2, l6 = l22 * l22 * l22;
      for (var i2 = 0, delta, fy, fpy; i2 < iterations2; ++i2) {
        fy = l2 * (A12 + A22 * l22 + l6 * (A32 + A42 * l22)) - y4;
        fpy = A12 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A42 * l22);
        l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
        if (abs4(delta) < epsilon24)
          break;
      }
      return [
        M2 * x4 * (A12 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A42 * l22)) / cos4(l2),
        asin4(sin4(l2) / M2)
      ];
    };
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw3(x4, y4) {
  var cy = cos4(y4), k4 = cos4(x4) * cy;
  return [cy * sin4(x4) / k4, sin4(y4) / k4];
}
var init_gnomonic3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/gnomonic.js"() {
    init_math5();
    init_azimuthal3();
    init_projection3();
    gnomonicRaw3.invert = azimuthalInvert3(atan5);
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/identity.js
var init_identity8 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/identity.js"() {
    init_rectangle2();
    init_identity7();
    init_transform3();
    init_fit3();
    init_math5();
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw2(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
var init_naturalEarth12 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/naturalEarth1.js"() {
    init_projection3();
    init_math5();
    naturalEarth1Raw2.invert = function(x4, y4) {
      var phi2 = y4, i2 = 25, delta;
      do {
        var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
        phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
      } while (abs4(delta) > epsilon7 && --i2 > 0);
      return [
        x4 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
        phi2
      ];
    };
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw3(x4, y4) {
  return [cos4(y4) * sin4(x4), sin4(y4)];
}
var init_orthographic3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/orthographic.js"() {
    init_math5();
    init_azimuthal3();
    init_projection3();
    orthographicRaw3.invert = azimuthalInvert3(asin4);
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw3(x4, y4) {
  var cy = cos4(y4), k4 = 1 + cos4(x4) * cy;
  return [cy * sin4(x4) / k4, sin4(y4) / k4];
}
function stereographic_default3() {
  return projection3(stereographicRaw3).scale(250).clipAngle(142);
}
var init_stereographic3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/stereographic.js"() {
    init_math5();
    init_azimuthal3();
    init_projection3();
    stereographicRaw3.invert = azimuthalInvert3(function(z2) {
      return 2 * atan5(z2);
    });
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw3(lambda, phi2) {
  return [log4(tan4((halfPi4 + phi2) / 2)), -lambda];
}
function transverseMercator_default3() {
  var m2 = mercatorProjection3(transverseMercatorRaw3), center2 = m2.center, rotate = m2.rotate;
  m2.center = function(_2) {
    return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
  };
  m2.rotate = function(_2) {
    return arguments.length ? rotate([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}
var init_transverseMercator3 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/projection/transverseMercator.js"() {
    init_math5();
    init_mercator3();
    transverseMercatorRaw3.invert = function(x4, y4) {
      return [-y4, 2 * atan5(exp4(x4)) - halfPi4];
    };
  }
});

// node_modules/d3-composite-projections/node_modules/d3-geo/src/index.js
var init_src5 = __esm({
  "node_modules/d3-composite-projections/node_modules/d3-geo/src/index.js"() {
    init_area5();
    init_bounds5();
    init_centroid5();
    init_circle5();
    init_antimeridian3();
    init_circle6();
    init_extent5();
    init_rectangle2();
    init_contains4();
    init_distance3();
    init_graticule3();
    init_interpolate3();
    init_length3();
    init_path3();
    init_albers3();
    init_albersUsa3();
    init_azimuthalEqualArea3();
    init_azimuthalEquidistant3();
    init_conicConformal3();
    init_conicEqualArea3();
    init_conicEquidistant3();
    init_equalEarth2();
    init_equirectangular3();
    init_gnomonic3();
    init_identity8();
    init_projection3();
    init_mercator3();
    init_naturalEarth12();
    init_orthographic3();
    init_stereographic3();
    init_transverseMercator3();
    init_rotation3();
    init_stream3();
    init_transform3();
  }
});

// node_modules/d3-composite-projections/src/bounds.js
function noop4() {
}
function boundsPoint6(x4, y4) {
  if (x4 < x010)
    x010 = x4;
  if (x4 > x15)
    x15 = x4;
  if (y4 < y010)
    y010 = y4;
  if (y4 > y15)
    y15 = y4;
}
var x010, y010, x15, y15, boundsStream6, bounds_default7;
var init_bounds7 = __esm({
  "node_modules/d3-composite-projections/src/bounds.js"() {
    x010 = Infinity;
    y010 = x010;
    x15 = -x010;
    y15 = x15;
    boundsStream6 = {
      point: boundsPoint6,
      lineStart: noop4,
      lineEnd: noop4,
      polygonStart: noop4,
      polygonEnd: noop4,
      result: function() {
        var bounds = [[x010, y010], [x15, y15]];
        x15 = y15 = -(y010 = x010 = Infinity);
        return bounds;
      }
    };
    bounds_default7 = boundsStream6;
  }
});

// node_modules/d3-composite-projections/src/fit.js
function fitExtent4(projection4, extent, object3) {
  var w3 = extent[1][0] - extent[0][0], h2 = extent[1][1] - extent[0][1], clip = projection4.clipExtent && projection4.clipExtent();
  projection4.scale(150).translate([0, 0]);
  if (clip != null)
    projection4.clipExtent(null);
  stream_default3(object3, projection4.stream(bounds_default7));
  var b2 = bounds_default7.result(), k4 = Math.min(w3 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x4 = +extent[0][0] + (w3 - k4 * (b2[1][0] + b2[0][0])) / 2, y4 = +extent[0][1] + (h2 - k4 * (b2[1][1] + b2[0][1])) / 2;
  if (clip != null)
    projection4.clipExtent(clip);
  return projection4.scale(k4 * 150).translate([x4, y4]);
}
function fitSize4(projection4, size, object3) {
  return fitExtent4(projection4, [[0, 0], size], object3);
}
var init_fit4 = __esm({
  "node_modules/d3-composite-projections/src/fit.js"() {
    init_src5();
    init_bounds7();
  }
});

// node_modules/d3-path/src/path.js
function Path() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
var pi5, tau5, epsilon8, tauEpsilon, path_default4;
var init_path4 = __esm({
  "node_modules/d3-path/src/path.js"() {
    pi5 = Math.PI;
    tau5 = 2 * pi5;
    epsilon8 = 1e-6;
    tauEpsilon = tau5 - epsilon8;
    Path.prototype = path.prototype = {
      constructor: Path,
      moveTo: function(x4, y4) {
        this._ += "M" + (this._x0 = this._x1 = +x4) + "," + (this._y0 = this._y1 = +y4);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x4, y4) {
        this._ += "L" + (this._x1 = +x4) + "," + (this._y1 = +y4);
      },
      quadraticCurveTo: function(x16, y16, x4, y4) {
        this._ += "Q" + +x16 + "," + +y16 + "," + (this._x1 = +x4) + "," + (this._y1 = +y4);
      },
      bezierCurveTo: function(x16, y16, x22, y22, x4, y4) {
        this._ += "C" + +x16 + "," + +y16 + "," + +x22 + "," + +y22 + "," + (this._x1 = +x4) + "," + (this._y1 = +y4);
      },
      arcTo: function(x16, y16, x22, y22, r2) {
        x16 = +x16, y16 = +y16, x22 = +x22, y22 = +y22, r2 = +r2;
        var x011 = this._x1, y011 = this._y1, x21 = x22 - x16, y21 = y22 - y16, x01 = x011 - x16, y01 = y011 - y16, l01_2 = x01 * x01 + y01 * y01;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x16) + "," + (this._y1 = y16);
        } else if (!(l01_2 > epsilon8))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon8) || !r2) {
          this._ += "L" + (this._x1 = x16) + "," + (this._y1 = y16);
        } else {
          var x20 = x22 - x011, y20 = y22 - y011, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi5 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
          if (Math.abs(t01 - 1) > epsilon8) {
            this._ += "L" + (x16 + t01 * x01) + "," + (y16 + t01 * y01);
          }
          this._ += "A" + r2 + "," + r2 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x16 + t21 * x21) + "," + (this._y1 = y16 + t21 * y21);
        }
      },
      arc: function(x4, y4, r2, a0, a1, ccw) {
        x4 = +x4, y4 = +y4, r2 = +r2, ccw = !!ccw;
        var dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x011 = x4 + dx, y011 = y4 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + x011 + "," + y011;
        } else if (Math.abs(this._x1 - x011) > epsilon8 || Math.abs(this._y1 - y011) > epsilon8) {
          this._ += "L" + x011 + "," + y011;
        }
        if (!r2)
          return;
        if (da < 0)
          da = da % tau5 + tau5;
        if (da > tauEpsilon) {
          this._ += "A" + r2 + "," + r2 + ",0,1," + cw + "," + (x4 - dx) + "," + (y4 - dy) + "A" + r2 + "," + r2 + ",0,1," + cw + "," + (this._x1 = x011) + "," + (this._y1 = y011);
        } else if (da > epsilon8) {
          this._ += "A" + r2 + "," + r2 + ",0," + +(da >= pi5) + "," + cw + "," + (this._x1 = x4 + r2 * Math.cos(a1)) + "," + (this._y1 = y4 + r2 * Math.sin(a1));
        }
      },
      rect: function(x4, y4, w3, h2) {
        this._ += "M" + (this._x0 = this._x1 = +x4) + "," + (this._y0 = this._y1 = +y4) + "h" + +w3 + "v" + +h2 + "h" + -w3 + "Z";
      },
      toString: function() {
        return this._;
      }
    };
    path_default4 = path;
  }
});

// node_modules/d3-path/src/index.js
var init_src6 = __esm({
  "node_modules/d3-path/src/index.js"() {
    init_path4();
  }
});

// node_modules/d3-composite-projections/src/albersUsa.js
function multiplex2(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].point(x4, y4);
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].sphere();
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].lineStart();
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].lineEnd();
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].polygonStart();
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].polygonEnd();
    }
  };
}
function albersUsa_default4() {
  var cache, cacheStream, lower48 = albers_default3(), lower48Point, alaska2 = conicEqualArea_default3().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default3().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function albersUsa(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (lower48Point.point(x4, y4), point5) || (alaskaPoint.point(x4, y4), point5) || (hawaiiPoint.point(x4, y4), point5);
  }
  albersUsa.invert = function(coordinates2) {
    var k4 = lower48.scale(), t2 = lower48.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= 0.12 && y4 < 0.234 && x4 >= -0.425 && x4 < -0.214 ? alaska2 : y4 >= 0.166 && y4 < 0.234 && x4 >= -0.214 && x4 < -0.115 ? hawaii : lower48).invert(coordinates2);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex2([lower48.stream(cacheStream = stream), alaska2.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_2) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_2), alaska2.precision(_2), hawaii.precision(_2);
    return reset();
  };
  albersUsa.scale = function(_2) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_2), alaska2.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_2) {
    if (!arguments.length)
      return lower48.translate();
    var k4 = lower48.scale(), x4 = +_2[0], y4 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x4 - 0.455 * k4, y4 - 0.238 * k4], [x4 + 0.455 * k4, y4 + 0.238 * k4]]).stream(pointStream);
    alaskaPoint = alaska2.translate([x4 - 0.307 * k4, y4 + 0.201 * k4]).clipExtent([[x4 - 0.425 * k4 + epsilon6, y4 + 0.12 * k4 + epsilon6], [x4 - 0.214 * k4 - epsilon6, y4 + 0.234 * k4 - epsilon6]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x4 - 0.205 * k4, y4 + 0.212 * k4]).clipExtent([[x4 - 0.214 * k4 + epsilon6, y4 + 0.166 * k4 + epsilon6], [x4 - 0.115 * k4 - epsilon6, y4 + 0.234 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent, object3) {
    return fitExtent4(albersUsa, extent, object3);
  };
  albersUsa.fitSize = function(size, object3) {
    return fitSize4(albersUsa, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }
  albersUsa.drawCompositionBorders = function(context) {
    var hawaii1 = lower48([-102.91, 26.3]);
    var hawaii2 = lower48([-104, 27.5]);
    var hawaii3 = lower48([-108, 29.1]);
    var hawaii4 = lower48([-110, 29.1]);
    var alaska1 = lower48([-110, 26.7]);
    var alaska22 = lower48([-112.8, 27.6]);
    var alaska3 = lower48([-114.3, 30.6]);
    var alaska4 = lower48([-119.3, 30.1]);
    context.moveTo(hawaii1[0], hawaii1[1]);
    context.lineTo(hawaii2[0], hawaii2[1]);
    context.lineTo(hawaii3[0], hawaii3[1]);
    context.lineTo(hawaii4[0], hawaii4[1]);
    context.moveTo(alaska1[0], alaska1[1]);
    context.lineTo(alaska22[0], alaska22[1]);
    context.lineTo(alaska3[0], alaska3[1]);
    context.lineTo(alaska4[0], alaska4[1]);
  };
  albersUsa.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return albersUsa.scale(1070);
}
var init_albersUsa4 = __esm({
  "node_modules/d3-composite-projections/src/albersUsa.js"() {
    init_math4();
    init_src5();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/albersUsaTerritories.js
function multiplex3(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].point(x4, y4);
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].sphere();
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].lineStart();
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].lineEnd();
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].polygonStart();
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].polygonEnd();
    }
  };
}
function albersUsaTerritories_default() {
  var cache, cacheStream, lower48 = albers_default3(), lower48Point, alaska2 = conicEqualArea_default3().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default3().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, puertoRico = conicEqualArea_default3().rotate([66, 0]).center([0, 18]).parallels([8, 18]), puertoRicoPoint, samoa = equirectangular_default3().rotate([173, 14]), samoaPoint, guam = equirectangular_default3().rotate([-145, -16.8]), guamPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function albersUsa(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (lower48Point.point(x4, y4), point5) || (alaskaPoint.point(x4, y4), point5) || (hawaiiPoint.point(x4, y4), point5) || (puertoRicoPoint.point(x4, y4), point5) || (samoaPoint.point(x4, y4), point5) || (guamPoint.point(x4, y4), point5);
  }
  albersUsa.invert = function(coordinates2) {
    var k4 = lower48.scale(), t2 = lower48.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= 0.12 && y4 < 0.234 && x4 >= -0.425 && x4 < -0.214 ? alaska2 : y4 >= 0.166 && y4 < 0.234 && x4 >= -0.214 && x4 < -0.115 ? hawaii : y4 >= 0.2064 && y4 < 0.2413 && x4 >= 0.312 && x4 < 0.385 ? puertoRico : y4 >= 0.09 && y4 < 0.1197 && x4 >= -0.4243 && x4 < -0.3232 ? samoa : y4 >= -0.0518 && y4 < 0.0895 && x4 >= -0.4243 && x4 < -0.3824 ? guam : lower48).invert(coordinates2);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex3([lower48.stream(cacheStream = stream), alaska2.stream(stream), hawaii.stream(stream), puertoRico.stream(stream), samoa.stream(stream), guam.stream(stream)]);
  };
  albersUsa.precision = function(_2) {
    if (!arguments.length) {
      return lower48.precision();
    }
    lower48.precision(_2);
    alaska2.precision(_2);
    hawaii.precision(_2);
    puertoRico.precision(_2);
    samoa.precision(_2);
    guam.precision(_2);
    return reset();
  };
  albersUsa.scale = function(_2) {
    if (!arguments.length) {
      return lower48.scale();
    }
    lower48.scale(_2);
    alaska2.scale(_2 * 0.35);
    hawaii.scale(_2);
    puertoRico.scale(_2);
    samoa.scale(_2 * 2);
    guam.scale(_2);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_2) {
    if (!arguments.length) {
      return lower48.translate();
    }
    var k4 = lower48.scale(), x4 = +_2[0], y4 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x4 - 0.455 * k4, y4 - 0.238 * k4], [x4 + 0.455 * k4, y4 + 0.238 * k4]]).stream(pointStream);
    alaskaPoint = alaska2.translate([x4 - 0.307 * k4, y4 + 0.201 * k4]).clipExtent([[x4 - 0.425 * k4 + epsilon6, y4 + 0.12 * k4 + epsilon6], [x4 - 0.214 * k4 - epsilon6, y4 + 0.233 * k4 - epsilon6]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x4 - 0.205 * k4, y4 + 0.212 * k4]).clipExtent([[x4 - 0.214 * k4 + epsilon6, y4 + 0.166 * k4 + epsilon6], [x4 - 0.115 * k4 - epsilon6, y4 + 0.233 * k4 - epsilon6]]).stream(pointStream);
    puertoRicoPoint = puertoRico.translate([x4 + 0.35 * k4, y4 + 0.224 * k4]).clipExtent([[x4 + 0.312 * k4 + epsilon6, y4 + 0.2064 * k4 + epsilon6], [x4 + 0.385 * k4 - epsilon6, y4 + 0.233 * k4 - epsilon6]]).stream(pointStream);
    samoaPoint = samoa.translate([x4 - 0.492 * k4, y4 + 0.09 * k4]).clipExtent([[x4 - 0.4243 * k4 + epsilon6, y4 + 0.0903 * k4 + epsilon6], [x4 - 0.3233 * k4 - epsilon6, y4 + 0.1197 * k4 - epsilon6]]).stream(pointStream);
    guamPoint = guam.translate([x4 - 0.408 * k4, y4 + 0.018 * k4]).clipExtent([[x4 - 0.4244 * k4 + epsilon6, y4 - 0.0519 * k4 + epsilon6], [x4 - 0.3824 * k4 - epsilon6, y4 + 0.0895 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent, object3) {
    return fitExtent4(albersUsa, extent, object3);
  };
  albersUsa.fitSize = function(size, object3) {
    return fitSize4(albersUsa, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }
  albersUsa.drawCompositionBorders = function(context) {
    var ulhawaii = lower48([-110.4641, 28.2805]);
    var urhawaii = lower48([-104.0597, 28.9528]);
    var ldhawaii = lower48([-103.7049, 25.1031]);
    var llhawaii = lower48([-109.8337, 24.4531]);
    var ulalaska = lower48([-124.4745, 28.1407]);
    var uralaska = lower48([-110.931, 30.8844]);
    var ldalaska = lower48([-109.8337, 24.4531]);
    var llalaska = lower48([-122.4628, 21.8562]);
    var ulpuertoRico = lower48([-76.8579, 25.1544]);
    var urpuertoRico = lower48([-72.429, 24.2097]);
    var ldpuertoRico = lower48([-72.8265, 22.7056]);
    var llpuertoRico = lower48([-77.1852, 23.6392]);
    var ulsamoa = lower48([-125.0093, 29.7791]);
    var ursamoa = lower48([-118.5193, 31.3262]);
    var ldsamoa = lower48([-118.064, 29.6912]);
    var llsamoa = lower48([-124.4369, 28.169]);
    var ulguam = lower48([-128.1314, 37.4582]);
    var urguam = lower48([-125.2132, 38.214]);
    var ldguam = lower48([-122.3616, 30.5115]);
    var llguam = lower48([-125.0315, 29.8211]);
    context.moveTo(ulhawaii[0], ulhawaii[1]);
    context.lineTo(urhawaii[0], urhawaii[1]);
    context.lineTo(ldhawaii[0], ldhawaii[1]);
    context.lineTo(ldhawaii[0], ldhawaii[1]);
    context.lineTo(llhawaii[0], llhawaii[1]);
    context.closePath();
    context.moveTo(ulalaska[0], ulalaska[1]);
    context.lineTo(uralaska[0], uralaska[1]);
    context.lineTo(ldalaska[0], ldalaska[1]);
    context.lineTo(ldalaska[0], ldalaska[1]);
    context.lineTo(llalaska[0], llalaska[1]);
    context.closePath();
    context.moveTo(ulpuertoRico[0], ulpuertoRico[1]);
    context.lineTo(urpuertoRico[0], urpuertoRico[1]);
    context.lineTo(ldpuertoRico[0], ldpuertoRico[1]);
    context.lineTo(ldpuertoRico[0], ldpuertoRico[1]);
    context.lineTo(llpuertoRico[0], llpuertoRico[1]);
    context.closePath();
    context.moveTo(ulsamoa[0], ulsamoa[1]);
    context.lineTo(ursamoa[0], ursamoa[1]);
    context.lineTo(ldsamoa[0], ldsamoa[1]);
    context.lineTo(ldsamoa[0], ldsamoa[1]);
    context.lineTo(llsamoa[0], llsamoa[1]);
    context.closePath();
    context.moveTo(ulguam[0], ulguam[1]);
    context.lineTo(urguam[0], urguam[1]);
    context.lineTo(ldguam[0], ldguam[1]);
    context.lineTo(ldguam[0], ldguam[1]);
    context.lineTo(llguam[0], llguam[1]);
    context.closePath();
  };
  albersUsa.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return albersUsa.scale(1070);
}
var init_albersUsaTerritories = __esm({
  "node_modules/d3-composite-projections/src/albersUsaTerritories.js"() {
    init_math4();
    init_src5();
    init_src5();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/conicConformalSpain.js
function multiplex4(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].point(x4, y4);
      }
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].sphere();
      }
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineStart();
      }
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineEnd();
      }
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonStart();
      }
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonEnd();
      }
    }
  };
}
function conicConformalSpain_default() {
  var cache, cacheStream, iberianPeninsule = conicConformal_default3().rotate([5, -38.6]).parallels([0, 60]), iberianPeninsulePoint, canaryIslands = conicConformal_default3().rotate([5, -38.6]).parallels([0, 60]), canaryIslandsPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function conicConformalSpain(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (iberianPeninsulePoint.point(x4, y4), point5) || (canaryIslandsPoint.point(x4, y4), point5);
  }
  conicConformalSpain.invert = function(coordinates2) {
    var k4 = iberianPeninsule.scale(), t2 = iberianPeninsule.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= 0.05346 && y4 < 0.0897 && x4 >= -0.13388 && x4 < -0.0322 ? canaryIslands : iberianPeninsule).invert(coordinates2);
  };
  conicConformalSpain.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex4([iberianPeninsule.stream(cacheStream = stream), canaryIslands.stream(stream)]);
  };
  conicConformalSpain.precision = function(_2) {
    if (!arguments.length) {
      return iberianPeninsule.precision();
    }
    iberianPeninsule.precision(_2);
    canaryIslands.precision(_2);
    return reset();
  };
  conicConformalSpain.scale = function(_2) {
    if (!arguments.length) {
      return iberianPeninsule.scale();
    }
    iberianPeninsule.scale(_2);
    canaryIslands.scale(_2);
    return conicConformalSpain.translate(iberianPeninsule.translate());
  };
  conicConformalSpain.translate = function(_2) {
    if (!arguments.length) {
      return iberianPeninsule.translate();
    }
    var k4 = iberianPeninsule.scale(), x4 = +_2[0], y4 = +_2[1];
    iberianPeninsulePoint = iberianPeninsule.translate(_2).clipExtent([[x4 - 0.06857 * k4, y4 - 0.1288 * k4], [x4 + 0.13249 * k4, y4 + 0.06 * k4]]).stream(pointStream);
    canaryIslandsPoint = canaryIslands.translate([x4 + 0.1 * k4, y4 - 0.094 * k4]).clipExtent([[x4 - 0.1331 * k4 + epsilon6, y4 + 0.053457 * k4 + epsilon6], [x4 - 0.0354 * k4 - epsilon6, y4 + 0.08969 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  conicConformalSpain.fitExtent = function(extent, object3) {
    return fitExtent4(conicConformalSpain, extent, object3);
  };
  conicConformalSpain.fitSize = function(size, object3) {
    return fitSize4(conicConformalSpain, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return conicConformalSpain;
  }
  conicConformalSpain.drawCompositionBorders = function(context) {
    var ulCanaryIslands = iberianPeninsule([-14.034675, 34.965007]);
    var urCanaryIslands = iberianPeninsule([-7.4208899, 35.536988]);
    var ldCanaryIslands = iberianPeninsule([-7.3148275, 33.54359]);
    context.moveTo(ulCanaryIslands[0], ulCanaryIslands[1]);
    context.lineTo(urCanaryIslands[0], urCanaryIslands[1]);
    context.lineTo(ldCanaryIslands[0], ldCanaryIslands[1]);
  };
  conicConformalSpain.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return conicConformalSpain.scale(2700);
}
var init_conicConformalSpain = __esm({
  "node_modules/d3-composite-projections/src/conicConformalSpain.js"() {
    init_math4();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/conicConformalPortugal.js
function multiplex5(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].point(x4, y4);
      }
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].sphere();
      }
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineStart();
      }
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineEnd();
      }
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonStart();
      }
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonEnd();
      }
    }
  };
}
function conicConformalPortugal_default() {
  var cache, cacheStream, iberianPeninsule = conicConformal_default3().rotate([10, -39.3]).parallels([0, 60]), iberianPeninsulePoint, madeira = conicConformal_default3().rotate([17, -32.7]).parallels([0, 60]), madeiraPoint, azores = conicConformal_default3().rotate([27.8, -38.6]).parallels([0, 60]), azoresPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function conicConformalPortugal(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (iberianPeninsulePoint.point(x4, y4), point5) || (madeiraPoint.point(x4, y4), point5) || (azoresPoint.point(x4, y4), point5);
  }
  conicConformalPortugal.invert = function(coordinates2) {
    var k4 = iberianPeninsule.scale(), t2 = iberianPeninsule.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= 93e-4 && y4 < 0.03678 && x4 >= -0.03875 && x4 < -0.0116 ? madeira : y4 >= -0.0412 && y4 < 91e-4 && x4 >= -0.07782 && x4 < -0.01166 ? azores : iberianPeninsule).invert(coordinates2);
  };
  conicConformalPortugal.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex5([iberianPeninsule.stream(cacheStream = stream), madeira.stream(stream), azores.stream(stream)]);
  };
  conicConformalPortugal.precision = function(_2) {
    if (!arguments.length) {
      return iberianPeninsule.precision();
    }
    iberianPeninsule.precision(_2);
    madeira.precision(_2);
    azores.precision(_2);
    return reset();
  };
  conicConformalPortugal.scale = function(_2) {
    if (!arguments.length) {
      return iberianPeninsule.scale();
    }
    iberianPeninsule.scale(_2);
    madeira.scale(_2);
    azores.scale(_2 * 0.6);
    return conicConformalPortugal.translate(iberianPeninsule.translate());
  };
  conicConformalPortugal.translate = function(_2) {
    if (!arguments.length) {
      return iberianPeninsule.translate();
    }
    var k4 = iberianPeninsule.scale(), x4 = +_2[0], y4 = +_2[1];
    iberianPeninsulePoint = iberianPeninsule.translate(_2).clipExtent([[x4 - 0.0115 * k4, y4 - 0.1138 * k4], [x4 + 0.2105 * k4, y4 + 0.0673 * k4]]).stream(pointStream);
    madeiraPoint = madeira.translate([x4 - 0.0265 * k4, y4 + 0.025 * k4]).clipExtent([[x4 - 0.0388 * k4 + epsilon6, y4 + 93e-4 * k4 + epsilon6], [x4 - 0.0116 * k4 - epsilon6, y4 + 0.0368 * k4 - epsilon6]]).stream(pointStream);
    azoresPoint = azores.translate([x4 - 0.045 * k4, y4 + -0.02 * k4]).clipExtent([[x4 - 0.0778 * k4 + epsilon6, y4 - 0.0413 * k4 + epsilon6], [x4 - 0.0117 * k4 - epsilon6, y4 + 91e-4 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  conicConformalPortugal.fitExtent = function(extent, object3) {
    return fitExtent4(conicConformalPortugal, extent, object3);
  };
  conicConformalPortugal.fitSize = function(size, object3) {
    return fitSize4(conicConformalPortugal, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return conicConformalPortugal;
  }
  conicConformalPortugal.drawCompositionBorders = function(context) {
    var ulmadeira = iberianPeninsule([-12.8351, 38.7113]);
    var urmadeira = iberianPeninsule([-10.8482, 38.7633]);
    var ldmadeira = iberianPeninsule([-10.8181, 37.2072]);
    var llmadeira = iberianPeninsule([-12.7345, 37.1573]);
    var ulazores = iberianPeninsule([-16.0753, 41.4436]);
    var urazores = iberianPeninsule([-10.9168, 41.6861]);
    var ldazores = iberianPeninsule([-10.8557, 38.7747]);
    var llazores = iberianPeninsule([-15.6728, 38.5505]);
    context.moveTo(ulmadeira[0], ulmadeira[1]);
    context.lineTo(urmadeira[0], urmadeira[1]);
    context.lineTo(ldmadeira[0], ldmadeira[1]);
    context.lineTo(ldmadeira[0], ldmadeira[1]);
    context.lineTo(llmadeira[0], llmadeira[1]);
    context.closePath();
    context.moveTo(ulazores[0], ulazores[1]);
    context.lineTo(urazores[0], urazores[1]);
    context.lineTo(ldazores[0], ldazores[1]);
    context.lineTo(ldazores[0], ldazores[1]);
    context.lineTo(llazores[0], llazores[1]);
    context.closePath();
  };
  conicConformalPortugal.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return conicConformalPortugal.scale(4200);
}
var init_conicConformalPortugal = __esm({
  "node_modules/d3-composite-projections/src/conicConformalPortugal.js"() {
    init_math4();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/mercatorEcuador.js
function multiplex6(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].point(x4, y4);
      }
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].sphere();
      }
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineStart();
      }
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineEnd();
      }
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonStart();
      }
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonEnd();
      }
    }
  };
}
function mercatorEcuador_default() {
  var cache, cacheStream, mainland = mercator_default3().rotate([80, 1.5]), mainlandPoint, galapagos = mercator_default3().rotate([90.73, 1]), galapagosPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function mercatorEcuador(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (mainlandPoint.point(x4, y4), point5) || (galapagosPoint.point(x4, y4), point5);
  }
  mercatorEcuador.invert = function(coordinates2) {
    var k4 = mainland.scale(), t2 = mainland.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= -0.0676 && y4 < -0.026 && x4 >= -0.0857 && x4 < -0.0263 ? galapagos : mainland).invert(coordinates2);
  };
  mercatorEcuador.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex6([mainland.stream(cacheStream = stream), galapagos.stream(stream)]);
  };
  mercatorEcuador.precision = function(_2) {
    if (!arguments.length) {
      return mainland.precision();
    }
    mainland.precision(_2);
    galapagos.precision(_2);
    return reset();
  };
  mercatorEcuador.scale = function(_2) {
    if (!arguments.length) {
      return mainland.scale();
    }
    mainland.scale(_2);
    galapagos.scale(_2);
    return mercatorEcuador.translate(mainland.translate());
  };
  mercatorEcuador.translate = function(_2) {
    if (!arguments.length) {
      return mainland.translate();
    }
    var k4 = mainland.scale(), x4 = +_2[0], y4 = +_2[1];
    mainlandPoint = mainland.translate(_2).clipExtent([[x4 - 0.0262 * k4, y4 - 0.0734 * k4], [x4 + 0.1741 * k4, y4 + 0.079 * k4]]).stream(pointStream);
    galapagosPoint = galapagos.translate([x4 - 0.06 * k4, y4 - 0.04 * k4]).clipExtent([[x4 - 0.0857 * k4 + epsilon6, y4 - 0.0676 * k4 + epsilon6], [x4 - 0.0263 * k4 - epsilon6, y4 - 0.026 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  mercatorEcuador.fitExtent = function(extent, object3) {
    return fitExtent4(mercatorEcuador, extent, object3);
  };
  mercatorEcuador.fitSize = function(size, object3) {
    return fitSize4(mercatorEcuador, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return mercatorEcuador;
  }
  mercatorEcuador.drawCompositionBorders = function(context) {
    var ulgalapagos = mainland([-84.9032, 2.3757]);
    var urgalapagos = mainland([-81.5047, 2.3708]);
    var ldgalapagos = mainland([-81.5063, -0.01]);
    var llgalapagos = mainland([-84.9086, -5e-3]);
    context.moveTo(ulgalapagos[0], ulgalapagos[1]);
    context.lineTo(urgalapagos[0], urgalapagos[1]);
    context.lineTo(ldgalapagos[0], ldgalapagos[1]);
    context.lineTo(llgalapagos[0], llgalapagos[1]);
    context.closePath();
  };
  mercatorEcuador.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return mercatorEcuador.scale(3500);
}
var init_mercatorEcuador = __esm({
  "node_modules/d3-composite-projections/src/mercatorEcuador.js"() {
    init_math4();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/transverseMercatorChile.js
function multiplex7(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].point(x4, y4);
      }
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].sphere();
      }
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineStart();
      }
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineEnd();
      }
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonStart();
      }
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonEnd();
      }
    }
  };
}
function transverseMercatorChile_default() {
  var cache, cacheStream, mainland = transverseMercator_default3().rotate([72, 37]), mainlandPoint, antarctic = stereographic_default3().rotate([72, 0]), antarcticPoint, juanFernandez = mercator_default3().rotate([80, 33.5]), juanFernandezPoint, pascua = mercator_default3().rotate([110, 25]), pascuaPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function transverseMercatorChile(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (mainlandPoint.point(x4, y4), point5) || (antarcticPoint.point(x4, y4), point5) || (juanFernandezPoint.point(x4, y4), point5) || (pascuaPoint.point(x4, y4), point5);
  }
  transverseMercatorChile.invert = function(coordinates2) {
    var k4 = mainland.scale(), t2 = mainland.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= 0.2582 && y4 < 0.32 && x4 >= -0.1036 && x4 < -0.087 ? antarctic : y4 >= -0.01298 && y4 < 0.0133 && x4 >= -0.11396 && x4 < -0.05944 ? juanFernandez : y4 >= 0.01539 && y4 < 0.03911 && x4 >= -0.089 && x4 < -0.0588 ? pascua : mainland).invert(coordinates2);
  };
  transverseMercatorChile.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex7([mainland.stream(cacheStream = stream), antarctic.stream(stream), juanFernandez.stream(stream), pascua.stream(stream)]);
  };
  transverseMercatorChile.precision = function(_2) {
    if (!arguments.length) {
      return mainland.precision();
    }
    mainland.precision(_2);
    antarctic.precision(_2);
    juanFernandez.precision(_2);
    pascua.precision(_2);
    return reset();
  };
  transverseMercatorChile.scale = function(_2) {
    if (!arguments.length) {
      return mainland.scale();
    }
    mainland.scale(_2);
    antarctic.scale(_2 * 0.15);
    juanFernandez.scale(_2 * 1.5);
    pascua.scale(_2 * 1.5);
    return transverseMercatorChile.translate(mainland.translate());
  };
  transverseMercatorChile.translate = function(_2) {
    if (!arguments.length) {
      return mainland.translate();
    }
    var k4 = mainland.scale(), x4 = +_2[0], y4 = +_2[1];
    mainlandPoint = mainland.translate(_2).clipExtent([[x4 - 0.059 * k4, y4 - 0.3835 * k4], [x4 + 0.4498 * k4, y4 + 0.3375 * k4]]).stream(pointStream);
    antarcticPoint = antarctic.translate([x4 - 0.087 * k4, y4 + 0.17 * k4]).clipExtent([[x4 - 0.1166 * k4 + epsilon6, y4 + 0.2582 * k4 + epsilon6], [x4 - 0.06 * k4 - epsilon6, y4 + 0.32 * k4 - epsilon6]]).stream(pointStream);
    juanFernandezPoint = juanFernandez.translate([x4 - 0.092 * k4, y4 - 0 * k4]).clipExtent([[x4 - 0.114 * k4 + epsilon6, y4 - 0.013 * k4 + epsilon6], [x4 - 0.0594 * k4 - epsilon6, y4 + 0.0133 * k4 - epsilon6]]).stream(pointStream);
    pascuaPoint = pascua.translate([x4 - 0.089 * k4, y4 - 0.0265 * k4]).clipExtent([[x4 - 0.089 * k4 + epsilon6, y4 + 0.0154 * k4 + epsilon6], [x4 - 0.0588 * k4 - epsilon6, y4 + 0.0391 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  transverseMercatorChile.fitExtent = function(extent, object3) {
    return fitExtent4(transverseMercatorChile, extent, object3);
  };
  transverseMercatorChile.fitSize = function(size, object3) {
    return fitSize4(transverseMercatorChile, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return transverseMercatorChile;
  }
  transverseMercatorChile.drawCompositionBorders = function(context) {
    var ulantarctic = mainland([-82.6999, -51.3043]);
    var urantarctic = mainland([-77.5442, -51.6631]);
    var ldantarctic = mainland([-78.0254, -55.186]);
    var llantarctic = mainland([-83.6106, -54.7785]);
    var uljuanFernandez = mainland([-80.0638, -35.984]);
    var urjuanFernandez = mainland([-76.2153, -36.1811]);
    var ldjuanFernandez = mainland([-76.2994, -37.6839]);
    var lljuanFernandez = mainland([-80.2231, -37.4757]);
    var ulpascua = mainland([-78.442, -37.706]);
    var urpascua = mainland([-76.263, -37.8054]);
    var ldpascua = mainland([-76.344, -39.1595]);
    var llpascua = mainland([-78.5638, -39.0559]);
    context.moveTo(ulantarctic[0], ulantarctic[1]);
    context.lineTo(urantarctic[0], urantarctic[1]);
    context.lineTo(ldantarctic[0], ldantarctic[1]);
    context.lineTo(ldantarctic[0], ldantarctic[1]);
    context.lineTo(llantarctic[0], llantarctic[1]);
    context.closePath();
    context.moveTo(uljuanFernandez[0], uljuanFernandez[1]);
    context.lineTo(urjuanFernandez[0], urjuanFernandez[1]);
    context.lineTo(ldjuanFernandez[0], ldjuanFernandez[1]);
    context.lineTo(ldjuanFernandez[0], ldjuanFernandez[1]);
    context.lineTo(lljuanFernandez[0], lljuanFernandez[1]);
    context.closePath();
    context.moveTo(ulpascua[0], ulpascua[1]);
    context.lineTo(urpascua[0], urpascua[1]);
    context.lineTo(ldpascua[0], ldpascua[1]);
    context.lineTo(ldpascua[0], ldpascua[1]);
    context.lineTo(llpascua[0], llpascua[1]);
    context.closePath();
  };
  transverseMercatorChile.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return transverseMercatorChile.scale(700);
}
var init_transverseMercatorChile = __esm({
  "node_modules/d3-composite-projections/src/transverseMercatorChile.js"() {
    init_math4();
    init_src5();
    init_src5();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/conicEquidistantJapan.js
function multiplex8(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].point(x4, y4);
      }
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].sphere();
      }
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineStart();
      }
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineEnd();
      }
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonStart();
      }
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonEnd();
      }
    }
  };
}
function conicEquidistantJapan_default() {
  var cache, cacheStream, mainland = conicEquidistant_default3().rotate([-136, -22]).parallels([40, 34]), mainlandPoint, hokkaido = conicEquidistant_default3().rotate([-146, -26]).parallels([40, 34]), hokkaidoPoint, okinawa = conicEquidistant_default3().rotate([-126, -19]).parallels([40, 34]), okinawaPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function conicEquidistantJapan(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (mainlandPoint.point(x4, y4), point5) || (hokkaidoPoint.point(x4, y4), point5) || (okinawaPoint.point(x4, y4), point5);
  }
  conicEquidistantJapan.invert = function(coordinates2) {
    var k4 = mainland.scale(), t2 = mainland.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= -0.10925 && y4 < -0.02701 && x4 >= -0.135 && x4 < -0.0397 ? hokkaido : y4 >= 0.04713 && y4 < 0.11138 && x4 >= -0.03986 && x4 < 0.051 ? okinawa : mainland).invert(coordinates2);
  };
  conicEquidistantJapan.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex8([mainland.stream(cacheStream = stream), hokkaido.stream(stream), okinawa.stream(stream)]);
  };
  conicEquidistantJapan.precision = function(_2) {
    if (!arguments.length) {
      return mainland.precision();
    }
    mainland.precision(_2);
    hokkaido.precision(_2);
    okinawa.precision(_2);
    return reset();
  };
  conicEquidistantJapan.scale = function(_2) {
    if (!arguments.length) {
      return mainland.scale();
    }
    mainland.scale(_2);
    hokkaido.scale(_2);
    okinawa.scale(_2 * 0.7);
    return conicEquidistantJapan.translate(mainland.translate());
  };
  conicEquidistantJapan.translate = function(_2) {
    if (!arguments.length) {
      return mainland.translate();
    }
    var k4 = mainland.scale(), x4 = +_2[0], y4 = +_2[1];
    mainlandPoint = mainland.translate(_2).clipExtent([[x4 - 0.1352 * k4, y4 - 0.1091 * k4], [x4 + 0.117 * k4, y4 + 0.098 * k4]]).stream(pointStream);
    hokkaidoPoint = hokkaido.translate([x4 - 0.0425 * k4, y4 - 5e-3 * k4]).clipExtent([[x4 - 0.135 * k4 + epsilon6, y4 - 0.1093 * k4 + epsilon6], [x4 - 0.0397 * k4 - epsilon6, y4 - 0.027 * k4 - epsilon6]]).stream(pointStream);
    okinawaPoint = okinawa.translate(_2).clipExtent([[x4 - 0.0399 * k4 + epsilon6, y4 + 0.0471 * k4 + epsilon6], [x4 + 0.051 * k4 - epsilon6, y4 + 0.1114 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  conicEquidistantJapan.fitExtent = function(extent, object3) {
    return fitExtent4(conicEquidistantJapan, extent, object3);
  };
  conicEquidistantJapan.fitSize = function(size, object3) {
    return fitSize4(conicEquidistantJapan, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return conicEquidistantJapan;
  }
  conicEquidistantJapan.drawCompositionBorders = function(context) {
    var ulhokkaido = mainland([126.01320483689143, 41.621090310215585]);
    var urhokkaido = mainland([133.04304387025903, 42.15087523707186]);
    var ldhokkaido = mainland([133.3021766080688, 37.43975444725098]);
    var llhokkaido = mainland([126.87889168628224, 36.95488945159779]);
    var llokinawa = mainland([132.9, 29.8]);
    var lmokinawa = mainland([134, 33]);
    var lrokinawa = mainland([139.3, 33.2]);
    var llrokinawa = mainland([139.16, 30.5]);
    context.moveTo(ulhokkaido[0], ulhokkaido[1]);
    context.lineTo(urhokkaido[0], urhokkaido[1]);
    context.lineTo(ldhokkaido[0], ldhokkaido[1]);
    context.lineTo(llhokkaido[0], llhokkaido[1]);
    context.closePath();
    context.moveTo(llokinawa[0], llokinawa[1]);
    context.lineTo(lmokinawa[0], lmokinawa[1]);
    context.lineTo(lrokinawa[0], lrokinawa[1]);
    context.lineTo(llrokinawa[0], llrokinawa[1]);
  };
  conicEquidistantJapan.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return conicEquidistantJapan.scale(2200);
}
var init_conicEquidistantJapan = __esm({
  "node_modules/d3-composite-projections/src/conicEquidistantJapan.js"() {
    init_math4();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/conicConformalFrance.js
function multiplex9(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].point(x4, y4);
      }
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].sphere();
      }
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineStart();
      }
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineEnd();
      }
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonStart();
      }
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonEnd();
      }
    }
  };
}
function conicConformalFrance_default() {
  var cache, cacheStream, europe = conicConformal_default3().rotate([-3, -46.2]).parallels([0, 60]), europePoint, guyane = mercator_default3().center([-53.2, 3.9]), guyanePoint, martinique = mercator_default3().center([-61.03, 14.67]), martiniquePoint, guadeloupe = mercator_default3().center([-61.46, 16.14]), guadeloupePoint, saintBarthelemy = mercator_default3().center([-62.85, 17.92]), saintBarthelemyPoint, stPierreMiquelon = mercator_default3().center([-56.23, 46.93]), stPierreMiquelonPoint, mayotte = mercator_default3().center([45.16, -12.8]), mayottePoint, reunion = mercator_default3().center([55.52, -21.13]), reunionPoint, nouvelleCaledonie = mercator_default3().center([165.8, -21.07]), nouvelleCaledoniePoint, wallisFutuna = mercator_default3().center([-178.1, -14.3]), wallisFutunaPoint, polynesie = mercator_default3().center([-150.55, -17.11]), polynesiePoint, polynesie2 = mercator_default3().center([-150.55, -17.11]), polynesie2Point, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function conicConformalFrance(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (europePoint.point(x4, y4), point5) || (guyanePoint.point(x4, y4), point5) || (martiniquePoint.point(x4, y4), point5) || (guadeloupePoint.point(x4, y4), point5) || (saintBarthelemyPoint.point(x4, y4), point5) || (stPierreMiquelonPoint.point(x4, y4), point5) || (mayottePoint.point(x4, y4), point5) || (reunionPoint.point(x4, y4), point5) || (nouvelleCaledoniePoint.point(x4, y4), point5) || (wallisFutunaPoint.point(x4, y4), point5) || (polynesiePoint.point(x4, y4), point5) || (polynesie2Point.point(x4, y4), point5);
  }
  conicConformalFrance.invert = function(coordinates2) {
    var k4 = europe.scale(), t2 = europe.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= 0.029 && y4 < 0.0864 && x4 >= -0.14 && x4 < -0.0996 ? guyane : y4 >= 0 && y4 < 0.029 && x4 >= -0.14 && x4 < -0.0996 ? martinique : y4 >= -0.032 && y4 < 0 && x4 >= -0.14 && x4 < -0.0996 ? guadeloupe : y4 >= -0.052 && y4 < -0.032 && x4 >= -0.14 && x4 < -0.0996 ? saintBarthelemy : y4 >= -0.076 && y4 < 0.052 && x4 >= -0.14 && x4 < -0.0996 ? stPierreMiquelon : y4 >= -0.076 && y4 < -0.052 && x4 >= 0.0967 && x4 < 0.1371 ? mayotte : y4 >= -0.052 && y4 < -0.02 && x4 >= 0.0967 && x4 < 0.1371 ? reunion : y4 >= -0.02 && y4 < 0.012 && x4 >= 0.0967 && x4 < 0.1371 ? nouvelleCaledonie : y4 >= 0.012 && y4 < 0.033 && x4 >= 0.0967 && x4 < 0.1371 ? wallisFutuna : y4 >= 0.033 && y4 < 0.0864 && x4 >= 0.0967 && x4 < 0.1371 ? polynesie : europe).invert(coordinates2);
  };
  conicConformalFrance.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex9([europe.stream(cacheStream = stream), guyane.stream(stream), martinique.stream(stream), guadeloupe.stream(stream), saintBarthelemy.stream(stream), stPierreMiquelon.stream(stream), mayotte.stream(stream), reunion.stream(stream), nouvelleCaledonie.stream(stream), wallisFutuna.stream(stream), polynesie.stream(stream), polynesie2.stream(stream)]);
  };
  conicConformalFrance.precision = function(_2) {
    if (!arguments.length) {
      return europe.precision();
    }
    europe.precision(_2);
    guyane.precision(_2);
    martinique.precision(_2);
    guadeloupe.precision(_2);
    saintBarthelemy.precision(_2);
    stPierreMiquelon.precision(_2);
    mayotte.precision(_2);
    reunion.precision(_2);
    nouvelleCaledonie.precision(_2);
    wallisFutuna.precision(_2);
    polynesie.precision(_2);
    polynesie2.precision(_2);
    return reset();
  };
  conicConformalFrance.scale = function(_2) {
    if (!arguments.length) {
      return europe.scale();
    }
    europe.scale(_2);
    guyane.scale(_2 * 0.6);
    martinique.scale(_2 * 1.6);
    guadeloupe.scale(_2 * 1.4);
    saintBarthelemy.scale(_2 * 5);
    stPierreMiquelon.scale(_2 * 1.3);
    mayotte.scale(_2 * 1.6);
    reunion.scale(_2 * 1.2);
    nouvelleCaledonie.scale(_2 * 0.3);
    wallisFutuna.scale(_2 * 2.7);
    polynesie.scale(_2 * 0.5);
    polynesie2.scale(_2 * 0.06);
    return conicConformalFrance.translate(europe.translate());
  };
  conicConformalFrance.translate = function(_2) {
    if (!arguments.length) {
      return europe.translate();
    }
    var k4 = europe.scale(), x4 = +_2[0], y4 = +_2[1];
    europePoint = europe.translate(_2).clipExtent([[x4 - 0.0996 * k4, y4 - 0.0908 * k4], [x4 + 0.0967 * k4, y4 + 0.0864 * k4]]).stream(pointStream);
    guyanePoint = guyane.translate([x4 - 0.12 * k4, y4 + 0.0575 * k4]).clipExtent([[x4 - 0.14 * k4 + epsilon6, y4 + 0.029 * k4 + epsilon6], [x4 - 0.0996 * k4 - epsilon6, y4 + 0.0864 * k4 - epsilon6]]).stream(pointStream);
    martiniquePoint = martinique.translate([x4 - 0.12 * k4, y4 + 0.013 * k4]).clipExtent([[x4 - 0.14 * k4 + epsilon6, y4 + 0 * k4 + epsilon6], [x4 - 0.0996 * k4 - epsilon6, y4 + 0.029 * k4 - epsilon6]]).stream(pointStream);
    guadeloupePoint = guadeloupe.translate([x4 - 0.12 * k4, y4 - 0.014 * k4]).clipExtent([[x4 - 0.14 * k4 + epsilon6, y4 - 0.032 * k4 + epsilon6], [x4 - 0.0996 * k4 - epsilon6, y4 + 0 * k4 - epsilon6]]).stream(pointStream);
    saintBarthelemyPoint = saintBarthelemy.translate([x4 - 0.12 * k4, y4 - 0.044 * k4]).clipExtent([[x4 - 0.14 * k4 + epsilon6, y4 - 0.052 * k4 + epsilon6], [x4 - 0.0996 * k4 - epsilon6, y4 - 0.032 * k4 - epsilon6]]).stream(pointStream);
    stPierreMiquelonPoint = stPierreMiquelon.translate([x4 - 0.12 * k4, y4 - 0.065 * k4]).clipExtent([[x4 - 0.14 * k4 + epsilon6, y4 - 0.076 * k4 + epsilon6], [x4 - 0.0996 * k4 - epsilon6, y4 - 0.052 * k4 - epsilon6]]).stream(pointStream);
    mayottePoint = mayotte.translate([x4 + 0.117 * k4, y4 - 0.064 * k4]).clipExtent([[x4 + 0.0967 * k4 + epsilon6, y4 - 0.076 * k4 + epsilon6], [x4 + 0.1371 * k4 - epsilon6, y4 - 0.052 * k4 - epsilon6]]).stream(pointStream);
    reunionPoint = reunion.translate([x4 + 0.116 * k4, y4 - 0.0355 * k4]).clipExtent([[x4 + 0.0967 * k4 + epsilon6, y4 - 0.052 * k4 + epsilon6], [x4 + 0.1371 * k4 - epsilon6, y4 - 0.02 * k4 - epsilon6]]).stream(pointStream);
    nouvelleCaledoniePoint = nouvelleCaledonie.translate([x4 + 0.116 * k4, y4 - 48e-4 * k4]).clipExtent([[x4 + 0.0967 * k4 + epsilon6, y4 - 0.02 * k4 + epsilon6], [x4 + 0.1371 * k4 - epsilon6, y4 + 0.012 * k4 - epsilon6]]).stream(pointStream);
    wallisFutunaPoint = wallisFutuna.translate([x4 + 0.116 * k4, y4 + 0.022 * k4]).clipExtent([[x4 + 0.0967 * k4 + epsilon6, y4 + 0.012 * k4 + epsilon6], [x4 + 0.1371 * k4 - epsilon6, y4 + 0.033 * k4 - epsilon6]]).stream(pointStream);
    polynesie2Point = polynesie2.translate([x4 + 0.11 * k4, y4 + 0.045 * k4]).clipExtent([[x4 + 0.0967 * k4 + epsilon6, y4 + 0.033 * k4 + epsilon6], [x4 + 0.1371 * k4 - epsilon6, y4 + 0.06 * k4 - epsilon6]]).stream(pointStream);
    polynesiePoint = polynesie.translate([x4 + 0.115 * k4, y4 + 0.075 * k4]).clipExtent([[x4 + 0.0967 * k4 + epsilon6, y4 + 0.06 * k4 + epsilon6], [x4 + 0.1371 * k4 - epsilon6, y4 + 0.0864 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  conicConformalFrance.fitExtent = function(extent, object3) {
    return fitExtent4(conicConformalFrance, extent, object3);
  };
  conicConformalFrance.fitSize = function(size, object3) {
    return fitSize4(conicConformalFrance, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return conicConformalFrance;
  }
  conicConformalFrance.drawCompositionBorders = function(context) {
    var ul, ur, ld, ll;
    ul = europe([-7.938886725111036, 43.7219460918835]);
    ur = europe([-4.832080896458295, 44.12930268549372]);
    ld = europe([-4.205299743793263, 40.98096346967365]);
    ll = europe([-7.071796453126152, 40.610037319181444]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([-8.42751373617692, 45.32889452553031]);
    ur = europe([-5.18599305777107, 45.7566442062976]);
    ld = europe([-4.832080905154431, 44.129302726751426]);
    ll = europe([-7.938886737126192, 43.72194613263854]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([-9.012656899657046, 47.127733821030176]);
    ur = europe([-5.6105244772793155, 47.579777861410626]);
    ld = europe([-5.185993067168585, 45.756644248170346]);
    ll = europe([-8.427513749141811, 45.32889456686326]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([-9.405747558985553, 48.26506375557457]);
    ur = europe([-5.896175018439575, 48.733352850851624]);
    ld = europe([-5.610524487556043, 47.57977790393761]);
    ll = europe([-9.012656913808351, 47.127733862971255]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([-9.908436061346974, 49.642448789505856]);
    ur = europe([-6.262026716233124, 50.131426841787174]);
    ld = europe([-5.896175029331232, 48.73335289377258]);
    ll = europe([-9.40574757396393, 48.26506379787767]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([11.996907706504462, 50.16039028163579]);
    ur = europe([15.649907879773343, 49.68279246765253]);
    ld = europe([15.156712840526632, 48.30371557625831]);
    ll = europe([11.64122661754411, 48.761078240546816]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([11.641226606955788, 48.7610781975889]);
    ur = europe([15.156712825832164, 48.30371553390465]);
    ld = europe([14.549932166241172, 46.4866532486199]);
    ll = europe([11.204443787952183, 46.91899233914248]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([11.204443778297161, 46.918992296823646]);
    ur = europe([14.549932152815039, 46.486653206856396]);
    ld = europe([13.994409796764009, 44.695833444323256]);
    ll = europe([10.805306599253848, 45.105133870684924]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([10.805306590412085, 45.10513382903308]);
    ur = europe([13.99440978444733, 44.695833403183606]);
    ld = europe([13.654633799024392, 43.53552468558152]);
    ll = europe([10.561516803980956, 43.930671459798624]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([10.561516795617383, 43.93067141859757]);
    ur = europe([13.654633787361952, 43.5355246448671]);
    ld = europe([12.867691604239901, 40.640701985019405]);
    ll = europe([9.997809515987688, 41.00288343254471]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([10.8, 42.4]);
    ur = europe([12.8, 42.13]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
  };
  conicConformalFrance.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return conicConformalFrance.scale(2700);
}
var init_conicConformalFrance = __esm({
  "node_modules/d3-composite-projections/src/conicConformalFrance.js"() {
    init_math4();
    init_src5();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/conicConformalEurope.js
function multiplex10(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].point(x4, y4);
      }
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].sphere();
      }
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineStart();
      }
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineEnd();
      }
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonStart();
      }
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonEnd();
      }
    }
  };
}
function conicConformalEurope_default() {
  var cache, cacheStream, europe = conicConformal_default3().rotate([-10, -53]).parallels([0, 60]), europePoint, guadeloupe = mercator_default3().center([-61.46, 16.14]), guadeloupePoint, guyane = mercator_default3().center([-53.2, 3.9]), guyanePoint, azores = conicConformal_default3().rotate([27.8, -38.9]).parallels([0, 60]), azoresPoint, azores2 = conicConformal_default3().rotate([25.43, -37.398]).parallels([0, 60]), azores2Point, azores3 = conicConformal_default3().rotate([31.17, -39.539]).parallels([0, 60]), azores3Point, madeira = conicConformal_default3().rotate([17, -32.7]).parallels([0, 60]), madeiraPoint, canaryIslands = conicConformal_default3().rotate([16, -28.5]).parallels([0, 60]), canaryIslandsPoint, martinique = mercator_default3().center([-61.03, 14.67]), martiniquePoint, mayotte = mercator_default3().center([45.16, -12.8]), mayottePoint, reunion = mercator_default3().center([55.52, -21.13]), reunionPoint, malta = conicConformal_default3().rotate([-14.4, -35.95]).parallels([0, 60]), maltaPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function conicConformalEurope(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (europePoint.point(x4, y4), point5) || (guyanePoint.point(x4, y4), point5) || (martiniquePoint.point(x4, y4), point5) || (guadeloupePoint.point(x4, y4), point5) || (canaryIslandsPoint.point(x4, y4), point5) || (madeiraPoint.point(x4, y4), point5) || (mayottePoint.point(x4, y4), point5) || (reunionPoint.point(x4, y4), point5) || (maltaPoint.point(x4, y4), point5) || (azoresPoint.point(x4, y4), point5) || (azores2Point.point(x4, y4), point5) || (azores3Point.point(x4, y4), point5);
  }
  conicConformalEurope.invert = function(coordinates2) {
    var k4 = europe.scale(), t2 = europe.translate(), x4 = (coordinates2[0] - (t2[0] + 0.08 * k4)) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= -0.31 && y4 < -0.24 && x4 >= 0.14 && x4 < 0.24 ? guadeloupe : y4 >= -0.24 && y4 < -0.17 && x4 >= 0.14 && x4 < 0.24 ? guyane : y4 >= -0.17 && y4 < -0.12 && x4 >= 0.21 && x4 < 0.24 ? azores2 : y4 >= -0.17 && y4 < -0.14 && x4 >= 0.14 && x4 < 0.165 ? azores3 : y4 >= -0.17 && y4 < -0.1 && x4 >= 0.14 && x4 < 0.24 ? azores : y4 >= -0.1 && y4 < -0.03 && x4 >= 0.14 && x4 < 0.24 ? madeira : y4 >= -0.03 && y4 < 0.04 && x4 >= 0.14 && x4 < 0.24 ? canaryIslands : y4 >= -0.31 && y4 < -0.24 && x4 >= 0.24 && x4 < 0.34 ? martinique : y4 >= -0.24 && y4 < -0.17 && x4 >= 0.24 && x4 < 0.34 ? mayotte : y4 >= -0.17 && y4 < -0.1 && x4 >= 0.24 && x4 < 0.34 ? reunion : y4 >= -0.1 && y4 < -0.03 && x4 >= 0.24 && x4 < 0.34 ? malta : europe).invert(coordinates2);
  };
  conicConformalEurope.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex10([europe.stream(cacheStream = stream), guyane.stream(stream), martinique.stream(stream), guadeloupe.stream(stream), canaryIslands.stream(stream), madeira.stream(stream), mayotte.stream(stream), reunion.stream(stream), malta.stream(stream), azores.stream(stream), azores2.stream(stream), azores3.stream(stream)]);
  };
  conicConformalEurope.precision = function(_2) {
    if (!arguments.length) {
      return europe.precision();
    }
    europe.precision(_2);
    guyane.precision(_2);
    martinique.precision(_2);
    guadeloupe.precision(_2);
    canaryIslands.precision(_2);
    madeira.precision(_2);
    mayotte.precision(_2);
    reunion.precision(_2);
    malta.precision(_2);
    azores.precision(_2);
    azores2.precision(_2);
    azores3.precision(_2);
    return reset();
  };
  conicConformalEurope.scale = function(_2) {
    if (!arguments.length) {
      return europe.scale();
    }
    europe.scale(_2);
    guadeloupe.scale(_2 * 3);
    guyane.scale(_2 * 0.8);
    martinique.scale(_2 * 3.5);
    reunion.scale(_2 * 2.7);
    azores.scale(_2 * 2);
    azores2.scale(_2 * 2);
    azores3.scale(_2 * 2);
    madeira.scale(_2 * 3);
    canaryIslands.scale(_2);
    mayotte.scale(_2 * 5.5);
    malta.scale(_2 * 6);
    return conicConformalEurope.translate(europe.translate());
  };
  conicConformalEurope.translate = function(_2) {
    if (!arguments.length) {
      return europe.translate();
    }
    var k4 = europe.scale(), x4 = +_2[0], y4 = +_2[1];
    europePoint = europe.translate([x4 - 0.08 * k4, y4]).clipExtent([[x4 - 0.51 * k4, y4 - 0.33 * k4], [x4 + 0.5 * k4, y4 + 0.33 * k4]]).stream(pointStream);
    guadeloupePoint = guadeloupe.translate([x4 + 0.19 * k4, y4 - 0.275 * k4]).clipExtent([[x4 + 0.14 * k4 + epsilon6, y4 - 0.31 * k4 + epsilon6], [x4 + 0.24 * k4 - epsilon6, y4 - 0.24 * k4 - epsilon6]]).stream(pointStream);
    guyanePoint = guyane.translate([x4 + 0.19 * k4, y4 - 0.205 * k4]).clipExtent([[x4 + 0.14 * k4 + epsilon6, y4 - 0.24 * k4 + epsilon6], [x4 + 0.24 * k4 - epsilon6, y4 - 0.17 * k4 - epsilon6]]).stream(pointStream);
    azoresPoint = azores.translate([x4 + 0.19 * k4, y4 - 0.135 * k4]).clipExtent([[x4 + 0.14 * k4 + epsilon6, y4 - 0.17 * k4 + epsilon6], [x4 + 0.24 * k4 - epsilon6, y4 - 0.1 * k4 - epsilon6]]).stream(pointStream);
    azores2Point = azores2.translate([x4 + 0.225 * k4, y4 - 0.147 * k4]).clipExtent([[x4 + 0.21 * k4 + epsilon6, y4 - 0.17 * k4 + epsilon6], [x4 + 0.24 * k4 - epsilon6, y4 - 0.12 * k4 - epsilon6]]).stream(pointStream);
    azores3Point = azores3.translate([x4 + 0.153 * k4, y4 - 0.15 * k4]).clipExtent([[x4 + 0.14 * k4 + epsilon6, y4 - 0.17 * k4 + epsilon6], [x4 + 0.165 * k4 - epsilon6, y4 - 0.14 * k4 - epsilon6]]).stream(pointStream);
    madeiraPoint = madeira.translate([x4 + 0.19 * k4, y4 - 0.065 * k4]).clipExtent([[x4 + 0.14 * k4 + epsilon6, y4 - 0.1 * k4 + epsilon6], [x4 + 0.24 * k4 - epsilon6, y4 - 0.03 * k4 - epsilon6]]).stream(pointStream);
    canaryIslandsPoint = canaryIslands.translate([x4 + 0.19 * k4, y4 + 5e-3 * k4]).clipExtent([[x4 + 0.14 * k4 + epsilon6, y4 - 0.03 * k4 + epsilon6], [x4 + 0.24 * k4 - epsilon6, y4 + 0.04 * k4 - epsilon6]]).stream(pointStream);
    martiniquePoint = martinique.translate([x4 + 0.29 * k4, y4 - 0.275 * k4]).clipExtent([[x4 + 0.24 * k4 + epsilon6, y4 - 0.31 * k4 + epsilon6], [x4 + 0.34 * k4 - epsilon6, y4 - 0.24 * k4 - epsilon6]]).stream(pointStream);
    mayottePoint = mayotte.translate([x4 + 0.29 * k4, y4 - 0.205 * k4]).clipExtent([[x4 + 0.24 * k4 + epsilon6, y4 - 0.24 * k4 + epsilon6], [x4 + 0.34 * k4 - epsilon6, y4 - 0.17 * k4 - epsilon6]]).stream(pointStream);
    reunionPoint = reunion.translate([x4 + 0.29 * k4, y4 - 0.135 * k4]).clipExtent([[x4 + 0.24 * k4 + epsilon6, y4 - 0.17 * k4 + epsilon6], [x4 + 0.34 * k4 - epsilon6, y4 - 0.1 * k4 - epsilon6]]).stream(pointStream);
    maltaPoint = malta.translate([x4 + 0.29 * k4, y4 - 0.065 * k4]).clipExtent([[x4 + 0.24 * k4 + epsilon6, y4 - 0.1 * k4 + epsilon6], [x4 + 0.34 * k4 - epsilon6, y4 - 0.03 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  conicConformalEurope.fitExtent = function(extent, object3) {
    return fitExtent4(conicConformalEurope, extent, object3);
  };
  conicConformalEurope.fitSize = function(size, object3) {
    return fitSize4(conicConformalEurope, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return conicConformalEurope;
  }
  conicConformalEurope.drawCompositionBorders = function(context) {
    var ul, ur, ld, ll;
    ul = europe([42.45755610828648, 63.343658547914934]);
    ur = europe([52.65837266667029, 59.35045080290929]);
    ld = europe([47.19754502247785, 56.12653496548117]);
    ll = europe([37.673034273363044, 59.61638268506111]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([59.41110754003403, 62.35069727399336]);
    ur = europe([66.75050228640794, 57.11797303636038]);
    ld = europe([60.236065725110436, 54.63331433818992]);
    ll = europe([52.65837313153311, 59.350450804599355]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([48.81091130080243, 66.93353402634641]);
    ur = europe([59.41110730654679, 62.35069740653086]);
    ld = europe([52.6583728974441, 59.3504509222445]);
    ll = europe([42.45755631675751, 63.34365868805821]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([31.054198418446475, 52.1080673766184]);
    ur = europe([39.09869284884117, 49.400700047190554]);
    ld = europe([36.0580811499175, 46.02944174908498]);
    ll = europe([28.690508588835726, 48.433126979386415]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([33.977877745912025, 55.849945501331]);
    ur = europe([42.75328432167726, 52.78455122462353]);
    ld = europe([39.09869297540224, 49.400700176148625]);
    ll = europe([31.05419851807008, 52.10806751810923]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([52.658372900759296, 59.35045068526415]);
    ur = europe([60.23606549583304, 54.63331423800264]);
    ld = europe([54.6756370953122, 51.892298789399455]);
    ll = europe([47.19754524788189, 56.126534861222794]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([47.19754506082455, 56.126534735591456]);
    ur = europe([54.675636900123514, 51.892298681337095]);
    ld = europe([49.94448648951486, 48.98775484983285]);
    ll = europe([42.75328468716108, 52.78455126060818]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([42.75328453416769, 52.78455113209101]);
    ur = europe([49.94448632339758, 48.98775473706457]);
    ld = europe([45.912339990394315, 45.99361784987003]);
    ll = europe([39.09869317356607, 49.40070009378711]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([37.673034114296634, 59.61638254183119]);
    ur = europe([47.197544835420544, 56.126534839849846]);
    ld = europe([42.75328447467064, 52.78455135314068]);
    ll = europe([33.977877870363905, 55.849945644671145]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([44.56748486446032, 57.26489367845818]);
    ld = europe([43.9335791193588, 53.746540942601726]);
    ll = europe([43, 56]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = europe([37.673034114296634, 59.61638254183119]);
    ur = europe([40.25902691953466, 58.83002044222639]);
    ld = europe([38.458270492742024, 57.26232178028002]);
    ll = europe([35.97754948030156, 58.00266637992386]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
  };
  conicConformalEurope.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return conicConformalEurope.scale(750);
}
var init_conicConformalEurope = __esm({
  "node_modules/d3-composite-projections/src/conicConformalEurope.js"() {
    init_math4();
    init_src5();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/conicConformalNetherlands.js
function multiplex11(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].point(x4, y4);
      }
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].sphere();
      }
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineStart();
      }
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineEnd();
      }
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonStart();
      }
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonEnd();
      }
    }
  };
}
function conicConformalNetherlands_default() {
  var cache, cacheStream, netherlandsMainland = conicConformal_default3().rotate([-5.5, -52.2]).parallels([0, 60]), netherlandsMainlandPoint, bonaire = mercator_default3().center([-68.25, 12.2]), bonairePoint, sabaSintEustatius = mercator_default3().center([-63.1, 17.5]), sabaSintEustatiusPoint, point5, pointStream = {
    point: function(x4, y4) {
      point5 = [x4, y4];
    }
  };
  function conicConformalNetherlands(coordinates2) {
    const [x4, y4] = coordinates2;
    return point5 = null, (netherlandsMainlandPoint.point(x4, y4), point5) || (bonairePoint.point(x4, y4), point5) || (sabaSintEustatiusPoint.point(x4, y4), point5);
  }
  conicConformalNetherlands.invert = function(coordinates2) {
    var k4 = netherlandsMainland.scale(), t2 = netherlandsMainland.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= -67e-4 && y4 < 15e-4 && x4 >= -0.0232 && x4 < -0.0154 ? bonaire : y4 >= -0.022 && y4 < -0.014 && x4 >= -0.023 && x4 < -0.014 ? sabaSintEustatius : netherlandsMainland).invert(coordinates2);
  };
  conicConformalNetherlands.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex11([
      netherlandsMainland.stream(cacheStream = stream),
      bonaire.stream(stream),
      sabaSintEustatius.stream(stream)
    ]);
  };
  conicConformalNetherlands.precision = function(_2) {
    if (!arguments.length)
      return netherlandsMainland.precision();
    netherlandsMainland.precision(_2);
    bonaire.precision(_2);
    sabaSintEustatius.precision(_2);
    return reset();
  };
  conicConformalNetherlands.scale = function(_2) {
    if (!arguments.length)
      return netherlandsMainland.scale();
    netherlandsMainland.scale(_2);
    bonaire.scale(_2);
    sabaSintEustatius.scale(_2);
    return conicConformalNetherlands.translate(netherlandsMainland.translate());
  };
  conicConformalNetherlands.translate = function(_2) {
    if (!arguments.length)
      return netherlandsMainland.translate();
    const k4 = netherlandsMainland.scale(), x4 = +_2[0], y4 = +_2[1];
    netherlandsMainlandPoint = netherlandsMainland.translate(_2).clipExtent([
      [x4 - 0.0245 * k4, y4 - 0.026 * k4],
      [x4 + 0.023 * k4, y4 + 0.026 * k4]
    ]).stream(pointStream);
    bonairePoint = bonaire.translate([x4 - 0.0186 * k4, y4 - 325e-5 * k4]).clipExtent([
      [x4 - 0.0232 * k4 + epsilon6, y4 - 67e-4 * k4 + epsilon6],
      [x4 - 0.0154 * k4 - epsilon6, y4 + 15e-4 * k4 - epsilon6]
    ]).stream(pointStream);
    sabaSintEustatiusPoint = sabaSintEustatius.translate([x4 - 0.0185 * k4, y4 - 0.017 * k4]).clipExtent([
      [x4 - 0.023 * k4 + epsilon6, y4 - 0.022 * k4 + epsilon6],
      [x4 - 0.014 * k4 - epsilon6, y4 - 0.014 * k4 - epsilon6]
    ]).stream(pointStream);
    return reset();
  };
  conicConformalNetherlands.fitExtent = function(extent, object3) {
    return fitExtent4(conicConformalNetherlands, extent, object3);
  };
  conicConformalNetherlands.fitSize = function(size, object3) {
    return fitSize4(conicConformalNetherlands, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return conicConformalNetherlands;
  }
  conicConformalNetherlands.drawCompositionBorders = function(context) {
    var ulbonaire = netherlandsMainland([3.30573, 52.5562]);
    var urbonaire = netherlandsMainland([4.043, 52.572]);
    var ldbonaire = netherlandsMainland([4.0646, 52.1017]);
    var llbonaire = netherlandsMainland([3.3382, 52.0861]);
    var ulsabaSintEustatius = netherlandsMainland([3.262, 53.439]);
    var ursabaSintEustatius = netherlandsMainland([4.1373, 53.4571]);
    var ldsabaSintEustatius = netherlandsMainland([4.1574, 52.9946]);
    var llsabaSintEustatius = netherlandsMainland([3.2951, 52.9768]);
    context.moveTo(ulbonaire[0], ulbonaire[1]);
    context.lineTo(urbonaire[0], urbonaire[1]);
    context.lineTo(ldbonaire[0], ldbonaire[1]);
    context.lineTo(ldbonaire[0], ldbonaire[1]);
    context.lineTo(llbonaire[0], llbonaire[1]);
    context.closePath();
    context.moveTo(ulsabaSintEustatius[0], ulsabaSintEustatius[1]);
    context.lineTo(ursabaSintEustatius[0], ursabaSintEustatius[1]);
    context.lineTo(ldsabaSintEustatius[0], ldsabaSintEustatius[1]);
    context.lineTo(ldsabaSintEustatius[0], ldsabaSintEustatius[1]);
    context.lineTo(llsabaSintEustatius[0], llsabaSintEustatius[1]);
    context.closePath();
  };
  conicConformalNetherlands.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return conicConformalNetherlands.scale(4200);
}
var init_conicConformalNetherlands = __esm({
  "node_modules/d3-composite-projections/src/conicConformalNetherlands.js"() {
    init_math4();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/mercatorMalaysia.js
function multiplex12(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].point(x4, y4);
      }
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].sphere();
      }
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineStart();
      }
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineEnd();
      }
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonStart();
      }
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonEnd();
      }
    }
  };
}
function mercatorMalaysia_default() {
  var cache, cacheStream, peninsular = mercator_default3().center([105.25, 4]), peninsularPoint, borneo = mercator_default3().center([118.65, 2.86]), borneoPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function mercatorMalaysia(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (peninsularPoint.point(x4, y4), point5) || (borneoPoint.point(x4, y4), point5);
  }
  mercatorMalaysia.invert = function(coordinates2) {
    var k4 = peninsular.scale(), t2 = peninsular.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= -0.0521 && y4 < 0.0229 && x4 >= -0.0111 && x4 < 0.1 ? borneo : peninsular).invert(coordinates2);
  };
  mercatorMalaysia.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex12([peninsular.stream(cacheStream = stream), borneo.stream(stream)]);
  };
  mercatorMalaysia.precision = function(_2) {
    if (!arguments.length) {
      return peninsular.precision();
    }
    peninsular.precision(_2);
    borneo.precision(_2);
    return reset();
  };
  mercatorMalaysia.scale = function(_2) {
    if (!arguments.length) {
      return peninsular.scale();
    }
    peninsular.scale(_2);
    borneo.scale(_2 * 0.615);
    return mercatorMalaysia.translate(peninsular.translate());
  };
  mercatorMalaysia.translate = function(_2) {
    if (!arguments.length) {
      return peninsular.translate();
    }
    var k4 = peninsular.scale(), x4 = +_2[0], y4 = +_2[1];
    peninsularPoint = peninsular.translate(_2).clipExtent([[x4 - 0.11 * k4, y4 - 0.0521 * k4], [x4 - 0.0111 * k4, y4 + 0.0521 * k4]]).stream(pointStream);
    borneoPoint = borneo.translate([x4 + 0.09 * k4, y4 - 0 * k4]).clipExtent([[x4 - 0.0111 * k4 + epsilon6, y4 - 0.0521 * k4 + epsilon6], [x4 + 0.1 * k4 - epsilon6, y4 + 0.024 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  mercatorMalaysia.fitExtent = function(extent, object3) {
    return fitExtent4(mercatorMalaysia, extent, object3);
  };
  mercatorMalaysia.fitSize = function(size, object3) {
    return fitSize4(mercatorMalaysia, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return mercatorMalaysia;
  }
  mercatorMalaysia.drawCompositionBorders = function(context) {
    var llbor = peninsular([106.3214, 2.0228]);
    var lmbor = peninsular([105.1843, 2.3761]);
    var lrbor = peninsular([104.2151, 3.3618]);
    var llrbor = peninsular([104.215, 4.5651]);
    context.moveTo(llbor[0], llbor[1]);
    context.lineTo(lmbor[0], lmbor[1]);
    context.lineTo(lrbor[0], lrbor[1]);
    context.lineTo(llrbor[0], llrbor[1]);
  };
  mercatorMalaysia.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return mercatorMalaysia.scale(4800);
}
var init_mercatorMalaysia = __esm({
  "node_modules/d3-composite-projections/src/mercatorMalaysia.js"() {
    init_math4();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/mercatorEquatorialGuinea.js
function multiplex13(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].point(x4, y4);
      }
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].sphere();
      }
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineStart();
      }
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].lineEnd();
      }
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonStart();
      }
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) {
        streams[i2].polygonEnd();
      }
    }
  };
}
function mercatorEquatorialGuinea_default() {
  var cache, cacheStream, continent = mercator_default3().rotate([-9.5, -1.5]), continentPoint, bioko = mercator_default3().rotate([-8.6, -3.5]), biokoPoint, annobon = mercator_default3().rotate([-5.6, 1.45]), annobonPoint, point5, pointStream = { point: function(x4, y4) {
    point5 = [x4, y4];
  } };
  function mercatorEquatorialGuinea(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (continentPoint.point(x4, y4), point5) || (biokoPoint.point(x4, y4), point5) || (annobonPoint.point(x4, y4), point5);
  }
  mercatorEquatorialGuinea.invert = function(coordinates2) {
    var k4 = continent.scale(), t2 = continent.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= -0.02 && y4 < 0 && x4 >= -0.038 && x4 < -5e-3 ? bioko : y4 >= 0 && y4 < 0.02 && x4 >= -0.038 && x4 < -5e-3 ? annobon : continent).invert(coordinates2);
  };
  mercatorEquatorialGuinea.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex13([continent.stream(cacheStream = stream), bioko.stream(stream), annobon.stream(stream)]);
  };
  mercatorEquatorialGuinea.precision = function(_2) {
    if (!arguments.length) {
      return continent.precision();
    }
    continent.precision(_2);
    bioko.precision(_2);
    annobon.precision(_2);
    return reset();
  };
  mercatorEquatorialGuinea.scale = function(_2) {
    if (!arguments.length) {
      return continent.scale();
    }
    continent.scale(_2);
    bioko.scale(_2 * 1.5);
    annobon.scale(_2 * 4);
    return mercatorEquatorialGuinea.translate(continent.translate());
  };
  mercatorEquatorialGuinea.translate = function(_2) {
    if (!arguments.length) {
      return continent.translate();
    }
    var k4 = continent.scale(), x4 = +_2[0], y4 = +_2[1];
    continentPoint = continent.translate(_2).clipExtent([[x4 - 5e-3 * k4, y4 - 0.02 * k4], [x4 + 0.038 * k4, y4 + 0.02 * k4]]).stream(pointStream);
    biokoPoint = bioko.translate([x4 - 0.025 * k4, y4 - 0.01 * k4]).clipExtent([[x4 - 0.038 * k4 + epsilon6, y4 - 0.02 * k4 + epsilon6], [x4 - 5e-3 * k4 - epsilon6, y4 + 0 * k4 - epsilon6]]).stream(pointStream);
    annobonPoint = annobon.translate([x4 - 0.025 * k4, y4 + 0.01 * k4]).clipExtent([[x4 - 0.038 * k4 + epsilon6, y4 - 0 * k4 + epsilon6], [x4 - 5e-3 * k4 - epsilon6, y4 + 0.02 * k4 - epsilon6]]).stream(pointStream);
    return reset();
  };
  mercatorEquatorialGuinea.fitExtent = function(extent, object3) {
    return fitExtent4(mercatorEquatorialGuinea, extent, object3);
  };
  mercatorEquatorialGuinea.fitSize = function(size, object3) {
    return fitSize4(mercatorEquatorialGuinea, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return mercatorEquatorialGuinea;
  }
  mercatorEquatorialGuinea.drawCompositionBorders = function(context) {
    var ul, ur, ld, ll;
    ul = continent([9.21327272751682, 2.645820439454123]);
    ur = continent([11.679126293239872, 2.644755519268689]);
    ld = continent([11.676845389029227, 0.35307824637606433]);
    ll = continent([9.213572917774014, 0.35414205204417754]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = continent([7.320873711543669, 2.64475551449975]);
    ur = continent([9.213272722738658, 2.645820434679803]);
    ld = continent([9.213422896480349, 1.4999812505283054]);
    ll = continent([7.322014760520787, 1.4989168878985566]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
    ul = continent([7.3220147605302905, 1.4989168783492766]);
    ur = continent([9.213422896481598, 1.499981240979021]);
    ld = continent([9.213572912999604, 0.354142056817247]);
    ll = continent([7.323154615739809, 0.353078251154504]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
  };
  mercatorEquatorialGuinea.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return mercatorEquatorialGuinea.scale(12e3);
}
var init_mercatorEquatorialGuinea = __esm({
  "node_modules/d3-composite-projections/src/mercatorEquatorialGuinea.js"() {
    init_math4();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/src/albersUk.js
function multiplex14(streams) {
  var n2 = streams.length;
  return {
    point: function(x4, y4) {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].point(x4, y4);
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].sphere();
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].lineStart();
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].lineEnd();
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].polygonStart();
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2)
        streams[i2].polygonEnd();
    }
  };
}
function albersUk_default() {
  var cache, cacheStream, main = albers_default3().rotate([4.4, 0.8]).center([0, 55.4]).parallels([50, 60]), mainPoint, shetland = albers_default3().rotate([4.4, 0.8]).center([0, 55.4]).parallels([50, 60]), shetlandPoint, point5, pointStream = {
    point: function(x4, y4) {
      point5 = [x4, y4];
    }
  };
  var shetlandBbox = [
    [-2.1, 70],
    [-0.7, 59.8]
  ];
  function albersUk(coordinates2) {
    var x4 = coordinates2[0], y4 = coordinates2[1];
    return point5 = null, (mainPoint.point(x4, y4), point5) || (shetlandPoint.point(x4, y4), point5);
  }
  albersUk.invert = function(coordinates2) {
    var k4 = main.scale(), t2 = main.translate(), x4 = (coordinates2[0] - t2[0]) / k4, y4 = (coordinates2[1] - t2[1]) / k4;
    return (y4 >= -0.089 && y4 < 0.06 && x4 >= 0.029 && x4 < 0.046 ? shetland : main).invert(coordinates2);
  };
  albersUk.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex14([
      main.stream(cacheStream = stream),
      shetland.stream(stream)
    ]);
  };
  albersUk.precision = function(_2) {
    if (!arguments.length)
      return main.precision();
    main.precision(_2), shetland.precision(_2);
    return reset();
  };
  albersUk.scale = function(_2) {
    if (!arguments.length)
      return main.scale();
    main.scale(_2), shetland.scale(_2);
    return albersUk.translate(main.translate());
  };
  albersUk.translate = function(_2) {
    if (!arguments.length)
      return main.translate();
    var k4 = main.scale(), x4 = +_2[0], y4 = +_2[1];
    mainPoint = main.translate(_2).clipExtent([
      [x4 - 0.065 * k4, y4 - 0.089 * k4],
      [x4 + 0.075 * k4, y4 + 0.089 * k4]
    ]).stream(pointStream);
    shetlandPoint = shetland.translate([x4 + 0.01 * k4, y4 + 0.025 * k4]).clipExtent([
      [x4 + 0.029 * k4 + epsilon6, y4 - 0.089 * k4 + epsilon6],
      [x4 + 0.046 * k4 - epsilon6, y4 - 0.06 * k4 - epsilon6]
    ]).stream(pointStream);
    return reset();
  };
  albersUk.fitExtent = function(extent, object3) {
    return fitExtent4(albersUk, extent, object3);
  };
  albersUk.fitSize = function(size, object3) {
    return fitSize4(albersUk, size, object3);
  };
  function reset() {
    cache = cacheStream = null;
    return albersUk;
  }
  albersUk.drawCompositionBorders = function(context) {
    var ul, ur, ld, ll;
    ul = main([-1.113205870242365, 59.64920050773357]);
    ur = main([0.807899092399606, 59.59085836472269]);
    ld = main([0.5778611961420386, 57.93467822832577]);
    ll = main([-1.25867782078448, 57.99029450085142]);
    context.moveTo(ul[0], ul[1]);
    context.lineTo(ur[0], ur[1]);
    context.lineTo(ld[0], ld[1]);
    context.lineTo(ll[0], ll[1]);
    context.closePath();
  };
  albersUk.getCompositionBorders = function() {
    var context = path_default4();
    this.drawCompositionBorders(context);
    return context.toString();
  };
  return albersUk.scale(2800);
}
var init_albersUk = __esm({
  "node_modules/d3-composite-projections/src/albersUk.js"() {
    init_math4();
    init_src5();
    init_fit4();
    init_src6();
  }
});

// node_modules/d3-composite-projections/index.js
var d3_composite_projections_exports = {};
__export(d3_composite_projections_exports, {
  geoAlbersUk: () => albersUk_default,
  geoAlbersUsa: () => albersUsa_default4,
  geoAlbersUsaTerritories: () => albersUsaTerritories_default,
  geoConicConformalEurope: () => conicConformalEurope_default,
  geoConicConformalFrance: () => conicConformalFrance_default,
  geoConicConformalNetherlands: () => conicConformalNetherlands_default,
  geoConicConformalPortugal: () => conicConformalPortugal_default,
  geoConicConformalSpain: () => conicConformalSpain_default,
  geoConicEquidistantJapan: () => conicEquidistantJapan_default,
  geoMercatorEcuador: () => mercatorEcuador_default,
  geoMercatorEquatorialGuinea: () => mercatorEquatorialGuinea_default,
  geoMercatorMalaysia: () => mercatorMalaysia_default,
  geoTransverseMercatorChile: () => transverseMercatorChile_default
});
var init_d3_composite_projections = __esm({
  "node_modules/d3-composite-projections/index.js"() {
    init_albersUsa4();
    init_albersUsaTerritories();
    init_conicConformalSpain();
    init_conicConformalPortugal();
    init_mercatorEcuador();
    init_transverseMercatorChile();
    init_conicEquidistantJapan();
    init_conicConformalFrance();
    init_conicConformalEurope();
    init_conicConformalNetherlands();
    init_mercatorMalaysia();
    init_mercatorEquatorialGuinea();
    init_albersUk();
  }
});

// node_modules/@antv/data-set/lib/util/get-geo-projection.js
var require_get_geo_projection = __commonJS({
  "node_modules/@antv/data-set/lib/util/get-geo-projection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var d3Geo = tslib_1.__importStar((init_d3_geo(), d3_geo_exports));
    var d3GeoProjection = tslib_1.__importStar((init_d3_geo_projection(), d3_geo_projection_exports));
    var d3CompositeProjection = tslib_1.__importStar((init_d3_composite_projections(), d3_composite_projections_exports));
    exports.default = function(projection4, exportRaw) {
      if (exportRaw === void 0) {
        exportRaw = false;
      }
      if (util_1.isFunction(projection4)) {
        return exportRaw ? projection4 : projection4();
      }
      if (util_1.isString(projection4)) {
        if (d3Geo[projection4]) {
          return exportRaw ? d3Geo[projection4] : d3Geo[projection4]();
        }
        if (d3GeoProjection[projection4]) {
          return exportRaw ? d3GeoProjection[projection4] : d3GeoProjection[projection4]();
        }
        if (d3CompositeProjection[projection4]) {
          return exportRaw ? d3CompositeProjection[projection4] : d3CompositeProjection[projection4]();
        }
      }
      return null;
    };
  }
});

// node_modules/@antv/data-set/lib/api/geo.js
var require_geo = __commonJS({
  "node_modules/@antv/data-set/lib/api/geo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var d3_geo_1 = (init_d3_geo(), d3_geo_exports);
    var d3_geo_projection_1 = (init_d3_geo_projection(), d3_geo_projection_exports);
    var view_1 = require_view();
    var get_geo_projection_1 = tslib_1.__importDefault(require_get_geo_projection());
    var api = {
      geoArea: function(feature2) {
        return d3_geo_1.geoArea(feature2);
      },
      geoAreaByName: function(name) {
        return d3_geo_1.geoArea(this.geoFeatureByName(name));
      },
      geoCentroid: function(feature2) {
        return d3_geo_1.geoCentroid(feature2);
      },
      geoCentroidByName: function(name) {
        return d3_geo_1.geoCentroid(this.geoFeatureByName(name));
      },
      geoDistance: function(p1, p2) {
        return d3_geo_1.geoDistance(p1, p2);
      },
      geoLength: function(feature2) {
        return d3_geo_1.geoLength(feature2);
      },
      geoLengthByName: function(name) {
        return d3_geo_1.geoLength(this.geoFeatureByName(name));
      },
      geoContains: function(feature2, position) {
        return d3_geo_1.geoContains(feature2, position);
      },
      geoFeatureByName: function(name) {
        var rows = this.rows;
        var result;
        rows.some(function(feature2) {
          if (feature2.name === name) {
            result = feature2;
            return true;
          }
          return false;
        });
        return result;
      },
      geoFeatureByPosition: function(position) {
        var rows = this.rows;
        var result;
        rows.some(function(feature2) {
          if (d3_geo_1.geoContains(feature2, position)) {
            result = feature2;
            return true;
          }
          return false;
        });
        return result;
      },
      geoNameByPosition: function(position) {
        var feature2 = this.geoFeatureByPosition(position);
        if (feature2) {
          return feature2.name;
        }
      },
      getGeoProjection: get_geo_projection_1.default,
      geoProject: function(feature2, projection4, exportRaw) {
        projection4 = get_geo_projection_1.default(projection4, exportRaw);
        return d3_geo_projection_1.geoProject(feature2, projection4);
      },
      geoProjectByName: function(name, projection4, exportRaw) {
        projection4 = get_geo_projection_1.default(projection4, exportRaw);
        return d3_geo_projection_1.geoProject(this.geoFeatureByName(name), projection4);
      },
      geoProjectPosition: function(position, projection4, exportRaw) {
        var func = get_geo_projection_1.default(projection4, exportRaw);
        return func(position);
      },
      geoProjectInvert: function(position, projection4, exportRaw) {
        var func = get_geo_projection_1.default(projection4, exportRaw);
        return func.invert(position);
      }
    };
    util_1.assign(view_1.View.prototype, api);
  }
});

// node_modules/@antv/data-set/lib/api/hierarchy.js
var require_hierarchy = __commonJS({
  "node_modules/@antv/data-set/lib/api/hierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var view_1 = require_view();
    util_1.assign(view_1.View.prototype, {
      getAllNodes: function() {
        var nodes = [];
        var root = this.root;
        if (root && root.each) {
          root.each(function(node) {
            nodes.push(node);
          });
        } else if (root && root.eachNode) {
          root.eachNode(function(node) {
            nodes.push(node);
          });
        }
        return nodes;
      },
      getAllLinks: function() {
        var links = [];
        var nodes = [this.root];
        var node;
        while (node = nodes.pop()) {
          var children = node.children;
          if (children) {
            children.forEach(function(child) {
              links.push({
                source: node,
                target: child
              });
              nodes.push(child);
            });
          }
        }
        return links;
      }
    });
    util_1.assign(view_1.View.prototype, {
      getAllEdges: view_1.View.prototype.getAllLinks
    });
  }
});

// node_modules/@antv/data-set/lib/util/simple-sort-by.js
var require_simple_sort_by = __commonJS({
  "node_modules/@antv/data-set/lib/util/simple-sort-by.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    function sortBy(arr, keys) {
      if (keys === void 0) {
        keys = [];
      }
      var comparer = void 0;
      if (util_1.isFunction(keys)) {
        comparer = keys;
      } else if (util_1.isArray(keys)) {
        comparer = function(a3, b2) {
          for (var i2 = 0; i2 < keys.length; i2++) {
            var key = keys[i2];
            if (a3[key] < b2[key]) {
              return -1;
            }
            if (a3[key] > b2[key]) {
              return 1;
            }
          }
          return 0;
        };
      } else if (util_1.isString(keys)) {
        comparer = function(a3, b2) {
          if (a3[keys] < b2[keys]) {
            return -1;
          }
          if (a3[keys] > b2[keys]) {
            return 1;
          }
          return 0;
        };
      }
      return arr.sort(comparer);
    }
    exports.default = sortBy;
  }
});

// node_modules/@antv/data-set/lib/util/partition.js
var require_partition = __commonJS({
  "node_modules/@antv/data-set/lib/util/partition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var simple_sort_by_1 = tslib_1.__importDefault(require_simple_sort_by());
    exports.default = function(rows, group_by, order_by) {
      if (order_by === void 0) {
        order_by = [];
      }
      var newRows = rows;
      if (order_by && order_by.length) {
        newRows = simple_sort_by_1.default(rows, order_by);
      }
      var groupingFn;
      if (util_1.isFunction(group_by)) {
        groupingFn = group_by;
      } else if (util_1.isArray(group_by)) {
        groupingFn = function(row) {
          return "_" + group_by.map(function(col) {
            return row[col];
          }).join("-");
        };
      } else if (util_1.isString(group_by)) {
        groupingFn = function(row) {
          return "_" + row[group_by];
        };
      }
      var groups2 = util_1.groupBy(newRows, groupingFn);
      return groups2;
    };
  }
});

// node_modules/@antv/data-set/lib/api/partition.js
var require_partition2 = __commonJS({
  "node_modules/@antv/data-set/lib/api/partition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var partition_1 = tslib_1.__importDefault(require_partition());
    var view_1 = require_view();
    util_1.assign(view_1.View.prototype, {
      partition: function(group_by, order_by) {
        if (order_by === void 0) {
          order_by = [];
        }
        return partition_1.default(this.rows, group_by, order_by);
      },
      group: function(group_by, order_by) {
        if (order_by === void 0) {
          order_by = [];
        }
        var groups2 = this.partition(group_by, order_by);
        return util_1.values(groups2);
      },
      groups: function(group_by, order_by) {
        if (order_by === void 0) {
          order_by = [];
        }
        return this.group(group_by, order_by);
      }
    });
  }
});

// node_modules/simple-statistics/dist/simple-statistics.mjs
var simple_statistics_exports = {};
__export(simple_statistics_exports, {
  BayesianClassifier: () => ut,
  PerceptronModel: () => ft,
  addToMean: () => Z,
  average: () => e,
  bayesian: () => ut,
  bernoulliDistribution: () => Mt,
  binomialDistribution: () => dt,
  bisect: () => Dt,
  chiSquaredDistributionTable: () => bt,
  chiSquaredGoodnessOfFit: () => qt,
  chunk: () => z,
  ckmeans: () => B2,
  combinations: () => X,
  combinationsReplacement: () => Y,
  combineMeans: () => $,
  combineVariances: () => tt,
  cumulativeStdNormalProbability: () => Nt,
  epsilon: () => lt,
  equalIntervalBreaks: () => G,
  erf: () => zt,
  errorFunction: () => zt,
  extent: () => c,
  extentSorted: () => M3,
  factorial: () => st,
  gamma: () => gt,
  gammaln: () => wt,
  geometricMean: () => rt,
  harmonicMean: () => nt,
  interquartileRange: () => _,
  inverseErrorFunction: () => Ft,
  iqr: () => _,
  kde: () => It,
  kernelDensityEstimation: () => It,
  linearRegression: () => t,
  linearRegressionLine: () => r,
  mad: () => N,
  max: () => v,
  maxSorted: () => w2,
  mean: () => e,
  median: () => A5,
  medianAbsoluteDeviation: () => N,
  medianSorted: () => et,
  min: () => g,
  minSorted: () => p,
  mode: () => l,
  modeFast: () => s,
  modeSorted: () => u,
  numericSort: () => f,
  perceptron: () => ft,
  permutationTest: () => Tt,
  permutationsHeap: () => W,
  poissonDistribution: () => mt,
  probit: () => St,
  product: () => m,
  quantile: () => y,
  quantileRank: () => C,
  quantileRankSorted: () => k2,
  quantileSorted: () => b,
  quickselect: () => q,
  rSquared: () => h,
  rms: () => ot,
  rootMeanSquare: () => ot,
  sample: () => U,
  sampleCorrelation: () => O,
  sampleCovariance: () => H,
  sampleKurtosis: () => R,
  sampleSkewness: () => Q,
  sampleStandardDeviation: () => L,
  sampleVariance: () => J,
  sampleWithReplacement: () => F,
  shuffle: () => T,
  shuffleInPlace: () => S,
  sign: () => Ut,
  standardDeviation: () => i,
  standardNormalTable: () => _t,
  subtractFromMean: () => at,
  sum: () => n,
  sumNthPowerDeviations: () => a,
  sumSimple: () => d,
  tTest: () => it,
  tTestTwoSample: () => ht,
  uniqueCountSorted: () => D,
  variance: () => o,
  zScore: () => Pt
});
function t(t2) {
  var r2, n2, e3 = t2.length;
  if (e3 === 1)
    r2 = 0, n2 = t2[0][1];
  else {
    for (var a3, o2, i2, h2 = 0, u2 = 0, f2 = 0, l2 = 0, s3 = 0; s3 < e3; s3++)
      h2 += o2 = (a3 = t2[s3])[0], u2 += i2 = a3[1], f2 += o2 * o2, l2 += o2 * i2;
    n2 = u2 / e3 - (r2 = (e3 * l2 - h2 * u2) / (e3 * f2 - h2 * h2)) * h2 / e3;
  }
  return { m: r2, b: n2 };
}
function r(t2) {
  return function(r2) {
    return t2.b + t2.m * r2;
  };
}
function n(t2) {
  if (t2.length === 0)
    return 0;
  for (var r2, n2 = t2[0], e3 = 0, a3 = 1; a3 < t2.length; a3++)
    r2 = n2 + t2[a3], Math.abs(n2) >= Math.abs(t2[a3]) ? e3 += n2 - r2 + t2[a3] : e3 += t2[a3] - r2 + n2, n2 = r2;
  return n2 + e3;
}
function e(t2) {
  if (t2.length === 0)
    throw new Error("mean requires at least one data point");
  return n(t2) / t2.length;
}
function a(t2, r2) {
  var n2, a3, o2 = e(t2), i2 = 0;
  if (r2 === 2)
    for (a3 = 0; a3 < t2.length; a3++)
      i2 += (n2 = t2[a3] - o2) * n2;
  else
    for (a3 = 0; a3 < t2.length; a3++)
      i2 += Math.pow(t2[a3] - o2, r2);
  return i2;
}
function o(t2) {
  if (t2.length === 0)
    throw new Error("variance requires at least one data point");
  return a(t2, 2) / t2.length;
}
function i(t2) {
  if (t2.length === 1)
    return 0;
  var r2 = o(t2);
  return Math.sqrt(r2);
}
function h(t2, r2) {
  if (t2.length < 2)
    return 1;
  for (var n2 = 0, e3 = 0; e3 < t2.length; e3++)
    n2 += t2[e3][1];
  for (var a3 = n2 / t2.length, o2 = 0, i2 = 0; i2 < t2.length; i2++)
    o2 += Math.pow(a3 - t2[i2][1], 2);
  for (var h2 = 0, u2 = 0; u2 < t2.length; u2++)
    h2 += Math.pow(t2[u2][1] - r2(t2[u2][0]), 2);
  return 1 - h2 / o2;
}
function u(t2) {
  if (t2.length === 0)
    throw new Error("mode requires at least one data point");
  if (t2.length === 1)
    return t2[0];
  for (var r2 = t2[0], n2 = NaN, e3 = 0, a3 = 1, o2 = 1; o2 < t2.length + 1; o2++)
    t2[o2] !== r2 ? (a3 > e3 && (e3 = a3, n2 = r2), a3 = 1, r2 = t2[o2]) : a3++;
  return n2;
}
function f(t2) {
  return t2.slice().sort(function(t3, r2) {
    return t3 - r2;
  });
}
function l(t2) {
  return u(f(t2));
}
function s(t2) {
  for (var r2, n2 = new Map(), e3 = 0, a3 = 0; a3 < t2.length; a3++) {
    var o2 = n2.get(t2[a3]);
    o2 === void 0 ? o2 = 1 : o2++, o2 > e3 && (r2 = t2[a3], e3 = o2), n2.set(t2[a3], o2);
  }
  if (e3 === 0)
    throw new Error("mode requires at last one data point");
  return r2;
}
function g(t2) {
  if (t2.length === 0)
    throw new Error("min requires at least one data point");
  for (var r2 = t2[0], n2 = 1; n2 < t2.length; n2++)
    t2[n2] < r2 && (r2 = t2[n2]);
  return r2;
}
function v(t2) {
  if (t2.length === 0)
    throw new Error("max requires at least one data point");
  for (var r2 = t2[0], n2 = 1; n2 < t2.length; n2++)
    t2[n2] > r2 && (r2 = t2[n2]);
  return r2;
}
function c(t2) {
  if (t2.length === 0)
    throw new Error("extent requires at least one data point");
  for (var r2 = t2[0], n2 = t2[0], e3 = 1; e3 < t2.length; e3++)
    t2[e3] > n2 && (n2 = t2[e3]), t2[e3] < r2 && (r2 = t2[e3]);
  return [r2, n2];
}
function p(t2) {
  return t2[0];
}
function w2(t2) {
  return t2[t2.length - 1];
}
function M3(t2) {
  return [t2[0], t2[t2.length - 1]];
}
function d(t2) {
  for (var r2 = 0, n2 = 0; n2 < t2.length; n2++)
    r2 += t2[n2];
  return r2;
}
function m(t2) {
  for (var r2 = 1, n2 = 0; n2 < t2.length; n2++)
    r2 *= t2[n2];
  return r2;
}
function b(t2, r2) {
  var n2 = t2.length * r2;
  if (t2.length === 0)
    throw new Error("quantile requires at least one data point.");
  if (r2 < 0 || r2 > 1)
    throw new Error("quantiles must be between 0 and 1");
  return r2 === 1 ? t2[t2.length - 1] : r2 === 0 ? t2[0] : n2 % 1 != 0 ? t2[Math.ceil(n2) - 1] : t2.length % 2 == 0 ? (t2[n2 - 1] + t2[n2]) / 2 : t2[n2];
}
function q(t2, r2, n2, e3) {
  for (n2 = n2 || 0, e3 = e3 || t2.length - 1; e3 > n2; ) {
    if (e3 - n2 > 600) {
      var a3 = e3 - n2 + 1, o2 = r2 - n2 + 1, i2 = Math.log(a3), h2 = 0.5 * Math.exp(2 * i2 / 3), u2 = 0.5 * Math.sqrt(i2 * h2 * (a3 - h2) / a3);
      o2 - a3 / 2 < 0 && (u2 *= -1), q(t2, r2, Math.max(n2, Math.floor(r2 - o2 * h2 / a3 + u2)), Math.min(e3, Math.floor(r2 + (a3 - o2) * h2 / a3 + u2)));
    }
    var f2 = t2[r2], l2 = n2, s3 = e3;
    for (E(t2, n2, r2), t2[e3] > f2 && E(t2, n2, e3); l2 < s3; ) {
      for (E(t2, l2, s3), l2++, s3--; t2[l2] < f2; )
        l2++;
      for (; t2[s3] > f2; )
        s3--;
    }
    t2[n2] === f2 ? E(t2, n2, s3) : E(t2, ++s3, e3), s3 <= r2 && (n2 = s3 + 1), r2 <= s3 && (e3 = s3 - 1);
  }
}
function E(t2, r2, n2) {
  var e3 = t2[r2];
  t2[r2] = t2[n2], t2[n2] = e3;
}
function y(t2, r2) {
  var n2 = t2.slice();
  if (Array.isArray(r2)) {
    !function(t3, r3) {
      for (var n3 = [0], e4 = 0; e4 < r3.length; e4++)
        n3.push(P(t3.length, r3[e4]));
      n3.push(t3.length - 1), n3.sort(I);
      var a4 = [0, n3.length - 1];
      for (; a4.length; ) {
        var o2 = Math.ceil(a4.pop()), i2 = Math.floor(a4.pop());
        if (!(o2 - i2 <= 1)) {
          var h2 = Math.floor((i2 + o2) / 2);
          x(t3, n3[h2], Math.floor(n3[i2]), Math.ceil(n3[o2])), a4.push(i2, h2, h2, o2);
        }
      }
    }(n2, r2);
    for (var e3 = [], a3 = 0; a3 < r2.length; a3++)
      e3[a3] = b(n2, r2[a3]);
    return e3;
  }
  return x(n2, P(n2.length, r2), 0, n2.length - 1), b(n2, r2);
}
function x(t2, r2, n2, e3) {
  r2 % 1 == 0 ? q(t2, r2, n2, e3) : (q(t2, r2 = Math.floor(r2), n2, e3), q(t2, r2 + 1, r2 + 1, e3));
}
function I(t2, r2) {
  return t2 - r2;
}
function P(t2, r2) {
  var n2 = t2 * r2;
  return r2 === 1 ? t2 - 1 : r2 === 0 ? 0 : n2 % 1 != 0 ? Math.ceil(n2) - 1 : t2 % 2 == 0 ? n2 - 0.5 : n2;
}
function k2(t2, r2) {
  if (r2 < t2[0])
    return 0;
  if (r2 > t2[t2.length - 1])
    return 1;
  var n2 = function(t3, r3) {
    var n3 = 0, e4 = 0, a4 = t3.length;
    for (; e4 < a4; )
      r3 <= t3[n3 = e4 + a4 >>> 1] ? a4 = n3 : e4 = -~n3;
    return e4;
  }(t2, r2);
  if (t2[n2] !== r2)
    return n2 / t2.length;
  n2++;
  var e3 = function(t3, r3) {
    var n3 = 0, e4 = 0, a4 = t3.length;
    for (; e4 < a4; )
      r3 >= t3[n3 = e4 + a4 >>> 1] ? e4 = -~n3 : a4 = n3;
    return e4;
  }(t2, r2);
  if (e3 === n2)
    return n2 / t2.length;
  var a3 = e3 - n2 + 1;
  return a3 * (e3 + n2) / 2 / a3 / t2.length;
}
function C(t2, r2) {
  return k2(f(t2), r2);
}
function _(t2) {
  var r2 = y(t2, 0.75), n2 = y(t2, 0.25);
  if (typeof r2 == "number" && typeof n2 == "number")
    return r2 - n2;
}
function A5(t2) {
  return +y(t2, 0.5);
}
function N(t2) {
  for (var r2 = A5(t2), n2 = [], e3 = 0; e3 < t2.length; e3++)
    n2.push(Math.abs(t2[e3] - r2));
  return A5(n2);
}
function z(t2, r2) {
  var n2 = [];
  if (r2 < 1)
    throw new Error("chunk size must be a positive number");
  if (Math.floor(r2) !== r2)
    throw new Error("chunk size must be an integer");
  for (var e3 = 0; e3 < t2.length; e3 += r2)
    n2.push(t2.slice(e3, e3 + r2));
  return n2;
}
function F(t2, r2, n2) {
  if (t2.length === 0)
    return [];
  n2 = n2 || Math.random;
  for (var e3 = t2.length, a3 = [], o2 = 0; o2 < r2; o2++) {
    var i2 = Math.floor(n2() * e3);
    a3.push(t2[i2]);
  }
  return a3;
}
function S(t2, r2) {
  r2 = r2 || Math.random;
  for (var n2, e3, a3 = t2.length; a3 > 0; )
    e3 = Math.floor(r2() * a3--), n2 = t2[a3], t2[a3] = t2[e3], t2[e3] = n2;
  return t2;
}
function T(t2, r2) {
  return S(t2.slice().slice(), r2);
}
function U(t2, r2, n2) {
  return T(t2, n2).slice(0, r2);
}
function D(t2) {
  for (var r2, n2 = 0, e3 = 0; e3 < t2.length; e3++)
    e3 !== 0 && t2[e3] === r2 || (r2 = t2[e3], n2++);
  return n2;
}
function K2(t2, r2) {
  for (var n2 = [], e3 = 0; e3 < t2; e3++) {
    for (var a3 = [], o2 = 0; o2 < r2; o2++)
      a3.push(0);
    n2.push(a3);
  }
  return n2;
}
function V(t2, r2, n2, e3) {
  var a3;
  if (t2 > 0) {
    var o2 = (n2[r2] - n2[t2 - 1]) / (r2 - t2 + 1);
    a3 = e3[r2] - e3[t2 - 1] - (r2 - t2 + 1) * o2 * o2;
  } else
    a3 = e3[r2] - n2[r2] * n2[r2] / (r2 + 1);
  return a3 < 0 ? 0 : a3;
}
function j(t2, r2, n2, e3, a3, o2, i2) {
  if (!(t2 > r2)) {
    var h2 = Math.floor((t2 + r2) / 2);
    e3[n2][h2] = e3[n2 - 1][h2 - 1], a3[n2][h2] = h2;
    var u2 = n2;
    t2 > n2 && (u2 = Math.max(u2, a3[n2][t2 - 1] || 0)), u2 = Math.max(u2, a3[n2 - 1][h2] || 0);
    var f2, l2, s3, g2 = h2 - 1;
    r2 < e3.length - 1 && (g2 = Math.min(g2, a3[n2][r2 + 1] || 0));
    for (var v2 = g2; v2 >= u2 && !((f2 = V(v2, h2, o2, i2)) + e3[n2 - 1][u2 - 1] >= e3[n2][h2]); --v2)
      (l2 = V(u2, h2, o2, i2) + e3[n2 - 1][u2 - 1]) < e3[n2][h2] && (e3[n2][h2] = l2, a3[n2][h2] = u2), u2++, (s3 = f2 + e3[n2 - 1][v2 - 1]) < e3[n2][h2] && (e3[n2][h2] = s3, a3[n2][h2] = v2);
    j(t2, h2 - 1, n2, e3, a3, o2, i2), j(h2 + 1, r2, n2, e3, a3, o2, i2);
  }
}
function B2(t2, r2) {
  if (r2 > t2.length)
    throw new Error("cannot generate more classes than there are data values");
  var n2 = f(t2);
  if (D(n2) === 1)
    return [n2];
  var e3 = K2(r2, n2.length), a3 = K2(r2, n2.length);
  !function(t3, r3, n3) {
    for (var e4 = r3[0].length, a4 = t3[Math.floor(e4 / 2)], o3 = [], i3 = [], h3 = 0, u3 = void 0; h3 < e4; ++h3)
      u3 = t3[h3] - a4, h3 === 0 ? (o3.push(u3), i3.push(u3 * u3)) : (o3.push(o3[h3 - 1] + u3), i3.push(i3[h3 - 1] + u3 * u3)), r3[0][h3] = V(0, h3, o3, i3), n3[0][h3] = 0;
    for (var f2 = 1; f2 < r3.length; ++f2)
      j(f2 < r3.length - 1 ? f2 : e4 - 1, e4 - 1, f2, r3, n3, o3, i3);
  }(n2, e3, a3);
  for (var o2 = [], i2 = a3[0].length - 1, h2 = a3.length - 1; h2 >= 0; h2--) {
    var u2 = a3[h2][i2];
    o2[h2] = n2.slice(u2, i2 + 1), h2 > 0 && (i2 = u2 - 1);
  }
  return o2;
}
function G(t2, r2) {
  if (t2.length < 2)
    return t2;
  for (var n2 = g(t2), e3 = v(t2), a3 = [n2], o2 = (e3 - n2) / r2, i2 = 1; i2 < r2; i2++)
    a3.push(a3[0] + o2 * i2);
  return a3.push(e3), a3;
}
function H(t2, r2) {
  if (t2.length !== r2.length)
    throw new Error("sampleCovariance requires samples with equal lengths");
  if (t2.length < 2)
    throw new Error("sampleCovariance requires at least two data points in each sample");
  for (var n2 = e(t2), a3 = e(r2), o2 = 0, i2 = 0; i2 < t2.length; i2++)
    o2 += (t2[i2] - n2) * (r2[i2] - a3);
  return o2 / (t2.length - 1);
}
function J(t2) {
  if (t2.length < 2)
    throw new Error("sampleVariance requires at least two data points");
  return a(t2, 2) / (t2.length - 1);
}
function L(t2) {
  var r2 = J(t2);
  return Math.sqrt(r2);
}
function O(t2, r2) {
  return H(t2, r2) / L(t2) / L(r2);
}
function Q(t2) {
  if (t2.length < 3)
    throw new Error("sampleSkewness requires at least three data points");
  for (var r2, n2 = e(t2), a3 = 0, o2 = 0, i2 = 0; i2 < t2.length; i2++)
    a3 += (r2 = t2[i2] - n2) * r2, o2 += r2 * r2 * r2;
  var h2 = Math.sqrt(a3 / (t2.length - 1)), u2 = t2.length;
  return u2 * o2 / ((u2 - 1) * (u2 - 2) * Math.pow(h2, 3));
}
function R(t2) {
  var r2 = t2.length;
  if (r2 < 4)
    throw new Error("sampleKurtosis requires at least four data points");
  for (var n2, a3 = e(t2), o2 = 0, i2 = 0, h2 = 0; h2 < r2; h2++)
    o2 += (n2 = t2[h2] - a3) * n2, i2 += n2 * n2 * n2 * n2;
  return (r2 - 1) / ((r2 - 2) * (r2 - 3)) * (r2 * (r2 + 1) * i2 / (o2 * o2) - 3 * (r2 - 1));
}
function W(t2) {
  for (var r2 = new Array(t2.length), n2 = [t2.slice()], e3 = 0; e3 < t2.length; e3++)
    r2[e3] = 0;
  for (var a3 = 0; a3 < t2.length; )
    if (r2[a3] < a3) {
      var o2 = 0;
      a3 % 2 != 0 && (o2 = r2[a3]);
      var i2 = t2[o2];
      t2[o2] = t2[a3], t2[a3] = i2, n2.push(t2.slice()), r2[a3]++, a3 = 0;
    } else
      r2[a3] = 0, a3++;
  return n2;
}
function X(t2, r2) {
  var n2, e3, a3, o2, i2 = [];
  for (n2 = 0; n2 < t2.length; n2++)
    if (r2 === 1)
      i2.push([t2[n2]]);
    else
      for (a3 = X(t2.slice(n2 + 1, t2.length), r2 - 1), e3 = 0; e3 < a3.length; e3++)
        (o2 = a3[e3]).unshift(t2[n2]), i2.push(o2);
  return i2;
}
function Y(t2, r2) {
  for (var n2 = [], e3 = 0; e3 < t2.length; e3++)
    if (r2 === 1)
      n2.push([t2[e3]]);
    else
      for (var a3 = Y(t2.slice(e3, t2.length), r2 - 1), o2 = 0; o2 < a3.length; o2++)
        n2.push([t2[e3]].concat(a3[o2]));
  return n2;
}
function Z(t2, r2, n2) {
  return t2 + (n2 - t2) / (r2 + 1);
}
function $(t2, r2, n2, e3) {
  return (t2 * r2 + n2 * e3) / (r2 + e3);
}
function tt(t2, r2, n2, e3, a3, o2) {
  var i2 = $(r2, n2, a3, o2);
  return (n2 * (t2 + Math.pow(r2 - i2, 2)) + o2 * (e3 + Math.pow(a3 - i2, 2))) / (n2 + o2);
}
function rt(t2) {
  if (t2.length === 0)
    throw new Error("geometricMean requires at least one data point");
  for (var r2 = 1, n2 = 0; n2 < t2.length; n2++) {
    if (t2[n2] <= 0)
      throw new Error("geometricMean requires only positive numbers as input");
    r2 *= t2[n2];
  }
  return Math.pow(r2, 1 / t2.length);
}
function nt(t2) {
  if (t2.length === 0)
    throw new Error("harmonicMean requires at least one data point");
  for (var r2 = 0, n2 = 0; n2 < t2.length; n2++) {
    if (t2[n2] <= 0)
      throw new Error("harmonicMean requires only positive numbers as input");
    r2 += 1 / t2[n2];
  }
  return t2.length / r2;
}
function et(t2) {
  return b(t2, 0.5);
}
function at(t2, r2, n2) {
  return (t2 * r2 - n2) / (r2 - 1);
}
function ot(t2) {
  if (t2.length === 0)
    throw new Error("rootMeanSquare requires at least one data point");
  for (var r2 = 0, n2 = 0; n2 < t2.length; n2++)
    r2 += Math.pow(t2[n2], 2);
  return Math.sqrt(r2 / t2.length);
}
function it(t2, r2) {
  return (e(t2) - r2) / (i(t2) / Math.sqrt(t2.length));
}
function ht(t2, r2, n2) {
  var a3 = t2.length, o2 = r2.length;
  if (!a3 || !o2)
    return null;
  n2 || (n2 = 0);
  var i2 = e(t2), h2 = e(r2), u2 = J(t2), f2 = J(r2);
  return typeof i2 == "number" && typeof h2 == "number" && typeof u2 == "number" && typeof f2 == "number" ? (i2 - h2 - n2) / Math.sqrt(((a3 - 1) * u2 + (o2 - 1) * f2) / (a3 + o2 - 2) * (1 / a3 + 1 / o2)) : void 0;
}
function ut() {
  this.totalCount = 0, this.data = {};
}
function ft() {
  this.weights = [], this.bias = 0;
}
function st(t2) {
  if (t2 < 0)
    throw new Error("factorial requires a non-negative value");
  if (Math.floor(t2) !== t2)
    throw new Error("factorial requires an integer input");
  for (var r2 = 1, n2 = 2; n2 <= t2; n2++)
    r2 *= n2;
  return r2;
}
function gt(t2) {
  if (typeof (r2 = t2) == "number" && isFinite(r2) && Math.floor(r2) === r2)
    return t2 <= 0 ? NaN : st(t2 - 1);
  var r2;
  if (--t2 < 0)
    return Math.PI / (Math.sin(Math.PI * -t2) * gt(-t2));
  var n2 = t2 + 0.25;
  return Math.pow(t2 / Math.E, t2) * Math.sqrt(2 * Math.PI * (t2 + 1 / 6)) * (1 + 1 / 144 / Math.pow(n2, 2) - 1 / 12960 / Math.pow(n2, 3) - 257 / 207360 / Math.pow(n2, 4) - 52 / 2612736 / Math.pow(n2, 5) + 5741173 / 9405849600 / Math.pow(n2, 6) + 37529 / 18811699200 / Math.pow(n2, 7));
}
function wt(t2) {
  if (t2 <= 0)
    return Infinity;
  t2--;
  for (var r2 = vt[0], n2 = 1; n2 < 15; n2++)
    r2 += vt[n2] / (t2 + n2);
  var e3 = ct + 0.5 + t2;
  return pt + Math.log(r2) - e3 + (t2 + 0.5) * Math.log(e3);
}
function Mt(t2) {
  if (t2 < 0 || t2 > 1)
    throw new Error("bernoulliDistribution requires probability to be between 0 and 1 inclusive");
  return [1 - t2, t2];
}
function dt(t2, r2) {
  if (!(r2 < 0 || r2 > 1 || t2 <= 0 || t2 % 1 != 0)) {
    var n2 = 0, e3 = 0, a3 = [], o2 = 1;
    do {
      a3[n2] = o2 * Math.pow(r2, n2) * Math.pow(1 - r2, t2 - n2), e3 += a3[n2], o2 = o2 * (t2 - ++n2 + 1) / n2;
    } while (e3 < 1 - lt);
    return a3;
  }
}
function mt(t2) {
  if (!(t2 <= 0)) {
    var r2 = 0, n2 = 0, e3 = [], a3 = 1;
    do {
      e3[r2] = Math.exp(-t2) * Math.pow(t2, r2) / a3, n2 += e3[r2], a3 *= ++r2;
    } while (n2 < 1 - lt);
    return e3;
  }
}
function qt(t2, r2, n2) {
  for (var a3 = 0, o2 = r2(e(t2)), i2 = [], h2 = [], u2 = 0; u2 < t2.length; u2++)
    i2[t2[u2]] === void 0 && (i2[t2[u2]] = 0), i2[t2[u2]]++;
  for (var f2 = 0; f2 < i2.length; f2++)
    i2[f2] === void 0 && (i2[f2] = 0);
  for (var l2 in o2)
    l2 in i2 && (h2[+l2] = o2[l2] * t2.length);
  for (var s3 = h2.length - 1; s3 >= 0; s3--)
    h2[s3] < 3 && (h2[s3 - 1] += h2[s3], h2.pop(), i2[s3 - 1] += i2[s3], i2.pop());
  for (var g2 = 0; g2 < i2.length; g2++)
    a3 += Math.pow(i2[g2] - h2[g2], 2) / h2[g2];
  return bt[i2.length - 1 - 1][n2] < a3;
}
function It(t2, r2, n2) {
  var e3, a3;
  if (r2 === void 0)
    e3 = yt.gaussian;
  else if (typeof r2 == "string") {
    if (!yt[r2])
      throw new Error('Unknown kernel "' + r2 + '"');
    e3 = yt[r2];
  } else
    e3 = r2;
  if (n2 === void 0)
    a3 = xt.nrd(t2);
  else if (typeof n2 == "string") {
    if (!xt[n2])
      throw new Error('Unknown bandwidth method "' + n2 + '"');
    a3 = xt[n2](t2);
  } else
    a3 = n2;
  return function(r3) {
    var n3 = 0, o2 = 0;
    for (n3 = 0; n3 < t2.length; n3++)
      o2 += e3((r3 - t2[n3]) / a3);
    return o2 / a3 / t2.length;
  };
}
function Pt(t2, r2, n2) {
  return (t2 - r2) / n2;
}
function Ct(t2) {
  for (var r2 = t2, n2 = t2, e3 = 1; e3 < 15; e3++)
    r2 += n2 *= t2 * t2 / (2 * e3 + 1);
  return Math.round(1e4 * (0.5 + r2 / kt * Math.exp(-t2 * t2 / 2))) / 1e4;
}
function Nt(t2) {
  var r2 = Math.abs(t2), n2 = Math.min(Math.round(100 * r2), _t.length - 1);
  return t2 >= 0 ? _t[n2] : +(1 - _t[n2]).toFixed(4);
}
function zt(t2) {
  var r2 = 1 / (1 + 0.5 * Math.abs(t2)), n2 = r2 * Math.exp(-Math.pow(t2, 2) - 1.26551223 + 1.00002368 * r2 + 0.37409196 * Math.pow(r2, 2) + 0.09678418 * Math.pow(r2, 3) - 0.18628806 * Math.pow(r2, 4) + 0.27886807 * Math.pow(r2, 5) - 1.13520398 * Math.pow(r2, 6) + 1.48851587 * Math.pow(r2, 7) - 0.82215223 * Math.pow(r2, 8) + 0.17087277 * Math.pow(r2, 9));
  return t2 >= 0 ? 1 - n2 : n2 - 1;
}
function Ft(t2) {
  var r2 = 8 * (Math.PI - 3) / (3 * Math.PI * (4 - Math.PI)), n2 = Math.sqrt(Math.sqrt(Math.pow(2 / (Math.PI * r2) + Math.log(1 - t2 * t2) / 2, 2) - Math.log(1 - t2 * t2) / r2) - (2 / (Math.PI * r2) + Math.log(1 - t2 * t2) / 2));
  return t2 >= 0 ? n2 : -n2;
}
function St(t2) {
  return t2 === 0 ? t2 = lt : t2 >= 1 && (t2 = 1 - lt), Math.sqrt(2) * Ft(2 * t2 - 1);
}
function Tt(t2, r2, n2, a3) {
  if (a3 === void 0 && (a3 = 1e4), n2 === void 0 && (n2 = "two_side"), n2 !== "two_side" && n2 !== "greater" && n2 !== "less")
    throw new Error("`alternative` must be either 'two_side', 'greater', or 'less'");
  for (var o2 = e(t2) - e(r2), i2 = new Array(a3), h2 = t2.concat(r2), u2 = Math.floor(h2.length / 2), f2 = 0; f2 < a3; f2++) {
    S(h2);
    var l2 = h2.slice(0, u2), s3 = h2.slice(u2, h2.length), g2 = e(l2) - e(s3);
    i2[f2] = g2;
  }
  var v2 = 0;
  if (n2 === "two_side")
    for (var c2 = 0; c2 <= a3; c2++)
      Math.abs(i2[c2]) >= Math.abs(o2) && (v2 += 1);
  else if (n2 === "greater")
    for (var p2 = 0; p2 <= a3; p2++)
      i2[p2] >= o2 && (v2 += 1);
  else
    for (var w3 = 0; w3 <= a3; w3++)
      i2[w3] <= o2 && (v2 += 1);
  return v2 / a3;
}
function Ut(t2) {
  if (typeof t2 == "number")
    return t2 < 0 ? -1 : t2 === 0 ? 0 : 1;
  throw new TypeError("not a number");
}
function Dt(t2, r2, n2, e3, a3) {
  if (typeof t2 != "function")
    throw new TypeError("func must be a function");
  for (var o2 = 0; o2 < e3; o2++) {
    var i2 = (r2 + n2) / 2;
    if (t2(i2) === 0 || Math.abs((n2 - r2) / 2) < a3)
      return i2;
    Ut(t2(i2)) === Ut(t2(r2)) ? r2 = i2 : n2 = i2;
  }
  throw new Error("maximum number of iterations exceeded");
}
var lt, vt, ct, pt, bt, Et, yt, xt, kt, _t, At;
var init_simple_statistics = __esm({
  "node_modules/simple-statistics/dist/simple-statistics.mjs"() {
    ut.prototype.train = function(t2, r2) {
      for (var n2 in this.data[r2] || (this.data[r2] = {}), t2) {
        var e3 = t2[n2];
        this.data[r2][n2] === void 0 && (this.data[r2][n2] = {}), this.data[r2][n2][e3] === void 0 && (this.data[r2][n2][e3] = 0), this.data[r2][n2][e3]++;
      }
      this.totalCount++;
    }, ut.prototype.score = function(t2) {
      var r2, n2 = {};
      for (var e3 in t2) {
        var a3 = t2[e3];
        for (r2 in this.data)
          n2[r2] = {}, n2[r2][e3 + "_" + a3] = this.data[r2][e3] ? (this.data[r2][e3][a3] || 0) / this.totalCount : 0;
      }
      var o2 = {};
      for (r2 in n2)
        for (var i2 in o2[r2] = 0, n2[r2])
          o2[r2] += n2[r2][i2];
      return o2;
    }, ft.prototype.predict = function(t2) {
      if (t2.length !== this.weights.length)
        return null;
      for (var r2 = 0, n2 = 0; n2 < this.weights.length; n2++)
        r2 += this.weights[n2] * t2[n2];
      return (r2 += this.bias) > 0 ? 1 : 0;
    }, ft.prototype.train = function(t2, r2) {
      if (r2 !== 0 && r2 !== 1)
        return null;
      t2.length !== this.weights.length && (this.weights = t2, this.bias = 1);
      var n2 = this.predict(t2);
      if (n2 !== r2) {
        for (var e3 = r2 - n2, a3 = 0; a3 < this.weights.length; a3++)
          this.weights[a3] += e3 * t2[a3];
        this.bias += e3;
      }
      return this;
    };
    lt = 1e-4;
    vt = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
    ct = 607 / 128;
    pt = Math.log(Math.sqrt(2 * Math.PI));
    bt = { 1: { 0.995: 0, 0.99: 0, 0.975: 0, 0.95: 0, 0.9: 0.02, 0.5: 0.45, 0.1: 2.71, 0.05: 3.84, 0.025: 5.02, 0.01: 6.63, 5e-3: 7.88 }, 2: { 0.995: 0.01, 0.99: 0.02, 0.975: 0.05, 0.95: 0.1, 0.9: 0.21, 0.5: 1.39, 0.1: 4.61, 0.05: 5.99, 0.025: 7.38, 0.01: 9.21, 5e-3: 10.6 }, 3: { 0.995: 0.07, 0.99: 0.11, 0.975: 0.22, 0.95: 0.35, 0.9: 0.58, 0.5: 2.37, 0.1: 6.25, 0.05: 7.81, 0.025: 9.35, 0.01: 11.34, 5e-3: 12.84 }, 4: { 0.995: 0.21, 0.99: 0.3, 0.975: 0.48, 0.95: 0.71, 0.9: 1.06, 0.5: 3.36, 0.1: 7.78, 0.05: 9.49, 0.025: 11.14, 0.01: 13.28, 5e-3: 14.86 }, 5: { 0.995: 0.41, 0.99: 0.55, 0.975: 0.83, 0.95: 1.15, 0.9: 1.61, 0.5: 4.35, 0.1: 9.24, 0.05: 11.07, 0.025: 12.83, 0.01: 15.09, 5e-3: 16.75 }, 6: { 0.995: 0.68, 0.99: 0.87, 0.975: 1.24, 0.95: 1.64, 0.9: 2.2, 0.5: 5.35, 0.1: 10.65, 0.05: 12.59, 0.025: 14.45, 0.01: 16.81, 5e-3: 18.55 }, 7: { 0.995: 0.99, 0.99: 1.25, 0.975: 1.69, 0.95: 2.17, 0.9: 2.83, 0.5: 6.35, 0.1: 12.02, 0.05: 14.07, 0.025: 16.01, 0.01: 18.48, 5e-3: 20.28 }, 8: { 0.995: 1.34, 0.99: 1.65, 0.975: 2.18, 0.95: 2.73, 0.9: 3.49, 0.5: 7.34, 0.1: 13.36, 0.05: 15.51, 0.025: 17.53, 0.01: 20.09, 5e-3: 21.96 }, 9: { 0.995: 1.73, 0.99: 2.09, 0.975: 2.7, 0.95: 3.33, 0.9: 4.17, 0.5: 8.34, 0.1: 14.68, 0.05: 16.92, 0.025: 19.02, 0.01: 21.67, 5e-3: 23.59 }, 10: { 0.995: 2.16, 0.99: 2.56, 0.975: 3.25, 0.95: 3.94, 0.9: 4.87, 0.5: 9.34, 0.1: 15.99, 0.05: 18.31, 0.025: 20.48, 0.01: 23.21, 5e-3: 25.19 }, 11: { 0.995: 2.6, 0.99: 3.05, 0.975: 3.82, 0.95: 4.57, 0.9: 5.58, 0.5: 10.34, 0.1: 17.28, 0.05: 19.68, 0.025: 21.92, 0.01: 24.72, 5e-3: 26.76 }, 12: { 0.995: 3.07, 0.99: 3.57, 0.975: 4.4, 0.95: 5.23, 0.9: 6.3, 0.5: 11.34, 0.1: 18.55, 0.05: 21.03, 0.025: 23.34, 0.01: 26.22, 5e-3: 28.3 }, 13: { 0.995: 3.57, 0.99: 4.11, 0.975: 5.01, 0.95: 5.89, 0.9: 7.04, 0.5: 12.34, 0.1: 19.81, 0.05: 22.36, 0.025: 24.74, 0.01: 27.69, 5e-3: 29.82 }, 14: { 0.995: 4.07, 0.99: 4.66, 0.975: 5.63, 0.95: 6.57, 0.9: 7.79, 0.5: 13.34, 0.1: 21.06, 0.05: 23.68, 0.025: 26.12, 0.01: 29.14, 5e-3: 31.32 }, 15: { 0.995: 4.6, 0.99: 5.23, 0.975: 6.27, 0.95: 7.26, 0.9: 8.55, 0.5: 14.34, 0.1: 22.31, 0.05: 25, 0.025: 27.49, 0.01: 30.58, 5e-3: 32.8 }, 16: { 0.995: 5.14, 0.99: 5.81, 0.975: 6.91, 0.95: 7.96, 0.9: 9.31, 0.5: 15.34, 0.1: 23.54, 0.05: 26.3, 0.025: 28.85, 0.01: 32, 5e-3: 34.27 }, 17: { 0.995: 5.7, 0.99: 6.41, 0.975: 7.56, 0.95: 8.67, 0.9: 10.09, 0.5: 16.34, 0.1: 24.77, 0.05: 27.59, 0.025: 30.19, 0.01: 33.41, 5e-3: 35.72 }, 18: { 0.995: 6.26, 0.99: 7.01, 0.975: 8.23, 0.95: 9.39, 0.9: 10.87, 0.5: 17.34, 0.1: 25.99, 0.05: 28.87, 0.025: 31.53, 0.01: 34.81, 5e-3: 37.16 }, 19: { 0.995: 6.84, 0.99: 7.63, 0.975: 8.91, 0.95: 10.12, 0.9: 11.65, 0.5: 18.34, 0.1: 27.2, 0.05: 30.14, 0.025: 32.85, 0.01: 36.19, 5e-3: 38.58 }, 20: { 0.995: 7.43, 0.99: 8.26, 0.975: 9.59, 0.95: 10.85, 0.9: 12.44, 0.5: 19.34, 0.1: 28.41, 0.05: 31.41, 0.025: 34.17, 0.01: 37.57, 5e-3: 40 }, 21: { 0.995: 8.03, 0.99: 8.9, 0.975: 10.28, 0.95: 11.59, 0.9: 13.24, 0.5: 20.34, 0.1: 29.62, 0.05: 32.67, 0.025: 35.48, 0.01: 38.93, 5e-3: 41.4 }, 22: { 0.995: 8.64, 0.99: 9.54, 0.975: 10.98, 0.95: 12.34, 0.9: 14.04, 0.5: 21.34, 0.1: 30.81, 0.05: 33.92, 0.025: 36.78, 0.01: 40.29, 5e-3: 42.8 }, 23: { 0.995: 9.26, 0.99: 10.2, 0.975: 11.69, 0.95: 13.09, 0.9: 14.85, 0.5: 22.34, 0.1: 32.01, 0.05: 35.17, 0.025: 38.08, 0.01: 41.64, 5e-3: 44.18 }, 24: { 0.995: 9.89, 0.99: 10.86, 0.975: 12.4, 0.95: 13.85, 0.9: 15.66, 0.5: 23.34, 0.1: 33.2, 0.05: 36.42, 0.025: 39.36, 0.01: 42.98, 5e-3: 45.56 }, 25: { 0.995: 10.52, 0.99: 11.52, 0.975: 13.12, 0.95: 14.61, 0.9: 16.47, 0.5: 24.34, 0.1: 34.28, 0.05: 37.65, 0.025: 40.65, 0.01: 44.31, 5e-3: 46.93 }, 26: { 0.995: 11.16, 0.99: 12.2, 0.975: 13.84, 0.95: 15.38, 0.9: 17.29, 0.5: 25.34, 0.1: 35.56, 0.05: 38.89, 0.025: 41.92, 0.01: 45.64, 5e-3: 48.29 }, 27: { 0.995: 11.81, 0.99: 12.88, 0.975: 14.57, 0.95: 16.15, 0.9: 18.11, 0.5: 26.34, 0.1: 36.74, 0.05: 40.11, 0.025: 43.19, 0.01: 46.96, 5e-3: 49.65 }, 28: { 0.995: 12.46, 0.99: 13.57, 0.975: 15.31, 0.95: 16.93, 0.9: 18.94, 0.5: 27.34, 0.1: 37.92, 0.05: 41.34, 0.025: 44.46, 0.01: 48.28, 5e-3: 50.99 }, 29: { 0.995: 13.12, 0.99: 14.26, 0.975: 16.05, 0.95: 17.71, 0.9: 19.77, 0.5: 28.34, 0.1: 39.09, 0.05: 42.56, 0.025: 45.72, 0.01: 49.59, 5e-3: 52.34 }, 30: { 0.995: 13.79, 0.99: 14.95, 0.975: 16.79, 0.95: 18.49, 0.9: 20.6, 0.5: 29.34, 0.1: 40.26, 0.05: 43.77, 0.025: 46.98, 0.01: 50.89, 5e-3: 53.67 }, 40: { 0.995: 20.71, 0.99: 22.16, 0.975: 24.43, 0.95: 26.51, 0.9: 29.05, 0.5: 39.34, 0.1: 51.81, 0.05: 55.76, 0.025: 59.34, 0.01: 63.69, 5e-3: 66.77 }, 50: { 0.995: 27.99, 0.99: 29.71, 0.975: 32.36, 0.95: 34.76, 0.9: 37.69, 0.5: 49.33, 0.1: 63.17, 0.05: 67.5, 0.025: 71.42, 0.01: 76.15, 5e-3: 79.49 }, 60: { 0.995: 35.53, 0.99: 37.48, 0.975: 40.48, 0.95: 43.19, 0.9: 46.46, 0.5: 59.33, 0.1: 74.4, 0.05: 79.08, 0.025: 83.3, 0.01: 88.38, 5e-3: 91.95 }, 70: { 0.995: 43.28, 0.99: 45.44, 0.975: 48.76, 0.95: 51.74, 0.9: 55.33, 0.5: 69.33, 0.1: 85.53, 0.05: 90.53, 0.025: 95.02, 0.01: 100.42, 5e-3: 104.22 }, 80: { 0.995: 51.17, 0.99: 53.54, 0.975: 57.15, 0.95: 60.39, 0.9: 64.28, 0.5: 79.33, 0.1: 96.58, 0.05: 101.88, 0.025: 106.63, 0.01: 112.33, 5e-3: 116.32 }, 90: { 0.995: 59.2, 0.99: 61.75, 0.975: 65.65, 0.95: 69.13, 0.9: 73.29, 0.5: 89.33, 0.1: 107.57, 0.05: 113.14, 0.025: 118.14, 0.01: 124.12, 5e-3: 128.3 }, 100: { 0.995: 67.33, 0.99: 70.06, 0.975: 74.22, 0.95: 77.93, 0.9: 82.36, 0.5: 99.33, 0.1: 118.5, 0.05: 124.34, 0.025: 129.56, 0.01: 135.81, 5e-3: 140.17 } };
    Et = Math.sqrt(2 * Math.PI);
    yt = { gaussian: function(t2) {
      return Math.exp(-0.5 * t2 * t2) / Et;
    } };
    xt = { nrd: function(t2) {
      var r2 = L(t2), n2 = _(t2);
      return typeof n2 == "number" && (r2 = Math.min(r2, n2 / 1.34)), 1.06 * r2 * Math.pow(t2.length, -0.2);
    } };
    kt = Math.sqrt(2 * Math.PI);
    for (_t = [], At = 0; At <= 3.09; At += 0.01)
      _t.push(Ct(At));
  }
});

// node_modules/@antv/data-set/lib/util/p-by-fraction.js
var require_p_by_fraction = __commonJS({
  "node_modules/@antv/data-set/lib/util/p-by-fraction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = function(fraction) {
      var step = 1 / fraction;
      var pArr = [];
      for (var i2 = 0; i2 <= 1; i2 = i2 + step) {
        pArr.push(i2);
      }
      return pArr;
    };
  }
});

// node_modules/@antv/data-set/lib/constants.js
var require_constants = __commonJS({
  "node_modules/@antv/data-set/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      HIERARCHY: "hierarchy",
      GEO: "geo",
      HEX: "hex",
      GRAPH: "graph",
      TABLE: "table",
      GEO_GRATICULE: "geo-graticule",
      STATISTICS_METHODS: [
        "max",
        "mean",
        "median",
        "min",
        "mode",
        "product",
        "standardDeviation",
        "sum",
        "sumSimple",
        "variance"
      ]
    };
  }
});

// node_modules/@antv/data-set/lib/api/statistics.js
var require_statistics = __commonJS({
  "node_modules/@antv/data-set/lib/api/statistics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var simpleStatistics = tslib_1.__importStar((init_simple_statistics(), simple_statistics_exports));
    var util_1 = (init_esm(), esm_exports);
    var view_1 = require_view();
    var p_by_fraction_1 = tslib_1.__importDefault(require_p_by_fraction());
    var constants_1 = tslib_1.__importDefault(require_constants());
    var STATISTICS_METHODS = constants_1.default.STATISTICS_METHODS;
    function getColumnValues(view, column) {
      var values = view.getColumn(column);
      if (util_1.isArray(values) && util_1.isArray(values[0])) {
        values = util_1.flattenDeep(values);
      }
      return values;
    }
    STATISTICS_METHODS.forEach(function(method) {
      view_1.View.prototype[method] = function(column) {
        return simpleStatistics[method](getColumnValues(this, column));
      };
    });
    var quantile2 = simpleStatistics.quantile;
    util_1.assign(view_1.View.prototype, {
      average: view_1.View.prototype.mean,
      quantile: function(column, p2) {
        return quantile2(getColumnValues(this, column), p2);
      },
      quantiles: function(column, pArr) {
        var columnArr = getColumnValues(this, column);
        return pArr.map(function(p2) {
          return quantile2(columnArr, p2);
        });
      },
      quantilesByFraction: function(column, fraction) {
        return this.quantiles(column, p_by_fraction_1.default(fraction));
      },
      range: function(column) {
        return [this.min(column), this.max(column)];
      },
      extent: function(column) {
        return this.range(column);
      }
    });
  }
});

// node_modules/@antv/data-set/lib/data-set.js
var require_data_set = __commonJS({
  "node_modules/@antv/data-set/lib/data-set.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataSet = void 0;
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var wolfy87_eventemitter_1 = tslib_1.__importDefault(require_EventEmitter());
    var view_1 = require_view();
    var constants_1 = tslib_1.__importDefault(require_constants());
    var DataSet = function(_super) {
      tslib_1.__extends(DataSet2, _super);
      function DataSet2(initialProps) {
        if (initialProps === void 0) {
          initialProps = { state: {} };
        }
        var _this = _super.call(this) || this;
        _this.isDataSet = true;
        _this._onChangeTimer = null;
        _this.views = {};
        _this.state = {};
        _this.state = initialProps.state;
        return _this;
      }
      DataSet2.registerConnector = function(name, connector) {
        DataSet2.connectors[name] = connector;
      };
      DataSet2.getConnector = function(name) {
        return DataSet2.connectors[name] || DataSet2.connectors.default;
      };
      DataSet2.registerTransform = function(name, transform) {
        DataSet2.transforms[name] = transform;
      };
      DataSet2.getTransform = function(name) {
        return DataSet2.transforms[name] || DataSet2.transforms.default;
      };
      DataSet2.prototype._getUniqueViewName = function() {
        var name = util_1.uniqueId("view_");
        while (this.views[name]) {
          name = util_1.uniqueId("view_");
        }
        return name;
      };
      DataSet2.prototype.createView = function(name, options) {
        if (util_1.isNil(name)) {
          name = this._getUniqueViewName();
        }
        if (util_1.isObject(name)) {
          options = name;
          name = this._getUniqueViewName();
        }
        if (this.views[name]) {
          throw new Error("data view exists: " + name);
        }
        var view = new view_1.View(this, options);
        this.views[name] = view;
        return view;
      };
      DataSet2.prototype.getView = function(name) {
        return this.views[name];
      };
      DataSet2.prototype.setView = function(name, view) {
        this.views[name] = view;
      };
      DataSet2.prototype.setState = function(name, value2) {
        var _this = this;
        this.state[name] = value2;
        if (this._onChangeTimer) {
          window.clearTimeout(this._onChangeTimer);
          this._onChangeTimer = null;
        }
        this._onChangeTimer = window.setTimeout(function() {
          _this.emit("statechange", name, value2);
        }, 16);
      };
      DataSet2.CONSTANTS = constants_1.default;
      DataSet2.connectors = {};
      DataSet2.transforms = {};
      DataSet2.DataSet = DataSet2;
      DataSet2.DataView = view_1.View;
      DataSet2.View = view_1.View;
      DataSet2.version = "____DATASET_VERSION____";
      return DataSet2;
    }(wolfy87_eventemitter_1.default);
    exports.DataSet = DataSet;
    util_1.assign(DataSet, constants_1.default);
    util_1.assign(DataSet.prototype, {
      view: DataSet.prototype.createView
    });
    view_1.View.DataSet = DataSet;
  }
});

// node_modules/@antv/data-set/lib/connector/default.js
var require_default = __commonJS({
  "node_modules/@antv/data-set/lib/connector/default.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    data_set_1.DataSet.registerConnector("default", function(data, dataSet) {
      var view;
      if (util_1.isString(data)) {
        view = dataSet.getView(data);
      } else {
        view = data;
      }
      if (!view) {
        throw new TypeError("Invalid dataView");
      }
      return util_1.deepMix([], view.rows);
    });
  }
});

// node_modules/d3-dsv/src/dsv.js
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i2) {
    return JSON.stringify(name) + ": d[" + i2 + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f2) {
  var object3 = objectConverter(columns);
  return function(row, i2) {
    return f2(object3(row), i2, columns);
  };
}
function inferColumns(rows) {
  var columnSet = Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad(value2, width) {
  var s3 = value2 + "", length2 = s3.length;
  return length2 < width ? new Array(width - length2 + 1).join(0) + s3 : s3;
}
function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}
function formatDate(date) {
  var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse(text, f2) {
    var convert, columns, rows = parseRows(text, function(row, i2) {
      if (convert)
        return convert(row, i2 - 1);
      columns = row, convert = f2 ? customConverter(row, f2) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text, f2) {
    var rows = [], N2 = text.length, I2 = 0, n2 = 0, t2, eof = N2 <= 0, eol = false;
    if (text.charCodeAt(N2 - 1) === NEWLINE)
      --N2;
    if (text.charCodeAt(N2 - 1) === RETURN)
      --N2;
    function token() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i2, j2 = I2, c2;
      if (text.charCodeAt(j2) === QUOTE) {
        while (I2++ < N2 && text.charCodeAt(I2) !== QUOTE || text.charCodeAt(++I2) === QUOTE)
          ;
        if ((i2 = I2) >= N2)
          eof = true;
        else if ((c2 = text.charCodeAt(I2++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text.charCodeAt(I2) === NEWLINE)
            ++I2;
        }
        return text.slice(j2 + 1, i2 - 1).replace(/""/g, '"');
      }
      while (I2 < N2) {
        if ((c2 = text.charCodeAt(i2 = I2++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text.charCodeAt(I2) === NEWLINE)
            ++I2;
        } else if (c2 !== DELIMITER)
          continue;
        return text.slice(j2, i2);
      }
      return eof = true, text.slice(j2, N2);
    }
    while ((t2 = token()) !== EOF) {
      var row = [];
      while (t2 !== EOL && t2 !== EOF)
        row.push(t2), t2 = token();
      if (f2 && (row = f2(row, n2++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }
  function format(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value2) {
    return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
  }
  return {
    parse,
    parseRows,
    format,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}
var EOL, EOF, QUOTE, NEWLINE, RETURN;
var init_dsv = __esm({
  "node_modules/d3-dsv/src/dsv.js"() {
    EOL = {};
    EOF = {};
    QUOTE = 34;
    NEWLINE = 10;
    RETURN = 13;
  }
});

// node_modules/d3-dsv/src/csv.js
var csv, csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows, csvFormatRow, csvFormatValue;
var init_csv = __esm({
  "node_modules/d3-dsv/src/csv.js"() {
    init_dsv();
    csv = dsv_default(",");
    csvParse = csv.parse;
    csvParseRows = csv.parseRows;
    csvFormat = csv.format;
    csvFormatBody = csv.formatBody;
    csvFormatRows = csv.formatRows;
    csvFormatRow = csv.formatRow;
    csvFormatValue = csv.formatValue;
  }
});

// node_modules/d3-dsv/src/tsv.js
var tsv, tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows, tsvFormatRow, tsvFormatValue;
var init_tsv = __esm({
  "node_modules/d3-dsv/src/tsv.js"() {
    init_dsv();
    tsv = dsv_default("	");
    tsvParse = tsv.parse;
    tsvParseRows = tsv.parseRows;
    tsvFormat = tsv.format;
    tsvFormatBody = tsv.formatBody;
    tsvFormatRows = tsv.formatRows;
    tsvFormatRow = tsv.formatRow;
    tsvFormatValue = tsv.formatValue;
  }
});

// node_modules/d3-dsv/src/autoType.js
function autoType(object3) {
  for (var key in object3) {
    var value2 = object3[key].trim(), number, m2;
    if (!value2)
      value2 = null;
    else if (value2 === "true")
      value2 = true;
    else if (value2 === "false")
      value2 = false;
    else if (value2 === "NaN")
      value2 = NaN;
    else if (!isNaN(number = +value2))
      value2 = number;
    else if (m2 = value2.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m2[4] && !m2[7])
        value2 = value2.replace(/-/g, "/").replace(/T/, " ");
      value2 = new Date(value2);
    } else
      continue;
    object3[key] = value2;
  }
  return object3;
}
var fixtz;
var init_autoType = __esm({
  "node_modules/d3-dsv/src/autoType.js"() {
    fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
  }
});

// node_modules/d3-dsv/src/index.js
var src_exports = {};
__export(src_exports, {
  autoType: () => autoType,
  csvFormat: () => csvFormat,
  csvFormatBody: () => csvFormatBody,
  csvFormatRow: () => csvFormatRow,
  csvFormatRows: () => csvFormatRows,
  csvFormatValue: () => csvFormatValue,
  csvParse: () => csvParse,
  csvParseRows: () => csvParseRows,
  dsvFormat: () => dsv_default,
  tsvFormat: () => tsvFormat,
  tsvFormatBody: () => tsvFormatBody,
  tsvFormatRow: () => tsvFormatRow,
  tsvFormatRows: () => tsvFormatRows,
  tsvFormatValue: () => tsvFormatValue,
  tsvParse: () => tsvParse,
  tsvParseRows: () => tsvParseRows
});
var init_src7 = __esm({
  "node_modules/d3-dsv/src/index.js"() {
    init_dsv();
    init_csv();
    init_tsv();
    init_autoType();
  }
});

// node_modules/@antv/data-set/lib/connector/dsv.js
var require_dsv = __commonJS({
  "node_modules/@antv/data-set/lib/connector/dsv.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var d3_dsv_1 = (init_src7(), src_exports);
    var data_set_1 = require_data_set();
    data_set_1.DataSet.registerConnector("dsv", function(str, options) {
      if (options === void 0) {
        options = {};
      }
      var delimiter = options.delimiter || ",";
      if (!util_1.isString(delimiter)) {
        throw new TypeError("Invalid delimiter: must be a string!");
      }
      return d3_dsv_1.dsvFormat(delimiter).parse(str);
    });
    data_set_1.DataSet.registerConnector("csv", function(str) {
      return d3_dsv_1.csvParse(str);
    });
    data_set_1.DataSet.registerConnector("tsv", function(str) {
      return d3_dsv_1.tsvParse(str);
    });
  }
});

// node_modules/@antv/data-set/lib/connector/geo-graticule.js
var require_geo_graticule = __commonJS({
  "node_modules/@antv/data-set/lib/connector/geo-graticule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_geo_1 = (init_d3_geo(), d3_geo_exports);
    var data_set_1 = require_data_set();
    function connector(_options, dataView) {
      dataView.dataType = "geo-graticule";
      var data = d3_geo_1.geoGraticule().lines();
      data.map(function(row, index2) {
        row.index = "" + index2;
        return row;
      });
      dataView.rows = data;
      return data;
    }
    exports.default = connector;
    data_set_1.DataSet.registerConnector("geo-graticule", connector);
  }
});

// node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS({
  "node_modules/parse-svg-path/index.js"(exports, module) {
    module.exports = parse;
    var length2 = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse(path3) {
      var data = [];
      path3.replace(segment, function(_2, command, args) {
        var type = command.toLowerCase();
        args = parseValues(args);
        if (type == "m" && args.length > 2) {
          data.push([command].concat(args.splice(0, 2)));
          type = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length2[type]) {
            args.unshift(command);
            return data.push(args);
          }
          if (args.length < length2[type])
            throw new Error("malformed path data");
          data.push([command].concat(args.splice(0, length2[type])));
        }
      });
      return data;
    }
    var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers2 = args.match(number);
      return numbers2 ? numbers2.map(Number) : [];
    }
  }
});

// node_modules/abs-svg-path/index.js
var require_abs_svg_path = __commonJS({
  "node_modules/abs-svg-path/index.js"(exports, module) {
    module.exports = absolutize;
    function absolutize(path3) {
      var startX = 0;
      var startY = 0;
      var x4 = 0;
      var y4 = 0;
      return path3.map(function(seg) {
        seg = seg.slice();
        var type = seg[0];
        var command = type.toUpperCase();
        if (type != command) {
          seg[0] = command;
          switch (type) {
            case "a":
              seg[6] += x4;
              seg[7] += y4;
              break;
            case "v":
              seg[1] += y4;
              break;
            case "h":
              seg[1] += x4;
              break;
            default:
              for (var i2 = 1; i2 < seg.length; ) {
                seg[i2++] += x4;
                seg[i2++] += y4;
              }
          }
        }
        switch (command) {
          case "Z":
            x4 = startX;
            y4 = startY;
            break;
          case "H":
            x4 = seg[1];
            break;
          case "V":
            y4 = seg[1];
            break;
          case "M":
            x4 = startX = seg[1];
            y4 = startY = seg[2];
            break;
          default:
            x4 = seg[seg.length - 2];
            y4 = seg[seg.length - 1];
        }
        return seg;
      });
    }
  }
});

// node_modules/point-at-length/index.js
var require_point_at_length = __commonJS({
  "node_modules/point-at-length/index.js"(exports, module) {
    var parse = require_parse_svg_path();
    var isarray = require_isarray();
    var abs6 = require_abs_svg_path();
    module.exports = Points;
    function Points(path3) {
      if (!(this instanceof Points))
        return new Points(path3);
      this._path = isarray(path3) ? path3 : parse(path3);
      this._path = abs6(this._path);
      this._path = zvhToL(this._path);
      this._path = longhand(this._path);
    }
    Points.prototype.at = function(pos, opts) {
      return this._walk(pos, opts).pos;
    };
    Points.prototype.length = function() {
      return this._walk(null).length;
    };
    Points.prototype._walk = function(pos, opts) {
      var cur = [0, 0];
      var prev = [0, 0, 0];
      var p03 = [0, 0];
      var len = 0;
      for (var i2 = 0; i2 < this._path.length; i2++) {
        var p2 = this._path[i2];
        if (p2[0] === "M") {
          cur[0] = p2[1];
          cur[1] = p2[2];
          if (pos === 0) {
            return { length: len, pos: cur };
          }
        } else if (p2[0] === "C") {
          prev[0] = p03[0] = cur[0];
          prev[1] = p03[1] = cur[1];
          prev[2] = len;
          var n2 = 100;
          for (var j2 = 0; j2 <= n2; j2++) {
            var t2 = j2 / n2;
            var x4 = xof_C(p2, t2);
            var y4 = yof_C(p2, t2);
            len += dist(cur[0], cur[1], x4, y4);
            cur[0] = x4;
            cur[1] = y4;
            if (typeof pos === "number" && len >= pos) {
              var dv = (len - pos) / (len - prev[2]);
              var npos = [
                cur[0] * (1 - dv) + prev[0] * dv,
                cur[1] * (1 - dv) + prev[1] * dv
              ];
              return { length: len, pos: npos };
            }
            prev[0] = cur[0];
            prev[1] = cur[1];
            prev[2] = len;
          }
        } else if (p2[0] === "Q") {
          prev[0] = p03[0] = cur[0];
          prev[1] = p03[1] = cur[1];
          prev[2] = len;
          var n2 = 100;
          for (var j2 = 0; j2 <= n2; j2++) {
            var t2 = j2 / n2;
            var x4 = xof_Q(p2, t2);
            var y4 = yof_Q(p2, t2);
            len += dist(cur[0], cur[1], x4, y4);
            cur[0] = x4;
            cur[1] = y4;
            if (typeof pos === "number" && len >= pos) {
              var dv = (len - pos) / (len - prev[2]);
              var npos = [
                cur[0] * (1 - dv) + prev[0] * dv,
                cur[1] * (1 - dv) + prev[1] * dv
              ];
              return { length: len, pos: npos };
            }
            prev[0] = cur[0];
            prev[1] = cur[1];
            prev[2] = len;
          }
        } else if (p2[0] === "L") {
          prev[0] = cur[0];
          prev[1] = cur[1];
          prev[2] = len;
          len += dist(cur[0], cur[1], p2[1], p2[2]);
          cur[0] = p2[1];
          cur[1] = p2[2];
          if (typeof pos === "number" && len >= pos) {
            var dv = (len - pos) / (len - prev[2]);
            var npos = [
              cur[0] * (1 - dv) + prev[0] * dv,
              cur[1] * (1 - dv) + prev[1] * dv
            ];
            return { length: len, pos: npos };
          }
          prev[0] = cur[0];
          prev[1] = cur[1];
          prev[2] = len;
        }
      }
      return { length: len, pos: cur };
      function xof_C(p3, t3) {
        return Math.pow(1 - t3, 3) * p03[0] + 3 * Math.pow(1 - t3, 2) * t3 * p3[1] + 3 * (1 - t3) * Math.pow(t3, 2) * p3[3] + Math.pow(t3, 3) * p3[5];
      }
      function yof_C(p3, t3) {
        return Math.pow(1 - t3, 3) * p03[1] + 3 * Math.pow(1 - t3, 2) * t3 * p3[2] + 3 * (1 - t3) * Math.pow(t3, 2) * p3[4] + Math.pow(t3, 3) * p3[6];
      }
      function xof_Q(p3, t3) {
        return Math.pow(1 - t3, 2) * p03[0] + 2 * (1 - t3) * t3 * p3[1] + Math.pow(t3, 2) * p3[3];
      }
      function yof_Q(p3, t3) {
        return Math.pow(1 - t3, 2) * p03[1] + 2 * (1 - t3) * t3 * p3[2] + Math.pow(t3, 2) * p3[4];
      }
    };
    function dist(ax, ay, bx, by) {
      var x4 = ax - bx;
      var y4 = ay - by;
      return Math.sqrt(x4 * x4 + y4 * y4);
    }
    function longhand(path3) {
      var prev, x16 = 0, y16 = 0;
      var conversion = { S: { to: "C", x: 3 }, T: { to: "Q", x: 1 } };
      for (var i2 = 0, len = path3.length; i2 < len; i2++) {
        var cmd = path3[i2];
        var convert = conversion[cmd[0]];
        if (convert) {
          cmd[0] = convert.to;
          if (prev) {
            if (prev[0] === convert.to) {
              x16 = 2 * prev[convert.x + 2] - prev[convert.x];
              y16 = 2 * prev[convert.x + 3] - prev[convert.x + 1];
            } else {
              x16 = prev[prev.length - 2];
              y16 = prev[prev.length - 1];
            }
          }
          cmd.splice(1, 0, x16, y16);
        }
        prev = cmd;
      }
      return path3;
    }
    function zvhToL(path3) {
      var ret = [];
      var startPoint = ["L", 0, 0];
      var last_point;
      for (var i2 = 0, len = path3.length; i2 < len; i2++) {
        var pt2 = path3[i2];
        switch (pt2[0]) {
          case "M":
            startPoint = ["L", pt2[1], pt2[2]];
            ret.push(pt2);
            break;
          case "Z":
            ret.push(startPoint);
            break;
          case "H":
            last_point = ret[ret.length - 1] || ["L", 0, 0];
            ret.push(["L", pt2[1], last_point[last_point.length - 1]]);
            break;
          case "V":
            last_point = ret[ret.length - 1] || ["L", 0, 0];
            ret.push(["L", last_point[last_point.length - 2], pt2[1]]);
            break;
          default:
            ret.push(pt2);
        }
      }
      return ret;
    }
  }
});

// node_modules/@antv/data-set/lib/connector/geojson.js
var require_geojson = __commonJS({
  "node_modules/@antv/data-set/lib/connector/geojson.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var point_at_length_1 = tslib_1.__importDefault(require_point_at_length());
    var util_1 = (init_esm(), esm_exports);
    var d3_geo_1 = (init_d3_geo(), d3_geo_exports);
    var data_set_1 = require_data_set();
    var geoPathGenerator = d3_geo_1.geoPath();
    function GeoJSONConnector(data, _options, dataView) {
      dataView.dataType = data_set_1.DataSet.CONSTANTS.GEO;
      var features = util_1.deepMix([], data.features);
      features.forEach(function(feature2) {
        feature2.name = feature2.properties.name;
        feature2.longitude = [];
        feature2.latitude = [];
        var pathData = feature2.pathData = geoPathGenerator(feature2);
        var points2 = point_at_length_1.default(pathData);
        points2._path.forEach(function(point5) {
          feature2.longitude.push(point5[1]);
          feature2.latitude.push(point5[2]);
        });
        var centroid = geoPathGenerator.centroid(feature2);
        feature2.centroidX = centroid[0];
        feature2.centroidY = centroid[1];
      });
      return features;
    }
    data_set_1.DataSet.registerConnector("geo", GeoJSONConnector);
    data_set_1.DataSet.registerConnector("geojson", GeoJSONConnector);
    data_set_1.DataSet.registerConnector("GeoJSON", GeoJSONConnector);
    exports.default = GeoJSONConnector;
  }
});

// node_modules/@antv/data-set/lib/connector/graph.js
var require_graph = __commonJS({
  "node_modules/@antv/data-set/lib/connector/graph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var DEFAULT_OPTIONS = {
      nodes: function(d2) {
        return d2.nodes;
      },
      edges: function(d2) {
        return d2.edges;
      }
    };
    function connector(data, options, dataView) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      dataView.dataType = data_set_1.DataSet.CONSTANTS.GRAPH;
      var nodes = options.nodes, edges2 = options.edges;
      if (nodes && !util_1.isFunction(nodes)) {
        throw new TypeError("Invalid nodes: must be a function!");
      }
      if (edges2 && !util_1.isFunction(edges2)) {
        throw new TypeError("Invalid edges: must be a function!");
      }
      dataView.rows = dataView.graph = {
        nodes: nodes(data),
        edges: edges2(data)
      };
      util_1.assign(dataView, dataView.graph);
      return dataView.rows;
    }
    data_set_1.DataSet.registerConnector("graph", connector);
    data_set_1.DataSet.registerConnector("diagram", connector);
  }
});

// node_modules/d3-hexjson/src/render.js
function renderHexJSON(hexjson, width, height) {
  var layout = hexjson.layout;
  var hexes = [];
  var hexRadius = 0;
  Object.keys(hexjson.hexes).forEach(function(key) {
    hexjson.hexes[key].key = key;
    hexes.push(hexjson.hexes[key]);
  });
  var qmax = max_default(hexes, function(d2) {
    return +d2.q;
  }), qmin = min_default(hexes, function(d2) {
    return +d2.q;
  }), rmax = max_default(hexes, function(d2) {
    return +d2.r;
  }), rmin = min_default(hexes, function(d2) {
    return +d2.r;
  });
  var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;
  if (layout === "odd-r" || layout === "even-r") {
    hexRadius = min_default([
      width / ((qnum + 0.5) * Math.sqrt(3)),
      height / ((rnum + 1 / 3) * 1.5)
    ]);
  } else {
    hexRadius = min_default([
      height / ((rnum + 0.5) * Math.sqrt(3)),
      width / ((qnum + 1 / 3) * 1.5)
    ]);
  }
  var hexWidth = hexRadius * Math.sqrt(3);
  var vertices = getVertices(layout, hexWidth, hexRadius);
  var points2 = getPoints(vertices);
  hexes.forEach(function(hex) {
    hex.qc = hex.q - qmin;
    hex.rc = rmax - hex.r;
    hex.x = getX(hex, layout, hexWidth, hexRadius);
    hex.y = getY(hex, layout, hexWidth, hexRadius);
    hex.vertices = vertices;
    hex.points = points2;
  });
  return hexes;
}
function getX(hex, layout, hexWidth, hexRadius) {
  var x4 = 0, xOffset = 0;
  switch (layout) {
    case "odd-r":
      xOffset = hex.rc % 2 === 1 ? hexWidth : hexWidth / 2;
      x4 = hex.qc * hexWidth + xOffset;
      break;
    case "even-r":
      xOffset = hex.rc % 2 === 0 ? hexWidth : hexWidth / 2;
      x4 = hex.qc * hexWidth + xOffset;
      break;
    case "odd-q":
    case "even-q":
      x4 = hex.qc * hexRadius * 1.5 + hexRadius;
      break;
  }
  return x4;
}
function getY(hex, layout, hexWidth, hexRadius) {
  var y4 = 0, yOffset = 0;
  switch (layout) {
    case "odd-r":
    case "even-r":
      y4 = hex.rc * hexRadius * 1.5 + hexRadius;
      break;
    case "odd-q":
      yOffset = hex.qc % 2 === 1 ? hexWidth : hexWidth / 2;
      y4 = hex.rc * hexWidth + yOffset;
      break;
    case "even-q":
      yOffset = hex.qc % 2 === 0 ? hexWidth : hexWidth / 2;
      y4 = hex.rc * hexWidth + yOffset;
      break;
  }
  return y4;
}
function getVertices(layout, hexWidth, hexRadius) {
  var vertices = [];
  switch (layout) {
    case "odd-r":
    case "even-r":
      vertices.push({ x: 0, y: 0 - hexRadius });
      vertices.push({ x: 0 + hexWidth * 0.5, y: 0 - 0.5 * hexRadius });
      vertices.push({ x: 0 + hexWidth * 0.5, y: 0 + 0.5 * hexRadius });
      vertices.push({ x: 0, y: 0 + hexRadius });
      vertices.push({ x: 0 - hexWidth * 0.5, y: 0 + 0.5 * hexRadius });
      vertices.push({ x: 0 - hexWidth * 0.5, y: 0 - 0.5 * hexRadius });
      break;
    case "odd-q":
    case "even-q":
      vertices.push({ x: 0 - hexRadius, y: 0 });
      vertices.push({ x: 0 - 0.5 * hexRadius, y: 0 - hexWidth * 0.5 });
      vertices.push({ x: 0 + 0.5 * hexRadius, y: 0 - hexWidth * 0.5 });
      vertices.push({ x: 0 + hexRadius, y: 0 });
      vertices.push({ x: 0 + 0.5 * hexRadius, y: 0 + hexWidth * 0.5 });
      vertices.push({ x: 0 - 0.5 * hexRadius, y: 0 + hexWidth * 0.5 });
      break;
  }
  return vertices;
}
function getPoints(vertices) {
  var points2 = "";
  vertices.forEach(function(v2) {
    points2 += v2.x + "," + v2.y + " ";
  });
  return points2.substring(0, points2.length - 1);
}
function getGridForHexJSON(hexjson) {
  var grid = {};
  grid.layout = hexjson.layout;
  grid.hexes = {};
  var hexes = [];
  Object.keys(hexjson.hexes).forEach(function(key) {
    hexes.push(hexjson.hexes[key]);
  });
  var qmax = max_default(hexes, function(d2) {
    return +d2.q;
  }), qmin = min_default(hexes, function(d2) {
    return +d2.q;
  }), rmax = max_default(hexes, function(d2) {
    return +d2.r;
  }), rmin = min_default(hexes, function(d2) {
    return +d2.r;
  });
  var i2, j2, fkey;
  for (i2 = qmin; i2 <= qmax; i2++) {
    for (j2 = rmin; j2 <= rmax; j2++) {
      fkey = "Q" + i2 + "R" + j2;
      grid.hexes[fkey] = { q: i2, r: j2 };
    }
  }
  return grid;
}
function getBoundaryDotsForHexJSON(hexjson, width, height, field) {
  var hexes = [];
  var layout = hexjson.layout;
  Object.keys(hexjson.hexes).forEach(function(key) {
    hexes.push(hexjson.hexes[key]);
  });
  var qmax = max_default(hexes, function(d2) {
    return +d2.q;
  }), qmin = min_default(hexes, function(d2) {
    return +d2.q;
  }), rmax = max_default(hexes, function(d2) {
    return +d2.r;
  }), rmin = min_default(hexes, function(d2) {
    return +d2.r;
  });
  var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;
  var hexRadius;
  if (layout === "odd-r" || layout === "even-r") {
    hexRadius = min_default([
      width / ((qnum + 0.5) * Math.sqrt(3)),
      height / ((rnum + 1 / 3) * 1.5)
    ]);
  } else {
    hexRadius = min_default([
      height / ((rnum + 0.5) * Math.sqrt(3)),
      width / ((qnum + 1 / 3) * 1.5)
    ]);
  }
  var hexWidth = hexRadius * Math.sqrt(3);
  var lines2 = [];
  var hexRadiusSquared = hexRadius * hexRadius * 4;
  var maxHex = hexes.length;
  if (maxHex > 1) {
    hexes.forEach(function(hex2) {
      hex2.qc = hex2.q - qmin;
      hex2.rc = rmax - hex2.r;
      hex2.x = getX(hex2, layout, hexWidth, hexRadius);
      hex2.y = getY(hex2, layout, hexWidth, hexRadius);
    });
    for (var i2 = 0; i2 < maxHex - 1; i2++) {
      for (var j2 = i2 + 1; j2 < maxHex; j2++) {
        var hex = hexes[i2];
        var otherHex = hexes[j2];
        if (hex[field] !== otherHex[field]) {
          if (Math.abs(hex.q - otherHex.q) <= 1 && Math.abs(hex.r - otherHex.r) <= 1) {
            if ((hex.x - otherHex.x) * (hex.x - otherHex.x) + (hex.y - otherHex.y) * (hex.y - otherHex.y) < hexRadiusSquared) {
              var midpoint = {};
              midpoint.x = otherHex.x + (hex.x - otherHex.x) / 2;
              midpoint.y = otherHex.y + (hex.y - otherHex.y) / 2;
              var perp = {};
              var denom = Math.sqrt(3) * 4;
              perp.dx = (hex.y - otherHex.y) / denom;
              perp.dy = -(hex.x - otherHex.x) / denom;
              lines2.push({ x: midpoint.x - 2 * perp.dx, y: midpoint.y - 2 * perp.dy });
              lines2.push({ x: midpoint.x - perp.dx, y: midpoint.y - perp.dy });
              lines2.push({ x: midpoint.x, y: midpoint.y });
              lines2.push({ x: midpoint.x + perp.dx, y: midpoint.y + perp.dy });
              lines2.push({ x: midpoint.x + 2 * perp.dx, y: midpoint.y + 2 * perp.dy });
            }
          }
        }
      }
    }
  }
  return lines2;
}
function getBoundarySegmentsForHexJSON(hexjson, width, height, field) {
  var hexes = [];
  var layout = hexjson.layout;
  Object.keys(hexjson.hexes).forEach(function(key) {
    hexes.push(hexjson.hexes[key]);
  });
  var qmax = max_default(hexes, function(d2) {
    return +d2.q;
  }), qmin = min_default(hexes, function(d2) {
    return +d2.q;
  }), rmax = max_default(hexes, function(d2) {
    return +d2.r;
  }), rmin = min_default(hexes, function(d2) {
    return +d2.r;
  });
  var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;
  var hexRadius;
  if (layout === "odd-r" || layout === "even-r") {
    hexRadius = min_default([
      width / ((qnum + 0.5) * Math.sqrt(3)),
      height / ((rnum + 1 / 3) * 1.5)
    ]);
  } else {
    hexRadius = min_default([
      height / ((rnum + 0.5) * Math.sqrt(3)),
      width / ((qnum + 1 / 3) * 1.5)
    ]);
  }
  var hexWidth = hexRadius * Math.sqrt(3);
  var segments = [];
  var hexRadiusSquared = hexRadius * hexRadius * 4;
  var maxHex = hexes.length;
  if (maxHex > 1) {
    hexes.forEach(function(hex2) {
      hex2.qc = hex2.q - qmin;
      hex2.rc = rmax - hex2.r;
      hex2.x = getX(hex2, layout, hexWidth, hexRadius);
      hex2.y = getY(hex2, layout, hexWidth, hexRadius);
    });
    for (var i2 = 0; i2 < maxHex - 1; i2++) {
      for (var j2 = i2 + 1; j2 < maxHex; j2++) {
        var hex = hexes[i2];
        var otherHex = hexes[j2];
        if (hex[field] !== otherHex[field]) {
          if (Math.abs(hex.q - otherHex.q) <= 1 && Math.abs(hex.r - otherHex.r) <= 1) {
            if ((hex.x - otherHex.x) * (hex.x - otherHex.x) + (hex.y - otherHex.y) * (hex.y - otherHex.y) < hexRadiusSquared) {
              var midpoint = {};
              midpoint.x = otherHex.x + (hex.x - otherHex.x) / 2;
              midpoint.y = otherHex.y + (hex.y - otherHex.y) / 2;
              var perp = {};
              var direction = 1;
              if (hex[field] < otherHex[field]) {
                direction = -1;
              }
              var denom = Math.sqrt(3) * 2 * direction;
              perp.dx = (hex.y - otherHex.y) / denom;
              perp.dy = -(hex.x - otherHex.x) / denom;
              segments.push({
                x1: midpoint.x - perp.dx,
                y1: midpoint.y - perp.dy,
                x2: midpoint.x + perp.dx,
                y2: midpoint.y + perp.dy
              });
            }
          }
        }
      }
    }
  }
  return segments;
}
var init_render = __esm({
  "node_modules/d3-hexjson/src/render.js"() {
    init_src();
  }
});

// node_modules/d3-hexjson/index.js
var d3_hexjson_exports = {};
__export(d3_hexjson_exports, {
  getBoundaryDotsForHexJSON: () => getBoundaryDotsForHexJSON,
  getBoundarySegmentsForHexJSON: () => getBoundarySegmentsForHexJSON,
  getGridForHexJSON: () => getGridForHexJSON,
  renderHexJSON: () => renderHexJSON
});
var init_d3_hexjson = __esm({
  "node_modules/d3-hexjson/index.js"() {
    init_render();
  }
});

// node_modules/@antv/data-set/lib/connector/hexjson.js
var require_hexjson = __commonJS({
  "node_modules/@antv/data-set/lib/connector/hexjson.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var d3_hexjson_1 = (init_d3_hexjson(), d3_hexjson_exports);
    var data_set_1 = require_data_set();
    var DEFAULT_OPTIONS = {
      width: 1,
      height: 1
    };
    function processRow(row) {
      row.cx = row.x;
      row.cy = row.y;
      row.x = [];
      row.y = [];
      row.vertices.forEach(function(v2) {
        row.x.push(v2.x + row.cx);
        row.y.push(v2.y + row.cy);
      });
      return row;
    }
    function HexJSONConnector(data, options, dataView) {
      dataView.dataType = data_set_1.DataSet.CONSTANTS.HEX;
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var width = options.width, height = options.height;
      var HexJSON = util_1.deepMix([], data);
      dataView._HexJSON = HexJSON;
      var grid = dataView._GridHexJSON = d3_hexjson_1.getGridForHexJSON(HexJSON);
      var rows = dataView.rows = d3_hexjson_1.renderHexJSON(HexJSON, width, height).map(processRow);
      dataView._gridRows = d3_hexjson_1.renderHexJSON(grid, width, height).map(processRow);
      return rows;
    }
    data_set_1.DataSet.registerConnector("hex", HexJSONConnector);
    data_set_1.DataSet.registerConnector("hexjson", HexJSONConnector);
    data_set_1.DataSet.registerConnector("hex-json", HexJSONConnector);
    data_set_1.DataSet.registerConnector("HexJSON", HexJSONConnector);
    exports.default = HexJSONConnector;
  }
});

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a3, b2) {
  return a3.parent === b2.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x4, c2) {
  return x4 + c2.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y4, c2) {
  return Math.max(y4, c2.y);
}
function leafLeft(node) {
  var children;
  while (children = node.children)
    node = children[0];
  return node;
}
function leafRight(node) {
  var children;
  while (children = node.children)
    node = children[children.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root) {
    var previousNode, x4 = 0;
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x4 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root), right2 = leafRight(root), x011 = left2.x - separation(left2, right2) / 2, x16 = right2.x + separation(right2, left2) / 2;
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x011) / (x16 - x011) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }
  cluster.separation = function(x4) {
    return arguments.length ? (separation = x4, cluster) : separation;
  };
  cluster.size = function(x4) {
    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x4) {
    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}
var init_cluster = __esm({
  "node_modules/d3-hierarchy/src/cluster.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count2(node) {
  var sum5 = 0, children = node.children, i2 = children && children.length;
  if (!i2)
    sum5 = 1;
  else
    while (--i2 >= 0)
      sum5 += children[i2].value;
  node.value = sum5;
}
function count_default() {
  return this.eachAfter(count2);
}
var init_count2 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/count.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback) {
  var node = this, current, next = [node], children, i2, n2;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children)
        for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
          next.push(children[i2]);
        }
    }
  } while (next.length);
  return this;
}
var init_each = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/each.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback) {
  var node = this, nodes = [node], children, i2;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children)
      for (i2 = children.length - 1; i2 >= 0; --i2) {
        nodes.push(children[i2]);
      }
  }
  return this;
}
var init_eachBefore = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/eachBefore.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback) {
  var node = this, nodes = [node], next = [], children, i2, n2;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children)
      for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        nodes.push(children[i2]);
      }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}
var init_eachAfter = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/eachAfter.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default2(value2) {
  return this.eachAfter(function(node) {
    var sum5 = +value2(node.data) || 0, children = node.children, i2 = children && children.length;
    while (--i2 >= 0)
      sum5 += children[i2].value;
    node.value = sum5;
  });
}
var init_sum3 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/sum.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}
var init_sort2 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/sort.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default5(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k4 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k4, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a3, b2) {
  if (a3 === b2)
    return a3;
  var aNodes = a3.ancestors(), bNodes = b2.ancestors(), c2 = null;
  a3 = aNodes.pop();
  b2 = bNodes.pop();
  while (a3 === b2) {
    c2 = a3;
    a3 = aNodes.pop();
    b2 = bNodes.pop();
  }
  return c2;
}
var init_path5 = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/path.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
var init_ancestors = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/ancestors.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}
var init_descendants = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/descendants.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
var init_leaves = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/leaves.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}
var init_links = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/links.js"() {
  }
});

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children) {
  var root = new Node(data), valued = +data.value && (root.value = data.value), node, nodes = [root], child, childs, i2, n2;
  if (children == null)
    children = defaultChildren;
  while (node = nodes.pop()) {
    if (valued)
      node.value = +node.data.value;
    if ((childs = children(node.data)) && (n2 = childs.length)) {
      node.children = new Array(n2);
      for (i2 = n2 - 1; i2 >= 0; --i2) {
        nodes.push(child = node.children[i2] = new Node(childs[i2]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function defaultChildren(d2) {
  return d2.children;
}
function copyData(node) {
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
var init_hierarchy = __esm({
  "node_modules/d3-hierarchy/src/hierarchy/index.js"() {
    init_count2();
    init_each();
    init_eachBefore();
    init_eachAfter();
    init_sum3();
    init_sort2();
    init_path5();
    init_ancestors();
    init_descendants();
    init_leaves();
    init_links();
    Node.prototype = hierarchy.prototype = {
      constructor: Node,
      count: count_default,
      each: each_default,
      eachAfter: eachAfter_default,
      eachBefore: eachBefore_default,
      sum: sum_default2,
      sort: sort_default,
      path: path_default5,
      ancestors: ancestors_default,
      descendants: descendants_default,
      leaves: leaves_default,
      links: links_default,
      copy: node_copy
    };
  }
});

// node_modules/d3-hierarchy/src/array.js
function shuffle(array3) {
  var m2 = array3.length, t2, i2;
  while (m2) {
    i2 = Math.random() * m2-- | 0;
    t2 = array3[m2];
    array3[m2] = array3[i2];
    array3[i2] = t2;
  }
  return array3;
}
var slice3;
var init_array3 = __esm({
  "node_modules/d3-hierarchy/src/array.js"() {
    slice3 = Array.prototype.slice;
  }
});

// node_modules/d3-hierarchy/src/pack/enclose.js
function enclose_default(circles2) {
  var i2 = 0, n2 = (circles2 = shuffle(slice3.call(circles2))).length, B3 = [], p2, e3;
  while (i2 < n2) {
    p2 = circles2[i2];
    if (e3 && enclosesWeak(e3, p2))
      ++i2;
    else
      e3 = encloseBasis(B3 = extendBasis(B3, p2)), i2 = 0;
  }
  return e3;
}
function extendBasis(B3, p2) {
  var i2, j2;
  if (enclosesWeakAll(p2, B3))
    return [p2];
  for (i2 = 0; i2 < B3.length; ++i2) {
    if (enclosesNot(p2, B3[i2]) && enclosesWeakAll(encloseBasis2(B3[i2], p2), B3)) {
      return [B3[i2], p2];
    }
  }
  for (i2 = 0; i2 < B3.length - 1; ++i2) {
    for (j2 = i2 + 1; j2 < B3.length; ++j2) {
      if (enclosesNot(encloseBasis2(B3[i2], B3[j2]), p2) && enclosesNot(encloseBasis2(B3[i2], p2), B3[j2]) && enclosesNot(encloseBasis2(B3[j2], p2), B3[i2]) && enclosesWeakAll(encloseBasis3(B3[i2], B3[j2], p2), B3)) {
        return [B3[i2], B3[j2], p2];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a3, b2) {
  var dr = a3.r - b2.r, dx = b2.x - a3.x, dy = b2.y - a3.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a3, b2) {
  var dr = a3.r - b2.r + 1e-6, dx = b2.x - a3.x, dy = b2.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a3, B3) {
  for (var i2 = 0; i2 < B3.length; ++i2) {
    if (!enclosesWeak(a3, B3[i2])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B3) {
  switch (B3.length) {
    case 1:
      return encloseBasis1(B3[0]);
    case 2:
      return encloseBasis2(B3[0], B3[1]);
    case 3:
      return encloseBasis3(B3[0], B3[1], B3[2]);
  }
}
function encloseBasis1(a3) {
  return {
    x: a3.x,
    y: a3.y,
    r: a3.r
  };
}
function encloseBasis2(a3, b2) {
  var x16 = a3.x, y16 = a3.y, r1 = a3.r, x22 = b2.x, y22 = b2.y, r2 = b2.r, x21 = x22 - x16, y21 = y22 - y16, r21 = r2 - r1, l2 = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x16 + x22 + x21 / l2 * r21) / 2,
    y: (y16 + y22 + y21 / l2 * r21) / 2,
    r: (l2 + r1 + r2) / 2
  };
}
function encloseBasis3(a3, b2, c2) {
  var x16 = a3.x, y16 = a3.y, r1 = a3.r, x22 = b2.x, y22 = b2.y, r2 = b2.r, x32 = c2.x, y32 = c2.y, r3 = c2.r, a22 = x16 - x22, a32 = x16 - x32, b22 = y16 - y22, b3 = y16 - y32, c22 = r2 - r1, c3 = r3 - r1, d1 = x16 * x16 + y16 * y16 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab = a32 * b22 - a22 * b3, xa = (b22 * d3 - b3 * d2) / (ab * 2) - x16, xb = (b3 * c22 - b22 * c3) / ab, ya = (a32 * d2 - a22 * d3) / (ab * 2) - y16, yb = (a22 * c3 - a32 * c22) / ab, A6 = xb * xb + yb * yb - 1, B3 = 2 * (r1 + xa * xb + ya * yb), C2 = xa * xa + ya * ya - r1 * r1, r4 = -(A6 ? (B3 + Math.sqrt(B3 * B3 - 4 * A6 * C2)) / (2 * A6) : C2 / B3);
  return {
    x: x16 + xa + xb * r4,
    y: y16 + ya + yb * r4,
    r: r4
  };
}
var init_enclose = __esm({
  "node_modules/d3-hierarchy/src/pack/enclose.js"() {
    init_array3();
  }
});

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b2, a3, c2) {
  var dx = b2.x - a3.x, x4, a22, dy = b2.y - a3.y, y4, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a3.r + c2.r, a22 *= a22;
    b22 = b2.r + c2.r, b22 *= b22;
    if (a22 > b22) {
      x4 = (d2 + b22 - a22) / (2 * d2);
      y4 = Math.sqrt(Math.max(0, b22 / d2 - x4 * x4));
      c2.x = b2.x - x4 * dx - y4 * dy;
      c2.y = b2.y - x4 * dy + y4 * dx;
    } else {
      x4 = (d2 + a22 - b22) / (2 * d2);
      y4 = Math.sqrt(Math.max(0, a22 / d2 - x4 * x4));
      c2.x = a3.x + x4 * dx - y4 * dy;
      c2.y = a3.y + x4 * dy + y4 * dx;
    }
  } else {
    c2.x = a3.x + c2.r;
    c2.y = a3.y;
  }
}
function intersects(a3, b2) {
  var dr = a3.r + b2.r - 1e-6, dx = b2.x - a3.x, dy = b2.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a3 = node._, b2 = node.next._, ab = a3.r + b2.r, dx = (a3.x * b2.r + b2.x * a3.r) / ab, dy = (a3.y * b2.r + b2.y * a3.r) / ab;
  return dx * dx + dy * dy;
}
function Node2(circle4) {
  this._ = circle4;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles2) {
  if (!(n2 = circles2.length))
    return 0;
  var a3, b2, c2, n2, aa, ca, i2, j2, k4, sj, sk;
  a3 = circles2[0], a3.x = 0, a3.y = 0;
  if (!(n2 > 1))
    return a3.r;
  b2 = circles2[1], a3.x = -b2.r, b2.x = a3.r, b2.y = 0;
  if (!(n2 > 2))
    return a3.r + b2.r;
  place(b2, a3, c2 = circles2[2]);
  a3 = new Node2(a3), b2 = new Node2(b2), c2 = new Node2(c2);
  a3.next = c2.previous = b2;
  b2.next = a3.previous = c2;
  c2.next = b2.previous = a3;
  pack:
    for (i2 = 3; i2 < n2; ++i2) {
      place(a3._, b2._, c2 = circles2[i2]), c2 = new Node2(c2);
      j2 = b2.next, k4 = a3.previous, sj = b2._.r, sk = a3._.r;
      do {
        if (sj <= sk) {
          if (intersects(j2._, c2._)) {
            b2 = j2, a3.next = b2, b2.previous = a3, --i2;
            continue pack;
          }
          sj += j2._.r, j2 = j2.next;
        } else {
          if (intersects(k4._, c2._)) {
            a3 = k4, a3.next = b2, b2.previous = a3, --i2;
            continue pack;
          }
          sk += k4._.r, k4 = k4.previous;
        }
      } while (j2 !== k4.next);
      c2.previous = a3, c2.next = b2, a3.next = b2.previous = b2 = c2;
      aa = score(a3);
      while ((c2 = c2.next) !== b2) {
        if ((ca = score(c2)) < aa) {
          a3 = c2, aa = ca;
        }
      }
      b2 = a3.next;
    }
  a3 = [b2._], c2 = b2;
  while ((c2 = c2.next) !== b2)
    a3.push(c2._);
  c2 = enclose_default(a3);
  for (i2 = 0; i2 < n2; ++i2)
    a3 = circles2[i2], a3.x -= c2.x, a3.y -= c2.y;
  return c2.r;
}
function siblings_default(circles2) {
  packEnclose(circles2);
  return circles2;
}
var init_siblings = __esm({
  "node_modules/d3-hierarchy/src/pack/siblings.js"() {
    init_enclose();
  }
});

// node_modules/d3-hierarchy/src/accessors.js
function optional(f2) {
  return f2 == null ? null : required(f2);
}
function required(f2) {
  if (typeof f2 !== "function")
    throw new Error();
  return f2;
}
var init_accessors = __esm({
  "node_modules/d3-hierarchy/src/accessors.js"() {
  }
});

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default6(x4) {
  return function() {
    return x4;
  };
}
var init_constant6 = __esm({
  "node_modules/d3-hierarchy/src/constant.js"() {
  }
});

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d2) {
  return Math.sqrt(d2.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }
  pack.radius = function(x4) {
    return arguments.length ? (radius = optional(x4), pack) : radius;
  };
  pack.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], pack) : [dx, dy];
  };
  pack.padding = function(x4) {
    return arguments.length ? (padding = typeof x4 === "function" ? x4 : constant_default6(+x4), pack) : padding;
  };
  return pack;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildren(padding, k4) {
  return function(node) {
    if (children = node.children) {
      var children, i2, n2 = children.length, r2 = padding(node) * k4 || 0, e3;
      if (r2)
        for (i2 = 0; i2 < n2; ++i2)
          children[i2].r += r2;
      e3 = packEnclose(children);
      if (r2)
        for (i2 = 0; i2 < n2; ++i2)
          children[i2].r -= r2;
      node.r = e3 + r2;
    }
  };
}
function translateChild(k4) {
  return function(node) {
    var parent = node.parent;
    node.r *= k4;
    if (parent) {
      node.x = parent.x + k4 * node.x;
      node.y = parent.y + k4 * node.y;
    }
  };
}
var init_pack = __esm({
  "node_modules/d3-hierarchy/src/pack/index.js"() {
    init_siblings();
    init_accessors();
    init_constant6();
  }
});

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}
var init_round = __esm({
  "node_modules/d3-hierarchy/src/treemap/round.js"() {
  }
});

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x011, y011, x16, y16) {
  var nodes = parent.children, node, i2 = -1, n2 = nodes.length, k4 = parent.value && (x16 - x011) / parent.value;
  while (++i2 < n2) {
    node = nodes[i2], node.y0 = y011, node.y1 = y16;
    node.x0 = x011, node.x1 = x011 += node.value * k4;
  }
}
var init_dice = __esm({
  "node_modules/d3-hierarchy/src/treemap/dice.js"() {
  }
});

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round2 = false;
  function partition(root) {
    var n2 = root.height + 1;
    root.x0 = root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n2;
    root.eachBefore(positionNode(dy, n2));
    if (round2)
      root.eachBefore(round_default);
    return root;
  }
  function positionNode(dy2, n2) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n2, node.x1, dy2 * (node.depth + 2) / n2);
      }
      var x011 = node.x0, y011 = node.y0, x16 = node.x1 - padding, y16 = node.y1 - padding;
      if (x16 < x011)
        x011 = x16 = (x011 + x16) / 2;
      if (y16 < y011)
        y011 = y16 = (y011 + y16) / 2;
      node.x0 = x011;
      node.y0 = y011;
      node.x1 = x16;
      node.y1 = y16;
    };
  }
  partition.round = function(x4) {
    return arguments.length ? (round2 = !!x4, partition) : round2;
  };
  partition.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], partition) : [dx, dy];
  };
  partition.padding = function(x4) {
    return arguments.length ? (padding = +x4, partition) : padding;
  };
  return partition;
}
var init_partition = __esm({
  "node_modules/d3-hierarchy/src/partition.js"() {
    init_round();
    init_dice();
  }
});

// node_modules/d3-hierarchy/src/stratify.js
function defaultId(d2) {
  return d2.id;
}
function defaultParentId(d2) {
  return d2.parentId;
}
function stratify_default() {
  var id = defaultId, parentId = defaultParentId;
  function stratify(data) {
    var d2, i2, n2 = data.length, root, parent, node, nodes = new Array(n2), nodeId, nodeKey, nodeByKey = {};
    for (i2 = 0; i2 < n2; ++i2) {
      d2 = data[i2], node = nodes[i2] = new Node(d2);
      if ((nodeId = id(d2, i2, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], nodeId = parentId(data[i2], i2, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root)
          throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      }
    }
    if (!root)
      throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n2;
    }).eachBefore(computeHeight);
    root.parent = null;
    if (n2 > 0)
      throw new Error("cycle");
    return root;
  }
  stratify.id = function(x4) {
    return arguments.length ? (id = required(x4), stratify) : id;
  };
  stratify.parentId = function(x4) {
    return arguments.length ? (parentId = required(x4), stratify) : parentId;
  };
  return stratify;
}
var keyPrefix, preroot, ambiguous;
var init_stratify = __esm({
  "node_modules/d3-hierarchy/src/stratify.js"() {
    init_accessors();
    init_hierarchy();
    keyPrefix = "$";
    preroot = { depth: -1 };
    ambiguous = {};
  }
});

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a3, b2) {
  return a3.parent === b2.parent ? 1 : 2;
}
function nextLeft(v2) {
  var children = v2.children;
  return children ? children[0] : v2.t;
}
function nextRight(v2) {
  var children = v2.children;
  return children ? children[children.length - 1] : v2.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v2) {
  var shift = 0, change = 0, children = v2.children, i2 = children.length, w3;
  while (--i2 >= 0) {
    w3 = children[i2];
    w3.z += shift;
    w3.m += shift;
    shift += w3.s + (change += w3.c);
  }
}
function nextAncestor(vim, v2, ancestor) {
  return vim.a.parent === v2.parent ? vim.a : ancestor;
}
function TreeNode(node, i2) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i2;
}
function treeRoot(root) {
  var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i2, n2;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n2 = children.length);
      for (i2 = n2 - 1; i2 >= 0; --i2) {
        nodes.push(child = node.children[i2] = new TreeNode(children[i2], i2));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root) {
    var t2 = treeRoot(root);
    t2.eachAfter(firstWalk), t2.parent.m = -t2.z;
    t2.eachBefore(secondWalk);
    if (nodeSize)
      root.eachBefore(sizeNode);
    else {
      var left2 = root, right2 = root, bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s3 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s3 - left2.x, kx3 = dx / (right2.x + s3 + tx), ky2 = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx3;
        node.y = node.depth * ky2;
      });
    }
    return root;
  }
  function firstWalk(v2) {
    var children = v2.children, siblings = v2.parent.children, w3 = v2.i ? siblings[v2.i - 1] : null;
    if (children) {
      executeShifts(v2);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w3) {
        v2.z = w3.z + separation(v2._, w3._);
        v2.m = v2.z - midpoint;
      } else {
        v2.z = midpoint;
      }
    } else if (w3) {
      v2.z = w3.z + separation(v2._, w3._);
    }
    v2.parent.A = apportion(v2, w3, v2.parent.A || siblings[0]);
  }
  function secondWalk(v2) {
    v2._.x = v2.z + v2.parent.m;
    v2.m += v2.parent.m;
  }
  function apportion(v2, w3, ancestor) {
    if (w3) {
      var vip = v2, vop = v2, vim = w3, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v2;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v2;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x4) {
    return arguments.length ? (separation = x4, tree) : separation;
  };
  tree.size = function(x4) {
    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x4) {
    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}
var init_tree = __esm({
  "node_modules/d3-hierarchy/src/tree.js"() {
    init_hierarchy();
    TreeNode.prototype = Object.create(Node.prototype);
  }
});

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x011, y011, x16, y16) {
  var nodes = parent.children, node, i2 = -1, n2 = nodes.length, k4 = parent.value && (y16 - y011) / parent.value;
  while (++i2 < n2) {
    node = nodes[i2], node.x0 = x011, node.x1 = x16;
    node.y0 = y011, node.y1 = y011 += node.value * k4;
  }
}
var init_slice = __esm({
  "node_modules/d3-hierarchy/src/treemap/slice.js"() {
  }
});

// node_modules/d3-hierarchy/src/treemap/squarify.js
function squarifyRatio(ratio, parent, x011, y011, x16, y16) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n2 = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n2) {
    dx = x16 - x011, dy = y16 - y011;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n2);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n2; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x011, y011, x16, value2 ? y011 += dy * sumValue / value2 : y16);
    else
      slice_default(row, x011, y011, value2 ? x011 += dx * sumValue / value2 : x16, y16);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var phi, squarify_default;
var init_squarify = __esm({
  "node_modules/d3-hierarchy/src/treemap/squarify.js"() {
    init_dice();
    init_slice();
    phi = (1 + Math.sqrt(5)) / 2;
    squarify_default = function custom(ratio) {
      function squarify(parent, x011, y011, x16, y16) {
        squarifyRatio(ratio, parent, x011, y011, x16, y16);
      }
      squarify.ratio = function(x4) {
        return custom((x4 = +x4) > 1 ? x4 : 1);
      };
      return squarify;
    }(phi);
  }
});

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round2)
      root.eachBefore(round_default);
    return root;
  }
  function positionNode(node) {
    var p2 = paddingStack[node.depth], x011 = node.x0 + p2, y011 = node.y0 + p2, x16 = node.x1 - p2, y16 = node.y1 - p2;
    if (x16 < x011)
      x011 = x16 = (x011 + x16) / 2;
    if (y16 < y011)
      y011 = y16 = (y011 + y16) / 2;
    node.x0 = x011;
    node.y0 = y011;
    node.x1 = x16;
    node.y1 = y16;
    if (node.children) {
      p2 = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x011 += paddingLeft(node) - p2;
      y011 += paddingTop(node) - p2;
      x16 -= paddingRight(node) - p2;
      y16 -= paddingBottom(node) - p2;
      if (x16 < x011)
        x011 = x16 = (x011 + x16) / 2;
      if (y16 < y011)
        y011 = y16 = (y011 + y16) / 2;
      tile(node, x011, y011, x16, y16);
    }
  }
  treemap.round = function(x4) {
    return arguments.length ? (round2 = !!x4, treemap) : round2;
  };
  treemap.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x4) {
    return arguments.length ? (tile = required(x4), treemap) : tile;
  };
  treemap.padding = function(x4) {
    return arguments.length ? treemap.paddingInner(x4).paddingOuter(x4) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x4) {
    return arguments.length ? (paddingInner = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x4) {
    return arguments.length ? treemap.paddingTop(x4).paddingRight(x4).paddingBottom(x4).paddingLeft(x4) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x4) {
    return arguments.length ? (paddingTop = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x4) {
    return arguments.length ? (paddingRight = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x4) {
    return arguments.length ? (paddingBottom = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x4) {
    return arguments.length ? (paddingLeft = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingLeft;
  };
  return treemap;
}
var init_treemap = __esm({
  "node_modules/d3-hierarchy/src/treemap/index.js"() {
    init_round();
    init_squarify();
    init_accessors();
    init_constant6();
  }
});

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x011, y011, x16, y16) {
  var nodes = parent.children, i2, n2 = nodes.length, sum5, sums = new Array(n2 + 1);
  for (sums[0] = sum5 = i2 = 0; i2 < n2; ++i2) {
    sums[i2 + 1] = sum5 += nodes[i2].value;
  }
  partition(0, n2, parent.value, x011, y011, x16, y16);
  function partition(i3, j2, value2, x012, y012, x17, y17) {
    if (i3 >= j2 - 1) {
      var node = nodes[i3];
      node.x0 = x012, node.y0 = y012;
      node.x1 = x17, node.y1 = y17;
      return;
    }
    var valueOffset = sums[i3], valueTarget = value2 / 2 + valueOffset, k4 = i3 + 1, hi = j2 - 1;
    while (k4 < hi) {
      var mid = k4 + hi >>> 1;
      if (sums[mid] < valueTarget)
        k4 = mid + 1;
      else
        hi = mid;
    }
    if (valueTarget - sums[k4 - 1] < sums[k4] - valueTarget && i3 + 1 < k4)
      --k4;
    var valueLeft = sums[k4] - valueOffset, valueRight = value2 - valueLeft;
    if (x17 - x012 > y17 - y012) {
      var xk = (x012 * valueRight + x17 * valueLeft) / value2;
      partition(i3, k4, valueLeft, x012, y012, xk, y17);
      partition(k4, j2, valueRight, xk, y012, x17, y17);
    } else {
      var yk = (y012 * valueRight + y17 * valueLeft) / value2;
      partition(i3, k4, valueLeft, x012, y012, x17, yk);
      partition(k4, j2, valueRight, x012, yk, x17, y17);
    }
  }
}
var init_binary = __esm({
  "node_modules/d3-hierarchy/src/treemap/binary.js"() {
  }
});

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x011, y011, x16, y16) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x011, y011, x16, y16);
}
var init_sliceDice = __esm({
  "node_modules/d3-hierarchy/src/treemap/sliceDice.js"() {
    init_dice();
    init_slice();
  }
});

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default;
var init_resquarify = __esm({
  "node_modules/d3-hierarchy/src/treemap/resquarify.js"() {
    init_dice();
    init_slice();
    init_squarify();
    resquarify_default = function custom2(ratio) {
      function resquarify(parent, x011, y011, x16, y16) {
        if ((rows = parent._squarify) && rows.ratio === ratio) {
          var rows, row, nodes, i2, j2 = -1, n2, m2 = rows.length, value2 = parent.value;
          while (++j2 < m2) {
            row = rows[j2], nodes = row.children;
            for (i2 = row.value = 0, n2 = nodes.length; i2 < n2; ++i2)
              row.value += nodes[i2].value;
            if (row.dice)
              dice_default(row, x011, y011, x16, y011 += (y16 - y011) * row.value / value2);
            else
              slice_default(row, x011, y011, x011 += (x16 - x011) * row.value / value2, y16);
            value2 -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x011, y011, x16, y16);
          rows.ratio = ratio;
        }
      }
      resquarify.ratio = function(x4) {
        return custom2((x4 = +x4) > 1 ? x4 : 1);
      };
      return resquarify;
    }(phi);
  }
});

// node_modules/d3-hierarchy/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  cluster: () => cluster_default,
  hierarchy: () => hierarchy,
  pack: () => pack_default,
  packEnclose: () => enclose_default,
  packSiblings: () => siblings_default,
  partition: () => partition_default,
  stratify: () => stratify_default,
  tree: () => tree_default,
  treemap: () => treemap_default,
  treemapBinary: () => binary_default,
  treemapDice: () => dice_default,
  treemapResquarify: () => resquarify_default,
  treemapSlice: () => slice_default,
  treemapSliceDice: () => sliceDice_default,
  treemapSquarify: () => squarify_default
});
var init_src8 = __esm({
  "node_modules/d3-hierarchy/src/index.js"() {
    init_cluster();
    init_hierarchy();
    init_pack();
    init_siblings();
    init_enclose();
    init_partition();
    init_stratify();
    init_tree();
    init_treemap();
    init_binary();
    init_dice();
    init_slice();
    init_sliceDice();
    init_squarify();
    init_resquarify();
  }
});

// node_modules/@antv/data-set/lib/connector/hierarchy.js
var require_hierarchy2 = __commonJS({
  "node_modules/@antv/data-set/lib/connector/hierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var d3_hierarchy_1 = (init_src8(), src_exports2);
    var data_set_1 = require_data_set();
    function connector(data, options, dataView) {
      dataView.dataType = data_set_1.DataSet.CONSTANTS.HIERARCHY;
      var children = options && options.children ? options.children : null;
      if (children && !util_1.isFunction(children)) {
        throw new TypeError("Invalid children: must be a function!");
      }
      if (!options.pureData) {
        dataView.rows = dataView.root = d3_hierarchy_1.hierarchy(data, children);
      } else {
        dataView.rows = dataView.root = data;
      }
      return data;
    }
    data_set_1.DataSet.registerConnector("hierarchy", connector);
    data_set_1.DataSet.registerConnector("tree", connector);
  }
});

// node_modules/topojson-client/src/identity.js
function identity_default9(x4) {
  return x4;
}
var init_identity9 = __esm({
  "node_modules/topojson-client/src/identity.js"() {
  }
});

// node_modules/topojson-client/src/transform.js
function transform_default4(transform) {
  if (transform == null)
    return identity_default9;
  var x011, y011, kx3 = transform.scale[0], ky2 = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
  return function(input, i2) {
    if (!i2)
      x011 = y011 = 0;
    var j2 = 2, n2 = input.length, output = new Array(n2);
    output[0] = (x011 += input[0]) * kx3 + dx;
    output[1] = (y011 += input[1]) * ky2 + dy;
    while (j2 < n2)
      output[j2] = input[j2], ++j2;
    return output;
  };
}
var init_transform4 = __esm({
  "node_modules/topojson-client/src/transform.js"() {
    init_identity9();
  }
});

// node_modules/topojson-client/src/bbox.js
function bbox_default(topology) {
  var t2 = transform_default4(topology.transform), key, x011 = Infinity, y011 = x011, x16 = -x011, y16 = -x011;
  function bboxPoint(p2) {
    p2 = t2(p2);
    if (p2[0] < x011)
      x011 = p2[0];
    if (p2[0] > x16)
      x16 = p2[0];
    if (p2[1] < y011)
      y011 = p2[1];
    if (p2[1] > y16)
      y16 = p2[1];
  }
  function bboxGeometry(o2) {
    switch (o2.type) {
      case "GeometryCollection":
        o2.geometries.forEach(bboxGeometry);
        break;
      case "Point":
        bboxPoint(o2.coordinates);
        break;
      case "MultiPoint":
        o2.coordinates.forEach(bboxPoint);
        break;
    }
  }
  topology.arcs.forEach(function(arc) {
    var i2 = -1, n2 = arc.length, p2;
    while (++i2 < n2) {
      p2 = t2(arc[i2], i2);
      if (p2[0] < x011)
        x011 = p2[0];
      if (p2[0] > x16)
        x16 = p2[0];
      if (p2[1] < y011)
        y011 = p2[1];
      if (p2[1] > y16)
        y16 = p2[1];
    }
  });
  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }
  return [x011, y011, x16, y16];
}
var init_bbox = __esm({
  "node_modules/topojson-client/src/bbox.js"() {
    init_transform4();
  }
});

// node_modules/topojson-client/src/reverse.js
function reverse_default(array3, n2) {
  var t2, j2 = array3.length, i2 = j2 - n2;
  while (i2 < --j2)
    t2 = array3[i2], array3[i2++] = array3[j2], array3[j2] = t2;
}
var init_reverse2 = __esm({
  "node_modules/topojson-client/src/reverse.js"() {
  }
});

// node_modules/topojson-client/src/feature.js
function feature_default(topology, o2) {
  if (typeof o2 === "string")
    o2 = topology.objects[o2];
  return o2.type === "GeometryCollection" ? { type: "FeatureCollection", features: o2.geometries.map(function(o3) {
    return feature(topology, o3);
  }) } : feature(topology, o2);
}
function feature(topology, o2) {
  var id = o2.id, bbox = o2.bbox, properties = o2.properties == null ? {} : o2.properties, geometry = object2(topology, o2);
  return id == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id, properties, geometry } : { type: "Feature", id, bbox, properties, geometry };
}
function object2(topology, o2) {
  var transformPoint = transform_default4(topology.transform), arcs = topology.arcs;
  function arc(i2, points2) {
    if (points2.length)
      points2.pop();
    for (var a3 = arcs[i2 < 0 ? ~i2 : i2], k4 = 0, n2 = a3.length; k4 < n2; ++k4) {
      points2.push(transformPoint(a3[k4], k4));
    }
    if (i2 < 0)
      reverse_default(points2, n2);
  }
  function point5(p2) {
    return transformPoint(p2);
  }
  function line(arcs2) {
    var points2 = [];
    for (var i2 = 0, n2 = arcs2.length; i2 < n2; ++i2)
      arc(arcs2[i2], points2);
    if (points2.length < 2)
      points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line(arcs2);
    while (points2.length < 4)
      points2.push(points2[0]);
    return points2;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o3) {
    var type = o3.type, coordinates2;
    switch (type) {
      case "GeometryCollection":
        return { type, geometries: o3.geometries.map(geometry) };
      case "Point":
        coordinates2 = point5(o3.coordinates);
        break;
      case "MultiPoint":
        coordinates2 = o3.coordinates.map(point5);
        break;
      case "LineString":
        coordinates2 = line(o3.arcs);
        break;
      case "MultiLineString":
        coordinates2 = o3.arcs.map(line);
        break;
      case "Polygon":
        coordinates2 = polygon(o3.arcs);
        break;
      case "MultiPolygon":
        coordinates2 = o3.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return { type, coordinates: coordinates2 };
  }
  return geometry(o2);
}
var init_feature = __esm({
  "node_modules/topojson-client/src/feature.js"() {
    init_reverse2();
    init_transform4();
  }
});

// node_modules/topojson-client/src/stitch.js
function stitch_default2(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i2, j2) {
    var arc = topology.arcs[i2 < 0 ? ~i2 : i2], t2;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t2 = arcs[++emptyIndex], arcs[emptyIndex] = i2, arcs[j2] = t2;
    }
  });
  arcs.forEach(function(i2) {
    var e3 = ends(i2), start = e3[0], end = e3[1], f2, g2;
    if (f2 = fragmentByEnd[start]) {
      delete fragmentByEnd[f2.end];
      f2.push(i2);
      f2.end = end;
      if (g2 = fragmentByStart[end]) {
        delete fragmentByStart[g2.start];
        var fg = g2 === f2 ? f2 : f2.concat(g2);
        fragmentByStart[fg.start = f2.start] = fragmentByEnd[fg.end = g2.end] = fg;
      } else {
        fragmentByStart[f2.start] = fragmentByEnd[f2.end] = f2;
      }
    } else if (f2 = fragmentByStart[end]) {
      delete fragmentByStart[f2.start];
      f2.unshift(i2);
      f2.start = start;
      if (g2 = fragmentByEnd[start]) {
        delete fragmentByEnd[g2.end];
        var gf = g2 === f2 ? f2 : g2.concat(f2);
        fragmentByStart[gf.start = g2.start] = fragmentByEnd[gf.end = f2.end] = gf;
      } else {
        fragmentByStart[f2.start] = fragmentByEnd[f2.end] = f2;
      }
    } else {
      f2 = [i2];
      fragmentByStart[f2.start = start] = fragmentByEnd[f2.end = end] = f2;
    }
  });
  function ends(i2) {
    var arc = topology.arcs[i2 < 0 ? ~i2 : i2], p03 = arc[0], p1;
    if (topology.transform)
      p1 = [0, 0], arc.forEach(function(dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });
    else
      p1 = arc[arc.length - 1];
    return i2 < 0 ? [p1, p03] : [p03, p1];
  }
  function flush(fragmentByEnd2, fragmentByStart2) {
    for (var k4 in fragmentByEnd2) {
      var f2 = fragmentByEnd2[k4];
      delete fragmentByStart2[f2.start];
      delete f2.start;
      delete f2.end;
      f2.forEach(function(i2) {
        stitchedArcs[i2 < 0 ? ~i2 : i2] = 1;
      });
      fragments.push(f2);
    }
  }
  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i2) {
    if (!stitchedArcs[i2 < 0 ? ~i2 : i2])
      fragments.push([i2]);
  });
  return fragments;
}
var init_stitch2 = __esm({
  "node_modules/topojson-client/src/stitch.js"() {
  }
});

// node_modules/topojson-client/src/mesh.js
function mesh_default(topology) {
  return object2(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object3, filter2) {
  var arcs, i2, n2;
  if (arguments.length > 1)
    arcs = extractArcs(topology, object3, filter2);
  else
    for (i2 = 0, arcs = new Array(n2 = topology.arcs.length); i2 < n2; ++i2)
      arcs[i2] = i2;
  return { type: "MultiLineString", arcs: stitch_default2(topology, arcs) };
}
function extractArcs(topology, object3, filter2) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i2) {
    var j2 = i2 < 0 ? ~i2 : i2;
    (geomsByArc[j2] || (geomsByArc[j2] = [])).push({ i: i2, g: geom });
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o2) {
    switch (geom = o2, o2.type) {
      case "GeometryCollection":
        o2.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o2.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o2.arcs);
        break;
      case "MultiPolygon":
        extract3(o2.arcs);
        break;
    }
  }
  geometry(object3);
  geomsByArc.forEach(filter2 == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter2(geoms[0].g, geoms[geoms.length - 1].g))
      arcs.push(geoms[0].i);
  });
  return arcs;
}
var init_mesh = __esm({
  "node_modules/topojson-client/src/mesh.js"() {
    init_feature();
    init_stitch2();
  }
});

// node_modules/topojson-client/src/merge.js
function planarRingArea(ring) {
  var i2 = -1, n2 = ring.length, a3, b2 = ring[n2 - 1], area = 0;
  while (++i2 < n2)
    a3 = b2, b2 = ring[i2], area += a3[0] * b2[1] - a3[1] * b2[0];
  return Math.abs(area);
}
function merge_default2(topology) {
  return object2(topology, mergeArcs.apply(this, arguments));
}
function mergeArcs(topology, objects) {
  var polygonsByArc = {}, polygons = [], groups2 = [];
  objects.forEach(geometry);
  function geometry(o2) {
    switch (o2.type) {
      case "GeometryCollection":
        o2.geometries.forEach(geometry);
        break;
      case "Polygon":
        extract(o2.arcs);
        break;
      case "MultiPolygon":
        o2.arcs.forEach(extract);
        break;
    }
  }
  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }
  function area(ring) {
    return planarRingArea(object2(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
  }
  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group2 = [], neighbors = [polygon];
      polygon._ = 1;
      groups2.push(group2);
      while (polygon = neighbors.pop()) {
        group2.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon2) {
              if (!polygon2._) {
                polygon2._ = 1;
                neighbors.push(polygon2);
              }
            });
          });
        });
      }
    }
  });
  polygons.forEach(function(polygon) {
    delete polygon._;
  });
  return {
    type: "MultiPolygon",
    arcs: groups2.map(function(polygons2) {
      var arcs = [], n2;
      polygons2.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });
      arcs = stitch_default2(topology, arcs);
      if ((n2 = arcs.length) > 1) {
        for (var i2 = 1, k4 = area(arcs[0]), ki, t2; i2 < n2; ++i2) {
          if ((ki = area(arcs[i2])) > k4) {
            t2 = arcs[0], arcs[0] = arcs[i2], arcs[i2] = t2, k4 = ki;
          }
        }
      }
      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}
var init_merge3 = __esm({
  "node_modules/topojson-client/src/merge.js"() {
    init_feature();
    init_stitch2();
  }
});

// node_modules/topojson-client/src/bisect.js
function bisect_default3(a3, x4) {
  var lo = 0, hi = a3.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a3[mid] < x4)
      lo = mid + 1;
    else
      hi = mid;
  }
  return lo;
}
var init_bisect3 = __esm({
  "node_modules/topojson-client/src/bisect.js"() {
  }
});

// node_modules/topojson-client/src/neighbors.js
function neighbors_default(objects) {
  var indexesByArc = {}, neighbors = objects.map(function() {
    return [];
  });
  function line(arcs, i3) {
    arcs.forEach(function(a3) {
      if (a3 < 0)
        a3 = ~a3;
      var o2 = indexesByArc[a3];
      if (o2)
        o2.push(i3);
      else
        indexesByArc[a3] = [i3];
    });
  }
  function polygon(arcs, i3) {
    arcs.forEach(function(arc) {
      line(arc, i3);
    });
  }
  function geometry(o2, i3) {
    if (o2.type === "GeometryCollection")
      o2.geometries.forEach(function(o3) {
        geometry(o3, i3);
      });
    else if (o2.type in geometryType)
      geometryType[o2.type](o2.arcs, i3);
  }
  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i3) {
      arcs.forEach(function(arc) {
        polygon(arc, i3);
      });
    }
  };
  objects.forEach(geometry);
  for (var i2 in indexesByArc) {
    for (var indexes2 = indexesByArc[i2], m2 = indexes2.length, j2 = 0; j2 < m2; ++j2) {
      for (var k4 = j2 + 1; k4 < m2; ++k4) {
        var ij = indexes2[j2], ik = indexes2[k4], n2;
        if ((n2 = neighbors[ij])[i2 = bisect_default3(n2, ik)] !== ik)
          n2.splice(i2, 0, ik);
        if ((n2 = neighbors[ik])[i2 = bisect_default3(n2, ij)] !== ij)
          n2.splice(i2, 0, ij);
      }
    }
  }
  return neighbors;
}
var init_neighbors = __esm({
  "node_modules/topojson-client/src/neighbors.js"() {
    init_bisect3();
  }
});

// node_modules/topojson-client/src/untransform.js
function untransform_default(transform) {
  if (transform == null)
    return identity_default9;
  var x011, y011, kx3 = transform.scale[0], ky2 = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
  return function(input, i2) {
    if (!i2)
      x011 = y011 = 0;
    var j2 = 2, n2 = input.length, output = new Array(n2), x16 = Math.round((input[0] - dx) / kx3), y16 = Math.round((input[1] - dy) / ky2);
    output[0] = x16 - x011, x011 = x16;
    output[1] = y16 - y011, y011 = y16;
    while (j2 < n2)
      output[j2] = input[j2], ++j2;
    return output;
  };
}
var init_untransform = __esm({
  "node_modules/topojson-client/src/untransform.js"() {
    init_identity9();
  }
});

// node_modules/topojson-client/src/quantize.js
function quantize_default2(topology, transform) {
  if (topology.transform)
    throw new Error("already quantized");
  if (!transform || !transform.scale) {
    if (!((n2 = Math.floor(transform)) >= 2))
      throw new Error("n must be \u22652");
    box = topology.bbox || bbox_default(topology);
    var x011 = box[0], y011 = box[1], x16 = box[2], y16 = box[3], n2;
    transform = { scale: [x16 - x011 ? (x16 - x011) / (n2 - 1) : 1, y16 - y011 ? (y16 - y011) / (n2 - 1) : 1], translate: [x011, y011] };
  } else {
    box = topology.bbox;
  }
  var t2 = untransform_default(transform), box, key, inputs = topology.objects, outputs = {};
  function quantizePoint(point5) {
    return t2(point5);
  }
  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection":
        output = { type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry) };
        break;
      case "Point":
        output = { type: "Point", coordinates: quantizePoint(input.coordinates) };
        break;
      case "MultiPoint":
        output = { type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint) };
        break;
      default:
        return input;
    }
    if (input.id != null)
      output.id = input.id;
    if (input.bbox != null)
      output.bbox = input.bbox;
    if (input.properties != null)
      output.properties = input.properties;
    return output;
  }
  function quantizeArc(input) {
    var i2 = 0, j2 = 1, n3 = input.length, p2, output = new Array(n3);
    output[0] = t2(input[0], 0);
    while (++i2 < n3)
      if ((p2 = t2(input[i2], i2))[0] || p2[1])
        output[j2++] = p2;
    if (j2 === 1)
      output[j2++] = [0, 0];
    output.length = j2;
    return output;
  }
  for (key in inputs)
    outputs[key] = quantizeGeometry(inputs[key]);
  return {
    type: "Topology",
    bbox: box,
    transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}
var init_quantize2 = __esm({
  "node_modules/topojson-client/src/quantize.js"() {
    init_bbox();
    init_untransform();
  }
});

// node_modules/topojson-client/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  bbox: () => bbox_default,
  feature: () => feature_default,
  merge: () => merge_default2,
  mergeArcs: () => mergeArcs,
  mesh: () => mesh_default,
  meshArcs: () => meshArcs,
  neighbors: () => neighbors_default,
  quantize: () => quantize_default2,
  transform: () => transform_default4,
  untransform: () => untransform_default
});
var init_src9 = __esm({
  "node_modules/topojson-client/src/index.js"() {
    init_bbox();
    init_feature();
    init_mesh();
    init_merge3();
    init_neighbors();
    init_quantize2();
    init_transform4();
    init_untransform();
  }
});

// node_modules/@antv/data-set/lib/connector/topojson.js
var require_topojson = __commonJS({
  "node_modules/@antv/data-set/lib/connector/topojson.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var topojson_client_1 = (init_src9(), src_exports3);
    var geojson_1 = tslib_1.__importDefault(require_geojson());
    var data_set_1 = require_data_set();
    function TopoJSONConnector(data, options, dataView) {
      var object3 = options.object;
      if (!util_1.isString(object3)) {
        throw new TypeError("Invalid object: must be a string!");
      }
      var geoData = topojson_client_1.feature(data, data.objects[object3]);
      return geojson_1.default(geoData, void 0, dataView);
    }
    data_set_1.DataSet.registerConnector("topojson", TopoJSONConnector);
    data_set_1.DataSet.registerConnector("TopoJSON", TopoJSONConnector);
  }
});

// node_modules/@antv/data-set/lib/transform/default.js
var require_default2 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/default.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_set_1 = require_data_set();
    data_set_1.DataSet.registerTransform("default", function(dataView) {
      return dataView;
    });
  }
});

// node_modules/@antv/data-set/lib/transform/filter.js
var require_filter = __commonJS({
  "node_modules/@antv/data-set/lib/transform/filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_set_1 = require_data_set();
    function defaultCallback(row) {
      return !!row;
    }
    data_set_1.DataSet.registerTransform("filter", function(dataView, options) {
      dataView.rows = dataView.rows.filter(options.callback || defaultCallback);
    });
  }
});

// node_modules/@antv/data-set/lib/util/option-parser.js
var require_option_parser = __commonJS({
  "node_modules/@antv/data-set/lib/util/option-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFields = exports.getField = void 0;
    var util_1 = (init_esm(), esm_exports);
    var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
    var INVALID_FIELDS_ERR_MSG = "Invalid fields: it must be an array!";
    function getField(options, defaultField) {
      var field = options.field, fields = options.fields;
      if (util_1.isString(field)) {
        return field;
      }
      if (util_1.isArray(field)) {
        console.warn(INVALID_FIELD_ERR_MSG);
        return field[0];
      }
      console.warn(INVALID_FIELD_ERR_MSG + " will try to get fields instead.");
      if (util_1.isString(fields)) {
        return fields;
      }
      if (util_1.isArray(fields) && fields.length) {
        return fields[0];
      }
      if (defaultField) {
        return defaultField;
      }
      throw new TypeError(INVALID_FIELD_ERR_MSG);
    }
    exports.getField = getField;
    function getFields(options, defaultFields) {
      var field = options.field, fields = options.fields;
      if (util_1.isArray(fields)) {
        return fields;
      }
      if (util_1.isString(fields)) {
        console.warn(INVALID_FIELDS_ERR_MSG);
        return [fields];
      }
      console.warn(INVALID_FIELDS_ERR_MSG + " will try to get field instead.");
      if (util_1.isString(field)) {
        console.warn(INVALID_FIELDS_ERR_MSG);
        return [field];
      }
      if (util_1.isArray(field) && field.length) {
        console.warn(INVALID_FIELDS_ERR_MSG);
        return field;
      }
      if (defaultFields) {
        return defaultFields;
      }
      throw new TypeError(INVALID_FIELDS_ERR_MSG);
    }
    exports.getFields = getFields;
  }
});

// node_modules/@antv/data-set/lib/transform/fold.js
var require_fold = __commonJS({
  "node_modules/@antv/data-set/lib/transform/fold.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      fields: [],
      key: "key",
      retains: [],
      value: "value"
    };
    data_set_1.DataSet.registerTransform("fold", function(dataView, options) {
      var columns = dataView.getColumnNames();
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var fields = option_parser_1.getFields(options);
      if (fields.length === 0) {
        console.warn("warning: option fields is not specified, will fold all columns.");
        fields = columns;
      }
      var key = options.key;
      var value2 = options.value;
      var retains = options.retains;
      if (!retains || retains.length === 0) {
        retains = util_1.difference(columns, fields);
      }
      var resultRows = [];
      dataView.rows.forEach(function(row) {
        fields.forEach(function(field) {
          var resultRow = util_1.pick(row, retains);
          resultRow[key] = field;
          resultRow[value2] = row[field];
          resultRows.push(resultRow);
        });
      });
      dataView.rows = resultRows;
    });
  }
});

// node_modules/@antv/data-set/lib/transform/map.js
var require_map2 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_set_1 = require_data_set();
    function defaultCallback(row) {
      return row;
    }
    data_set_1.DataSet.registerTransform("map", function(dataView, options) {
      dataView.rows = dataView.rows.map(options.callback || defaultCallback);
    });
  }
});

// node_modules/@antv/data-set/lib/transform/partition.js
var require_partition3 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/partition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var partition_1 = tslib_1.__importDefault(require_partition());
    var data_set_1 = require_data_set();
    var DEFAULT_OPTIONS = {
      groupBy: [],
      orderBy: []
    };
    data_set_1.DataSet.registerTransform("partition", function(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      dataView.rows = partition_1.default(dataView.rows, options.groupBy, options.orderBy);
    });
    function group2(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      dataView.rows = util_1.values(partition_1.default(dataView.rows, options.groupBy, options.orderBy));
    }
    data_set_1.DataSet.registerTransform("group", group2);
    data_set_1.DataSet.registerTransform("groups", group2);
  }
});

// node_modules/@antv/data-set/lib/transform/percent.js
var require_percent = __commonJS({
  "node_modules/@antv/data-set/lib/transform/percent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var simple_statistics_1 = (init_simple_statistics(), simple_statistics_exports);
    var partition_1 = tslib_1.__importDefault(require_partition());
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      groupBy: [],
      as: "_percent"
    };
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var field = option_parser_1.getField(options);
      var dimension = options.dimension, groupBy = options.groupBy;
      var as = options.as;
      if (!util_1.isString(dimension)) {
        throw new TypeError("Invalid dimension: must be a string!");
      }
      if (util_1.isArray(as)) {
        console.warn("Invalid as: must be a string, will use the first element of the array specified.");
        as = as[0];
      }
      if (!util_1.isString(as)) {
        throw new TypeError("Invalid as: must be a string!");
      }
      var rows = dataView.rows;
      var result = [];
      var groups2 = partition_1.default(rows, groupBy);
      util_1.forIn(groups2, function(group2) {
        var totalSum = simple_statistics_1.sum(group2.map(function(row) {
          return row[field];
        }));
        var innerGroups = partition_1.default(group2, [dimension]);
        util_1.forIn(innerGroups, function(innerGroup) {
          var innerSum = simple_statistics_1.sum(innerGroup.map(function(row) {
            return row[field];
          }));
          var resultRow = innerGroup[0];
          var dimensionValue = resultRow[dimension];
          resultRow[field] = innerSum;
          resultRow[dimension] = dimensionValue;
          if (totalSum === 0) {
            resultRow[as] = 0;
          } else {
            resultRow[as] = innerSum / totalSum;
          }
          result.push(resultRow);
        });
      });
      dataView.rows = result;
    }
    data_set_1.DataSet.registerTransform("percent", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/pick.js
var require_pick = __commonJS({
  "node_modules/@antv/data-set/lib/transform/pick.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    data_set_1.DataSet.registerTransform("pick", function(dataView, options) {
      var columns = option_parser_1.getFields(options, dataView.getColumnNames());
      dataView.rows = dataView.rows.map(function(row) {
        return util_1.pick(row, columns);
      });
    });
  }
});

// node_modules/@antv/data-set/lib/transform/proportion.js
var require_proportion = __commonJS({
  "node_modules/@antv/data-set/lib/transform/proportion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var partition_1 = tslib_1.__importDefault(require_partition());
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      groupBy: [],
      as: "_proportion"
    };
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var field = option_parser_1.getField(options);
      var dimension = options.dimension;
      var groupBy = options.groupBy;
      var as = options.as;
      if (!util_1.isString(dimension)) {
        throw new TypeError("Invalid dimension: must be a string!");
      }
      if (util_1.isArray(as)) {
        console.warn("Invalid as: must be a string, will use the first element of the array specified.");
        as = as[0];
      }
      if (!util_1.isString(as)) {
        throw new TypeError("Invalid as: must be a string!");
      }
      var rows = dataView.rows;
      var result = [];
      var groups2 = partition_1.default(rows, groupBy);
      util_1.forIn(groups2, function(group2) {
        var totalCount = group2.length;
        var innerGroups = partition_1.default(group2, [dimension]);
        util_1.forIn(innerGroups, function(innerGroup) {
          var innerCount = innerGroup.length;
          var resultRow = innerGroup[0];
          var dimensionValue = resultRow[dimension];
          resultRow[field] = innerCount;
          resultRow[dimension] = dimensionValue;
          resultRow[as] = innerCount / totalCount;
          result.push(resultRow);
        });
      });
      dataView.rows = result;
    }
    data_set_1.DataSet.registerTransform("proportion", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/rename.js
var require_rename = __commonJS({
  "node_modules/@antv/data-set/lib/transform/rename.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    function transform(dataView, options) {
      var map5 = options.map || {};
      var cleanMap = {};
      if (util_1.isPlainObject(map5)) {
        util_1.forIn(map5, function(value2, key) {
          if (util_1.isString(value2) && util_1.isString(key)) {
            cleanMap[key] = value2;
          }
        });
      }
      dataView.rows.forEach(function(row) {
        util_1.forIn(cleanMap, function(newKey, key) {
          var temp3 = row[key];
          delete row[key];
          row[newKey] = temp3;
        });
      });
    }
    data_set_1.DataSet.registerTransform("rename", transform);
    data_set_1.DataSet.registerTransform("rename-fields", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/reverse.js
var require_reverse = __commonJS({
  "node_modules/@antv/data-set/lib/transform/reverse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_set_1 = require_data_set();
    data_set_1.DataSet.registerTransform("reverse", function(dataView) {
      dataView.rows.reverse();
    });
  }
});

// node_modules/@antv/data-set/lib/transform/sort.js
var require_sort = __commonJS({
  "node_modules/@antv/data-set/lib/transform/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_set_1 = require_data_set();
    data_set_1.DataSet.registerTransform("sort", function(dataView, options) {
      var columnName = dataView.getColumnName(0);
      dataView.rows.sort(options.callback || function(a3, b2) {
        return a3[columnName] - b2[columnName];
      });
    });
  }
});

// node_modules/@antv/data-set/lib/transform/sort-by.js
var require_sort_by = __commonJS({
  "node_modules/@antv/data-set/lib/transform/sort-by.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var VALID_ORDERS = ["ASC", "DESC"];
    function transform(dataView, options) {
      var fields = option_parser_1.getFields(options, [dataView.getColumnName(0)]);
      if (!util_1.isArray(fields)) {
        throw new TypeError("Invalid fields: must be an array with strings!");
      }
      dataView.rows = util_1.sortBy(dataView.rows, fields);
      var order = options.order;
      if (order && VALID_ORDERS.indexOf(order) === -1) {
        throw new TypeError("Invalid order: " + order + " must be one of " + VALID_ORDERS.join(", "));
      } else if (order === "DESC") {
        dataView.rows.reverse();
      }
    }
    data_set_1.DataSet.registerTransform("sort-by", transform);
    data_set_1.DataSet.registerTransform("sortBy", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/subset.js
var require_subset = __commonJS({
  "node_modules/@antv/data-set/lib/transform/subset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    data_set_1.DataSet.registerTransform("subset", function(dataView, options) {
      var startIndex = options.startRowIndex || 0;
      var endIndex = options.endRowIndex || dataView.rows.length - 1;
      var columns = option_parser_1.getFields(options, dataView.getColumnNames());
      dataView.rows = dataView.getSubset(startIndex, endIndex, columns);
    });
  }
});

// node_modules/@antv/data-set/lib/transform/fill-rows.js
var require_fill_rows = __commonJS({
  "node_modules/@antv/data-set/lib/transform/fill-rows.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var partition_1 = tslib_1.__importDefault(require_partition());
    var data_set_1 = require_data_set();
    var DEFAULT_OPTIONS = {
      fillBy: "group",
      groupBy: [],
      orderBy: []
    };
    function arrayDifference(arr1, arr2) {
      var shadow = arr1.map(function(item) {
        return item;
      });
      arr2.forEach(function(item) {
        var index2 = shadow.indexOf(item);
        if (index2 > -1) {
          shadow.splice(index2, 1);
        }
      });
      return shadow;
    }
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var rows = dataView.rows;
      var groupBy = options.groupBy;
      var orderBy = options.orderBy;
      var groups2 = partition_1.default(rows, groupBy, orderBy);
      var maxLength = 0;
      var referenceGroup = [];
      util_1.forIn(groups2, function(group2) {
        if (group2.length > maxLength) {
          maxLength = group2.length;
          referenceGroup = group2;
        }
      });
      var referenceOrderByKeys = [];
      var referenceRowByOrderByKey = {};
      referenceGroup.forEach(function(row) {
        var key = orderBy.map(function(col) {
          return row[col];
        }).join("-");
        referenceOrderByKeys.push(key);
        referenceRowByOrderByKey[key] = row;
      });
      if (options.fillBy === "order") {
        var first_1 = referenceGroup[0];
        var allOrderByKeys_1 = [];
        var rowByOrderByKey_1 = {};
        rows.forEach(function(row) {
          var key = orderBy.map(function(col) {
            return row[col];
          }).join("-");
          if (allOrderByKeys_1.indexOf(key) === -1) {
            allOrderByKeys_1.push(key);
            rowByOrderByKey_1[key] = row;
          }
        });
        var _missingOrderByKeys = arrayDifference(allOrderByKeys_1, referenceOrderByKeys);
        _missingOrderByKeys.forEach(function(key) {
          var row = {};
          groupBy.forEach(function(col) {
            row[col] = first_1[col];
          });
          orderBy.forEach(function(col) {
            row[col] = rowByOrderByKey_1[key][col];
          });
          rows.push(row);
          referenceGroup.push(row);
          referenceOrderByKeys.push(key);
          referenceRowByOrderByKey[key] = row;
        });
        maxLength = referenceGroup.length;
      }
      util_1.forIn(groups2, function(group2) {
        if (group2 !== referenceGroup && group2.length < maxLength) {
          var first_2 = group2[0];
          var orderByKeys_1 = [];
          group2.forEach(function(row) {
            orderByKeys_1.push(orderBy.map(function(col) {
              return row[col];
            }).join("-"));
          });
          var missingOrderByKeys = arrayDifference(referenceOrderByKeys, orderByKeys_1);
          missingOrderByKeys.some(function(key, i2) {
            if (i2 >= maxLength - group2.length) {
              return true;
            }
            var referenceRow = referenceRowByOrderByKey[key];
            var row = {};
            groupBy.forEach(function(col) {
              row[col] = first_2[col];
            });
            orderBy.forEach(function(col) {
              row[col] = referenceRow[col];
            });
            rows.push(row);
            return false;
          });
        }
      });
    }
    data_set_1.DataSet.registerTransform("fill-rows", transform);
    data_set_1.DataSet.registerTransform("fillRows", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/impute.js
var require_impute = __commonJS({
  "node_modules/@antv/data-set/lib/transform/impute.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var simpleStatistics = tslib_1.__importStar((init_simple_statistics(), simple_statistics_exports));
    var partition_1 = tslib_1.__importDefault(require_partition());
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      groupBy: []
    };
    function notUndefinedValues(values) {
      return values.filter(function(value2) {
        return !util_1.isUndefined(value2);
      });
    }
    var STATISTICS_METHODS = ["mean", "median", "max", "min"];
    var imputations = {};
    STATISTICS_METHODS.forEach(function(method) {
      imputations[method] = function(row, values) {
        return simpleStatistics[method](values);
      };
    });
    imputations.value = function(_row, _values, value2) {
      return value2;
    };
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var field = option_parser_1.getField(options);
      var method = options.method;
      if (!method) {
        throw new TypeError("Invalid method!");
      }
      if (method === "value" && !util_1.has(options, "value")) {
        throw new TypeError("Invalid value: it is nil.");
      }
      var column = notUndefinedValues(dataView.getColumn(field));
      var groups2 = partition_1.default(dataView.rows, options.groupBy);
      util_1.forIn(groups2, function(group2) {
        var fieldValues = notUndefinedValues(group2.map(function(row) {
          return row[field];
        }));
        if (fieldValues.length === 0) {
          fieldValues = column;
        }
        group2.forEach(function(row) {
          if (util_1.isUndefined(row[field])) {
            if (util_1.isFunction(method)) {
              row[field] = method(row, fieldValues, options.value, group2);
            } else if (util_1.isString(method)) {
              row[field] = imputations[method](row, fieldValues, options.value);
            } else {
              throw new TypeError("Invalid method: must be a function or one of " + STATISTICS_METHODS.join(", "));
            }
          }
        });
      });
    }
    data_set_1.DataSet.registerTransform("impute", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/@antv/data-set/lib/transform/aggregate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var simpleStatistics = tslib_1.__importStar((init_simple_statistics(), simple_statistics_exports));
    var partition_1 = tslib_1.__importDefault(require_partition());
    var data_set_1 = require_data_set();
    var registerTransform = data_set_1.DataSet.registerTransform;
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      as: [],
      fields: [],
      groupBy: [],
      operations: []
    };
    var DEFAULT_OPERATION = "count";
    var aggregates = {
      count: function(data) {
        return data.length;
      },
      distinct: function(data, field) {
        var values = util_1.uniq(data.map(function(row) {
          return row[field];
        }));
        return values.length;
      }
    };
    data_set_1.DataSet.CONSTANTS.STATISTICS_METHODS.forEach(function(method) {
      aggregates[method] = function(data, field) {
        var values = data.map(function(row) {
          return row[field];
        });
        if (util_1.isArray(values) && util_1.isArray(values[0])) {
          values = util_1.flattenDeep(values);
        }
        return simpleStatistics[method](values);
      };
    });
    aggregates.average = aggregates.mean;
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var fields = option_parser_1.getFields(options);
      if (!util_1.isArray(fields)) {
        throw new TypeError("Invalid fields: it must be an array with one or more strings!");
      }
      var outputNames = options.as || [];
      if (util_1.isString(outputNames)) {
        outputNames = [outputNames];
      }
      var operations = options.operations;
      if (util_1.isString(operations)) {
        operations = [operations];
      }
      var DEFAULT_OPERATIONS = [DEFAULT_OPERATION];
      if (!util_1.isArray(operations) || !operations.length) {
        console.warn('operations is not defined, will use [ "count" ] directly.');
        operations = DEFAULT_OPERATIONS;
        outputNames = operations;
      }
      if (!(operations.length === 1 && operations[0] === DEFAULT_OPERATION)) {
        if (operations.length !== fields.length) {
          throw new TypeError("Invalid operations: it's length must be the same as fields!");
        }
        if (outputNames.length !== fields.length) {
          throw new TypeError("Invalid as: it's length must be the same as fields!");
        }
      }
      var groups2 = partition_1.default(dataView.rows, options.groupBy);
      var results = [];
      util_1.forIn(groups2, function(group2) {
        var result = group2[0];
        operations.forEach(function(operation, i2) {
          var outputName = outputNames[i2];
          var field = fields[i2];
          result[outputName] = aggregates[operation](group2, field);
        });
        results.push(result);
      });
      dataView.rows = results;
    }
    registerTransform("aggregate", transform);
    registerTransform("summary", transform);
    exports.default = {
      VALID_AGGREGATES: util_1.keys(aggregates)
    };
  }
});

// node_modules/regression/dist/regression.js
var require_regression = __commonJS({
  "node_modules/regression/dist/regression.js"(exports, module) {
    (function(global, factory) {
      if (typeof define === "function" && define.amd) {
        define(["module"], factory);
      } else if (typeof exports !== "undefined") {
        factory(module);
      } else {
        var mod = {
          exports: {}
        };
        factory(mod);
        global.regression = mod.exports;
      }
    })(exports, function(module2) {
      "use strict";
      function _defineProperty(obj, key, value2) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value2,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value2;
        }
        return obj;
      }
      var _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
            arr2[i2] = arr[i2];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };
      function determinationCoefficient(data, results) {
        var predictions = [];
        var observations = [];
        data.forEach(function(d2, i2) {
          if (d2[1] !== null) {
            observations.push(d2);
            predictions.push(results[i2]);
          }
        });
        var sum5 = observations.reduce(function(a3, observation) {
          return a3 + observation[1];
        }, 0);
        var mean2 = sum5 / observations.length;
        var ssyy = observations.reduce(function(a3, observation) {
          var difference2 = observation[1] - mean2;
          return a3 + difference2 * difference2;
        }, 0);
        var sse = observations.reduce(function(accum, observation, index2) {
          var prediction = predictions[index2];
          var residual = observation[1] - prediction[1];
          return accum + residual * residual;
        }, 0);
        return 1 - sse / ssyy;
      }
      function gaussianElimination(input, order) {
        var matrix = input;
        var n2 = input.length - 1;
        var coefficients = [order];
        for (var i2 = 0; i2 < n2; i2++) {
          var maxrow = i2;
          for (var j2 = i2 + 1; j2 < n2; j2++) {
            if (Math.abs(matrix[i2][j2]) > Math.abs(matrix[i2][maxrow])) {
              maxrow = j2;
            }
          }
          for (var k4 = i2; k4 < n2 + 1; k4++) {
            var tmp = matrix[k4][i2];
            matrix[k4][i2] = matrix[k4][maxrow];
            matrix[k4][maxrow] = tmp;
          }
          for (var _j = i2 + 1; _j < n2; _j++) {
            for (var _k = n2; _k >= i2; _k--) {
              matrix[_k][_j] -= matrix[_k][i2] * matrix[i2][_j] / matrix[i2][i2];
            }
          }
        }
        for (var _j2 = n2 - 1; _j2 >= 0; _j2--) {
          var total = 0;
          for (var _k2 = _j2 + 1; _k2 < n2; _k2++) {
            total += matrix[_k2][_j2] * coefficients[_k2];
          }
          coefficients[_j2] = (matrix[n2][_j2] - total) / matrix[_j2][_j2];
        }
        return coefficients;
      }
      function round2(number, precision) {
        var factor = Math.pow(10, precision);
        return Math.round(number * factor) / factor;
      }
      var methods = {
        linear: function linear(data, options) {
          var sum5 = [0, 0, 0, 0, 0];
          var len = 0;
          for (var n2 = 0; n2 < data.length; n2++) {
            if (data[n2][1] !== null) {
              len++;
              sum5[0] += data[n2][0];
              sum5[1] += data[n2][1];
              sum5[2] += data[n2][0] * data[n2][0];
              sum5[3] += data[n2][0] * data[n2][1];
              sum5[4] += data[n2][1] * data[n2][1];
            }
          }
          var run = len * sum5[2] - sum5[0] * sum5[0];
          var rise = len * sum5[3] - sum5[0] * sum5[1];
          var gradient = run === 0 ? 0 : round2(rise / run, options.precision);
          var intercept = round2(sum5[1] / len - gradient * sum5[0] / len, options.precision);
          var predict = function predict2(x4) {
            return [round2(x4, options.precision), round2(gradient * x4 + intercept, options.precision)];
          };
          var points2 = data.map(function(point5) {
            return predict(point5[0]);
          });
          return {
            points: points2,
            predict,
            equation: [gradient, intercept],
            r2: round2(determinationCoefficient(data, points2), options.precision),
            string: intercept === 0 ? "y = " + gradient + "x" : "y = " + gradient + "x + " + intercept
          };
        },
        exponential: function exponential(data, options) {
          var sum5 = [0, 0, 0, 0, 0, 0];
          for (var n2 = 0; n2 < data.length; n2++) {
            if (data[n2][1] !== null) {
              sum5[0] += data[n2][0];
              sum5[1] += data[n2][1];
              sum5[2] += data[n2][0] * data[n2][0] * data[n2][1];
              sum5[3] += data[n2][1] * Math.log(data[n2][1]);
              sum5[4] += data[n2][0] * data[n2][1] * Math.log(data[n2][1]);
              sum5[5] += data[n2][0] * data[n2][1];
            }
          }
          var denominator = sum5[1] * sum5[2] - sum5[5] * sum5[5];
          var a3 = Math.exp((sum5[2] * sum5[3] - sum5[5] * sum5[4]) / denominator);
          var b2 = (sum5[1] * sum5[4] - sum5[5] * sum5[3]) / denominator;
          var coeffA = round2(a3, options.precision);
          var coeffB = round2(b2, options.precision);
          var predict = function predict2(x4) {
            return [round2(x4, options.precision), round2(coeffA * Math.exp(coeffB * x4), options.precision)];
          };
          var points2 = data.map(function(point5) {
            return predict(point5[0]);
          });
          return {
            points: points2,
            predict,
            equation: [coeffA, coeffB],
            string: "y = " + coeffA + "e^(" + coeffB + "x)",
            r2: round2(determinationCoefficient(data, points2), options.precision)
          };
        },
        logarithmic: function logarithmic(data, options) {
          var sum5 = [0, 0, 0, 0];
          var len = data.length;
          for (var n2 = 0; n2 < len; n2++) {
            if (data[n2][1] !== null) {
              sum5[0] += Math.log(data[n2][0]);
              sum5[1] += data[n2][1] * Math.log(data[n2][0]);
              sum5[2] += data[n2][1];
              sum5[3] += Math.pow(Math.log(data[n2][0]), 2);
            }
          }
          var a3 = (len * sum5[1] - sum5[2] * sum5[0]) / (len * sum5[3] - sum5[0] * sum5[0]);
          var coeffB = round2(a3, options.precision);
          var coeffA = round2((sum5[2] - coeffB * sum5[0]) / len, options.precision);
          var predict = function predict2(x4) {
            return [round2(x4, options.precision), round2(round2(coeffA + coeffB * Math.log(x4), options.precision), options.precision)];
          };
          var points2 = data.map(function(point5) {
            return predict(point5[0]);
          });
          return {
            points: points2,
            predict,
            equation: [coeffA, coeffB],
            string: "y = " + coeffA + " + " + coeffB + " ln(x)",
            r2: round2(determinationCoefficient(data, points2), options.precision)
          };
        },
        power: function power(data, options) {
          var sum5 = [0, 0, 0, 0, 0];
          var len = data.length;
          for (var n2 = 0; n2 < len; n2++) {
            if (data[n2][1] !== null) {
              sum5[0] += Math.log(data[n2][0]);
              sum5[1] += Math.log(data[n2][1]) * Math.log(data[n2][0]);
              sum5[2] += Math.log(data[n2][1]);
              sum5[3] += Math.pow(Math.log(data[n2][0]), 2);
            }
          }
          var b2 = (len * sum5[1] - sum5[0] * sum5[2]) / (len * sum5[3] - Math.pow(sum5[0], 2));
          var a3 = (sum5[2] - b2 * sum5[0]) / len;
          var coeffA = round2(Math.exp(a3), options.precision);
          var coeffB = round2(b2, options.precision);
          var predict = function predict2(x4) {
            return [round2(x4, options.precision), round2(round2(coeffA * Math.pow(x4, coeffB), options.precision), options.precision)];
          };
          var points2 = data.map(function(point5) {
            return predict(point5[0]);
          });
          return {
            points: points2,
            predict,
            equation: [coeffA, coeffB],
            string: "y = " + coeffA + "x^" + coeffB,
            r2: round2(determinationCoefficient(data, points2), options.precision)
          };
        },
        polynomial: function polynomial(data, options) {
          var lhs = [];
          var rhs = [];
          var a3 = 0;
          var b2 = 0;
          var len = data.length;
          var k4 = options.order + 1;
          for (var i2 = 0; i2 < k4; i2++) {
            for (var l2 = 0; l2 < len; l2++) {
              if (data[l2][1] !== null) {
                a3 += Math.pow(data[l2][0], i2) * data[l2][1];
              }
            }
            lhs.push(a3);
            a3 = 0;
            var c2 = [];
            for (var j2 = 0; j2 < k4; j2++) {
              for (var _l = 0; _l < len; _l++) {
                if (data[_l][1] !== null) {
                  b2 += Math.pow(data[_l][0], i2 + j2);
                }
              }
              c2.push(b2);
              b2 = 0;
            }
            rhs.push(c2);
          }
          rhs.push(lhs);
          var coefficients = gaussianElimination(rhs, k4).map(function(v2) {
            return round2(v2, options.precision);
          });
          var predict = function predict2(x4) {
            return [round2(x4, options.precision), round2(coefficients.reduce(function(sum5, coeff, power) {
              return sum5 + coeff * Math.pow(x4, power);
            }, 0), options.precision)];
          };
          var points2 = data.map(function(point5) {
            return predict(point5[0]);
          });
          var string = "y = ";
          for (var _i = coefficients.length - 1; _i >= 0; _i--) {
            if (_i > 1) {
              string += coefficients[_i] + "x^" + _i + " + ";
            } else if (_i === 1) {
              string += coefficients[_i] + "x + ";
            } else {
              string += coefficients[_i];
            }
          }
          return {
            string,
            points: points2,
            predict,
            equation: [].concat(_toConsumableArray(coefficients)).reverse(),
            r2: round2(determinationCoefficient(data, points2), options.precision)
          };
        }
      };
      function createWrapper() {
        var reduce2 = function reduce3(accumulator, name) {
          return _extends({
            _round: round2
          }, accumulator, _defineProperty({}, name, function(data, supplied) {
            return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));
          }));
        };
        return Object.keys(methods).reduce(reduce2, {});
      }
      module2.exports = createWrapper();
    });
  }
});

// node_modules/@antv/data-set/lib/util/get-series-values.js
var require_get_series_values = __commonJS({
  "node_modules/@antv/data-set/lib/util/get-series-values.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    exports.default = function(extent, bw) {
      var bandwidth = bw || 1;
      var _a = tslib_1.__read(extent, 2), min4 = _a[0], max4 = _a[1];
      var values = [];
      var tmp = min4;
      while (tmp < max4) {
        values.push(tmp);
        tmp += bandwidth;
      }
      values.push(max4);
      return values;
    };
  }
});

// node_modules/@antv/data-set/lib/util/bandwidth.js
var require_bandwidth = __commonJS({
  "node_modules/@antv/data-set/lib/util/bandwidth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nrd = exports.silverman = void 0;
    var simple_statistics_1 = (init_simple_statistics(), simple_statistics_exports);
    function silverman(arr) {
      var stdev = simple_statistics_1.standardDeviation(arr);
      var num = 4 * Math.pow(stdev, 5);
      var denom = 3 * arr.length;
      return Math.pow(num / denom, 0.2);
    }
    exports.silverman = silverman;
    function nrd(arr) {
      var s3 = simple_statistics_1.standardDeviation(arr);
      var iqr = simple_statistics_1.interquartileRange(arr);
      if (typeof iqr === "number") {
        s3 = Math.min(s3, iqr / 1.34);
      }
      return 1.06 * s3 * Math.pow(arr.length, -0.2);
    }
    exports.nrd = nrd;
  }
});

// node_modules/@antv/data-set/lib/transform/regression.js
var require_regression2 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/regression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var regression_1 = tslib_1.__importDefault(require_regression());
    var util_1 = (init_esm(), esm_exports);
    var get_series_values_1 = tslib_1.__importDefault(require_get_series_values());
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var bandwidth_1 = require_bandwidth();
    var DEFAULT_OPTIONS = {
      as: ["x", "y"],
      method: "linear",
      order: 2,
      precision: 2
    };
    var REGRESSION_METHODS = ["linear", "exponential", "logarithmic", "power", "polynomial"];
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var fields = option_parser_1.getFields(options);
      if (!util_1.isArray(fields) || fields.length !== 2) {
        throw new TypeError("invalid fields: must be an array of 2 strings.");
      }
      var _a = tslib_1.__read(fields, 2), xField = _a[0], yField = _a[1];
      var method = options.method;
      if (REGRESSION_METHODS.indexOf(method) === -1) {
        throw new TypeError("invalid method: " + method + ". Must be one of " + REGRESSION_METHODS.join(", "));
      }
      var points2 = dataView.rows.map(function(row) {
        return [row[xField], row[yField]];
      });
      var regressionResult = regression_1.default[method](points2, options);
      var extent = options.extent;
      if (!util_1.isArray(extent) || extent.length !== 2) {
        extent = dataView.range(xField);
      }
      var bandwidth = options.bandwidth;
      if (!util_1.isNumber(bandwidth) || bandwidth <= 0) {
        bandwidth = bandwidth_1.silverman(dataView.getColumn(xField));
      }
      var valuesToPredict = get_series_values_1.default(extent, bandwidth);
      var result = [];
      var _b = tslib_1.__read(options.as, 2), asX = _b[0], asY = _b[1];
      valuesToPredict.forEach(function(value2) {
        var row = {};
        var _a2 = tslib_1.__read(regressionResult.predict(value2), 2), x4 = _a2[0], y4 = _a2[1];
        row[asX] = x4;
        row[asY] = y4;
        if (isFinite(y4)) {
          result.push(row);
        }
      });
      dataView.rows = result;
    }
    data_set_1.DataSet.registerTransform("regression", transform);
    exports.default = {
      REGRESSION_METHODS
    };
  }
});

// node_modules/@antv/data-set/lib/util/kernel.js
var require_kernel = __commonJS({
  "node_modules/@antv/data-set/lib/util/kernel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function uniform(u2) {
      return Math.abs(u2) <= 1 ? 0.5 : 0;
    }
    function tricubed(u2) {
      var abs6 = 1 - Math.pow(Math.abs(u2), 3);
      return Math.pow(abs6, 3);
    }
    exports.default = {
      boxcar: uniform,
      cosine: function(u2) {
        if (Math.abs(u2) <= 1) {
          return Math.PI / 4 * Math.cos(Math.PI / 2 * u2);
        }
        return 0;
      },
      epanechnikov: function(u2) {
        return Math.abs(u2) < 1 ? 0.75 * (1 - u2 * u2) : 0;
      },
      gaussian: function(u2) {
        return 0.3989422804 * Math.exp(-0.5 * u2 * u2);
      },
      quartic: function(u2) {
        if (Math.abs(u2) < 1) {
          var tmp = 1 - u2 * u2;
          return 15 / 16 * tmp * tmp;
        }
        return 0;
      },
      triangular: function(u2) {
        var abs6 = Math.abs(u2);
        return abs6 < 1 ? 1 - abs6 : 0;
      },
      tricube: function(u2) {
        return Math.abs(u2) < 1 ? 70 / 81 * tricubed(u2) : 0;
      },
      triweight: function(u2) {
        if (Math.abs(u2) < 1) {
          var tmp = 1 - u2 * u2;
          return 35 / 32 * tmp * tmp * tmp;
        }
        return 0;
      },
      uniform
    };
  }
});

// node_modules/@antv/data-set/lib/transform/kde.js
var require_kde = __commonJS({
  "node_modules/@antv/data-set/lib/transform/kde.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var get_series_values_1 = tslib_1.__importDefault(require_get_series_values());
    var kernel_1 = tslib_1.__importDefault(require_kernel());
    var bandwidth = tslib_1.__importStar(require_bandwidth());
    var partition_1 = tslib_1.__importDefault(require_partition());
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var simple_statistics_1 = (init_simple_statistics(), simple_statistics_exports);
    var DEFAULT_OPTIONS = {
      minSize: 0.01,
      as: ["key", "y", "size"],
      extent: [],
      method: "gaussian",
      bandwidth: "nrd",
      step: 0,
      groupBy: []
    };
    var KERNEL_METHODS = util_1.keys(kernel_1.default);
    var BANDWIDTH_METHODS = util_1.keys(bandwidth);
    function transform(dv, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var fields = option_parser_1.getFields(options);
      if (!util_1.isArray(fields) || fields.length < 1) {
        throw new TypeError("invalid fields: must be an array of at least 1 strings!");
      }
      var as = options.as;
      if (!util_1.isArray(as) || as.length !== 3) {
        throw new TypeError("invalid as: must be an array of 3 strings!");
      }
      var method = options.method;
      if (util_1.isString(method)) {
        if (KERNEL_METHODS.indexOf(method) === -1) {
          throw new TypeError("invalid method: " + method + ". Must be one of " + KERNEL_METHODS.join(", "));
        }
        method = kernel_1.default[method];
      }
      if (!util_1.isFunction(method)) {
        throw new TypeError("invalid method: kernel method must be a function!");
      }
      var extent = options.extent;
      if (!util_1.isArray(extent) || extent.length === 0) {
        var rangeArr_1 = [];
        util_1.each(fields, function(field) {
          var range3 = dv.range(field);
          rangeArr_1 = rangeArr_1.concat(range3);
        });
        extent = [Math.min.apply(Math, tslib_1.__spread(rangeArr_1)), Math.max.apply(Math, tslib_1.__spread(rangeArr_1))];
      }
      var bw = options.bandwidth;
      if (util_1.isString(bw) && bandwidth[bw]) {
        bw = bandwidth[bw](dv.getColumn(fields[0]));
      } else if (util_1.isFunction(bw)) {
        bw = bw(dv.getColumn(fields[0]));
      } else if (!util_1.isNumber(bw) || bw <= 0) {
        bw = bandwidth.nrd(dv.getColumn(fields[0]));
      }
      var seriesValues = get_series_values_1.default(extent, options.step ? options.step : bw);
      var result = [];
      var groupBy = options.groupBy;
      var groups2 = partition_1.default(dv.rows, groupBy);
      util_1.forIn(groups2, function(group2) {
        var probalityDensityFunctionByField = {};
        util_1.each(fields, function(field) {
          var row = util_1.pick(group2[0], groupBy);
          probalityDensityFunctionByField[field] = simple_statistics_1.kernelDensityEstimation(group2.map(function(item) {
            return item[field];
          }), method, bw);
          var _a = tslib_1.__read(as, 3), key = _a[0], y4 = _a[1], size = _a[2];
          row[key] = field;
          row[y4] = [];
          row[size] = [];
          util_1.each(seriesValues, function(yValue) {
            var sizeValue = probalityDensityFunctionByField[field](yValue);
            if (sizeValue >= options.minSize) {
              row[y4].push(yValue);
              row[size].push(sizeValue);
            }
          });
          result.push(row);
        });
      });
      dv.rows = result;
    }
    data_set_1.DataSet.registerTransform("kernel-density-estimation", transform);
    data_set_1.DataSet.registerTransform("kde", transform);
    data_set_1.DataSet.registerTransform("KDE", transform);
    exports.default = {
      KERNEL_METHODS,
      BANDWIDTH_METHODS
    };
  }
});

// node_modules/@antv/data-set/lib/transform/bin/hexagon.js
var require_hexagon = __commonJS({
  "node_modules/@antv/data-set/lib/transform/bin/hexagon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      as: ["x", "y", "count"],
      bins: [30, 30],
      offset: [0, 0],
      sizeByCount: false
    };
    var SQRT3 = Math.sqrt(3);
    var THIRD_PI = Math.PI / 3;
    var ANGLES = [0, THIRD_PI, 2 * THIRD_PI, 3 * THIRD_PI, 4 * THIRD_PI, 5 * THIRD_PI];
    function distance2(x011, y011, x16, y16) {
      return Math.sqrt((x011 - x16) * (x011 - x16) + (y011 - y16) * (y011 - y16));
    }
    function nearestBinsCenters(value2, scale, offset) {
      var temp3 = value2 - offset;
      scale = scale / 2;
      var div = Math.floor(temp3 / scale);
      var rounded = scale * (div + (Math.abs(div % 2) === 1 ? 1 : 0));
      var roundedScaled = scale * (div + (Math.abs(div % 2) === 1 ? 0 : 1));
      return [rounded + offset, roundedScaled + offset];
    }
    function generateBins(points2, binWidth, offset) {
      if (binWidth === void 0) {
        binWidth = [1, 1];
      }
      if (offset === void 0) {
        offset = [0, 0];
      }
      var bins = {};
      var _a = tslib_1.__read(binWidth, 2), binWidthX = _a[0], binWidthY = _a[1];
      var _b = tslib_1.__read(offset, 2), offsetX = _b[0], offsetY = _b[1];
      points2.forEach(function(point5) {
        var _a2, _b2;
        var _c = tslib_1.__read(point5, 2), x4 = _c[0], y4 = _c[1];
        var _d = tslib_1.__read(nearestBinsCenters(x4, binWidthX, offsetX), 2), xRounded = _d[0], xRoundedScaled = _d[1];
        var _e = tslib_1.__read(nearestBinsCenters(y4, binWidthY, offsetY), 2), yRounded = _e[0], yRoundedScaled = _e[1];
        var d1 = distance2(x4, y4, xRounded, yRounded);
        var d2 = distance2(x4, y4, xRoundedScaled, yRoundedScaled);
        var binKey;
        var binX;
        var binY;
        if (d1 < d2) {
          binKey = "x" + xRounded + "y" + yRounded;
          _a2 = tslib_1.__read([xRounded, yRounded], 2), binX = _a2[0], binY = _a2[1];
        } else {
          binKey = "x" + xRoundedScaled + "y" + yRoundedScaled;
          _b2 = tslib_1.__read([xRoundedScaled, yRoundedScaled], 2), binX = _b2[0], binY = _b2[1];
        }
        bins[binKey] = bins[binKey] || {
          x: binX,
          y: binY,
          count: 0
        };
        bins[binKey].count++;
      });
      return bins;
    }
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var fields = option_parser_1.getFields(options);
      if (!util_1.isArray(fields) || fields.length !== 2) {
        throw new TypeError("Invalid fields: it must be an array with 2 strings!");
      }
      var _a = tslib_1.__read(fields, 2), fieldX = _a[0], fieldY = _a[1];
      var rangeFieldX = dataView.range(fieldX);
      var rangeFieldY = dataView.range(fieldY);
      var widthX = rangeFieldX[1] - rangeFieldX[0];
      var widthY = rangeFieldY[1] - rangeFieldY[0];
      var binWidth = options.binWidth || [];
      if (binWidth.length !== 2) {
        var _b = tslib_1.__read(options.bins, 2), binsX = _b[0], binsY = _b[1];
        if (binsX <= 0 || binsY <= 0) {
          throw new TypeError("Invalid bins: must be an array with two positive numbers (e.g. [ 30, 30 ])!");
        }
        binWidth = [widthX / binsX, widthY / binsY];
      }
      var _c = tslib_1.__read(options.offset, 2), offsetX = _c[0], offsetY = _c[1];
      var yScale = 3 * binWidth[0] / (SQRT3 * binWidth[1]);
      var points2 = dataView.rows.map(function(row) {
        return [row[fieldX], yScale * row[fieldY]];
      });
      var bins = generateBins(points2, [binWidth[0], yScale * binWidth[1]], [offsetX, yScale * offsetY]);
      var _d = tslib_1.__read(options.as, 3), asX = _d[0], asY = _d[1], asCount = _d[2];
      if (!asX || !asY || !asCount) {
        throw new TypeError('Invalid as: it must be an array with three elements (e.g. [ "x", "y", "count" ])!');
      }
      var radius = binWidth[0] / SQRT3;
      var hexagonPoints = ANGLES.map(function(angle5) {
        return [Math.sin(angle5) * radius, -Math.cos(angle5) * radius];
      });
      var result = [];
      var maxCount = 0;
      if (options.sizeByCount) {
        util_1.forIn(bins, function(bin) {
          if (bin.count > maxCount) {
            maxCount = bin.count;
          }
        });
      }
      util_1.forIn(bins, function(bin) {
        var x4 = bin.x, y4 = bin.y, count3 = bin.count;
        var row = {};
        row[asCount] = count3;
        if (options.sizeByCount) {
          row[asX] = hexagonPoints.map(function(p2) {
            return x4 + bin.count / maxCount * p2[0];
          });
          row[asY] = hexagonPoints.map(function(p2) {
            return (y4 + bin.count / maxCount * p2[1]) / yScale;
          });
        } else {
          row[asX] = hexagonPoints.map(function(p2) {
            return x4 + p2[0];
          });
          row[asY] = hexagonPoints.map(function(p2) {
            return (y4 + p2[1]) / yScale;
          });
        }
        result.push(row);
      });
      dataView.rows = result;
    }
    data_set_1.DataSet.registerTransform("bin.hexagon", transform);
    data_set_1.DataSet.registerTransform("bin.hex", transform);
    data_set_1.DataSet.registerTransform("hexbin", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/bin/histogram.js
var require_histogram = __commonJS({
  "node_modules/@antv/data-set/lib/transform/bin/histogram.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var partition_1 = tslib_1.__importDefault(require_partition());
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      as: ["x", "count"],
      bins: void 0,
      offset: 0,
      groupBy: []
    };
    function nearestBin(value2, scale, offset) {
      var temp3 = value2 - offset;
      var div = Math.floor(temp3 / scale);
      return [div * scale + offset, (div + 1) * scale + offset];
    }
    function sturges(dataLength) {
      return Math.ceil(Math.log(dataLength) / Math.LN2) + 1;
    }
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var field = option_parser_1.getField(options);
      if (dataView.rows.length === 0) {
        return;
      }
      var range3 = dataView.range(field);
      var width = range3[1] - range3[0];
      var binWidth = options.binWidth;
      var bins = options.bins;
      if (!binWidth && bins) {
        if (bins <= 0) {
          throw new TypeError("Invalid bins: it must be a positive number!");
        }
        binWidth = width / bins;
      }
      if (!binWidth && !bins) {
        var binNumber = sturges(dataView.rows.length);
        binWidth = width / binNumber;
      }
      var offset = options.offset % binWidth;
      var rows = [];
      var groupBy = options.groupBy;
      var groups2 = partition_1.default(dataView.rows, groupBy);
      util_1.forIn(groups2, function(group2) {
        var bins2 = {};
        var column = group2.map(function(row) {
          return row[field];
        });
        column.forEach(function(value2) {
          var _a2 = tslib_1.__read(nearestBin(value2, binWidth, offset), 2), x011 = _a2[0], x16 = _a2[1];
          var binKey = x011 + "-" + x16;
          bins2[binKey] = bins2[binKey] || {
            x0: x011,
            x1: x16,
            count: 0
          };
          bins2[binKey].count++;
        });
        var _a = tslib_1.__read(options.as, 2), asX = _a[0], asCount = _a[1];
        if (!asX || !asCount) {
          throw new TypeError('Invalid as: it must be an array with 2 elements (e.g. [ "x", "count" ])!');
        }
        var meta = util_1.pick(group2[0], groupBy);
        util_1.forIn(bins2, function(bin) {
          var row = util_1.assign({}, meta);
          row[asX] = [bin.x0, bin.x1];
          row[asCount] = bin.count;
          rows.push(row);
        });
      });
      dataView.rows = rows;
    }
    data_set_1.DataSet.registerTransform("bin.histogram", transform);
    data_set_1.DataSet.registerTransform("bin.dot", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/bin/quantile.js
var require_quantile = __commonJS({
  "node_modules/@antv/data-set/lib/transform/bin/quantile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var simple_statistics_1 = (init_simple_statistics(), simple_statistics_exports);
    var partition_1 = tslib_1.__importDefault(require_partition());
    var p_by_fraction_1 = tslib_1.__importDefault(require_p_by_fraction());
    var data_set_1 = require_data_set();
    var registerTransform = data_set_1.DataSet.registerTransform;
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      as: "_bin",
      groupBy: [],
      fraction: 4
    };
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var field = option_parser_1.getField(options);
      var as = options.as;
      if (!util_1.isString(as)) {
        throw new TypeError('Invalid as: it must be a string (e.g. "_bin")!');
      }
      var pArray = options.p;
      var fraction = options.fraction;
      if (!util_1.isArray(pArray) || pArray.length === 0) {
        pArray = p_by_fraction_1.default(fraction);
      }
      var rows = dataView.rows;
      var groupBy = options.groupBy;
      var groups2 = partition_1.default(rows, groupBy);
      var result = [];
      util_1.forIn(groups2, function(group2) {
        var resultRow = group2[0];
        var binningColumn = group2.map(function(row) {
          return row[field];
        });
        var quantiles = pArray.map(function(p2) {
          return simple_statistics_1.quantile(binningColumn, p2);
        });
        resultRow[as] = quantiles;
        result.push(resultRow);
      });
      dataView.rows = result;
    }
    registerTransform("bin.quantile", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/bin/rectangle.js
var require_rectangle = __commonJS({
  "node_modules/@antv/data-set/lib/transform/bin/rectangle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var registerTransform = data_set_1.DataSet.registerTransform;
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      as: ["x", "y", "count"],
      bins: [30, 30],
      offset: [0, 0],
      sizeByCount: false
    };
    function nearestBin(value2, scale, offset) {
      var temp3 = value2 - offset;
      var div = Math.floor(temp3 / scale);
      return [div * scale + offset, (div + 1) * scale + offset];
    }
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var _a = tslib_1.__read(option_parser_1.getFields(options), 2), fieldX = _a[0], fieldY = _a[1];
      if (!fieldX || !fieldY) {
        throw new TypeError("Invalid fields: must be an array with 2 strings!");
      }
      var rangeFieldX = dataView.range(fieldX);
      var rangeFieldY = dataView.range(fieldY);
      var widthX = rangeFieldX[1] - rangeFieldX[0];
      var widthY = rangeFieldY[1] - rangeFieldY[0];
      var binWidth = options.binWidth || [];
      if (binWidth.length !== 2) {
        var _b = tslib_1.__read(options.bins, 2), binsX = _b[0], binsY = _b[1];
        if (binsX <= 0 || binsY <= 0) {
          throw new TypeError("Invalid bins: must be an array with 2 positive numbers (e.g. [ 30, 30 ])!");
        }
        binWidth = [widthX / binsX, widthY / binsY];
      }
      var points2 = dataView.rows.map(function(row) {
        return [row[fieldX], row[fieldY]];
      });
      var bins = {};
      var _c = tslib_1.__read(options.offset, 2), offsetX = _c[0], offsetY = _c[1];
      points2.forEach(function(point5) {
        var _a2 = tslib_1.__read(nearestBin(point5[0], binWidth[0], offsetX), 2), x011 = _a2[0], x16 = _a2[1];
        var _b2 = tslib_1.__read(nearestBin(point5[1], binWidth[1], offsetY), 2), y011 = _b2[0], y16 = _b2[1];
        var binKey = x011 + "-" + x16 + "-" + y011 + "-" + y16;
        bins[binKey] = bins[binKey] || {
          x0: x011,
          x1: x16,
          y0: y011,
          y1: y16,
          count: 0
        };
        bins[binKey].count++;
      });
      var rows = [];
      var _d = tslib_1.__read(options.as, 3), asX = _d[0], asY = _d[1], asCount = _d[2];
      if (!asX || !asY || !asCount) {
        throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ "x", "y", "count" ])!');
      }
      if (!options.sizeByCount) {
        util_1.forIn(bins, function(bin) {
          var row = {};
          row[asX] = [bin.x0, bin.x1, bin.x1, bin.x0];
          row[asY] = [bin.y0, bin.y0, bin.y1, bin.y1];
          row[asCount] = bin.count;
          rows.push(row);
        });
      } else {
        var maxCount_1 = 0;
        util_1.forIn(bins, function(bin) {
          if (bin.count > maxCount_1) {
            maxCount_1 = bin.count;
          }
        });
        util_1.forIn(bins, function(bin) {
          var x011 = bin.x0, x16 = bin.x1, y011 = bin.y0, y16 = bin.y1, count3 = bin.count;
          var scale = count3 / maxCount_1;
          var _a2 = tslib_1.__read([(x011 + x16) / 2, (y011 + y16) / 2], 2), cx = _a2[0], cy = _a2[1];
          var rx = (x16 - x011) * scale / 2;
          var ry = (y16 - y011) * scale / 2;
          var x01 = cx - rx;
          var x11 = cx + rx;
          var y01 = cy - ry;
          var y11 = cy + ry;
          var row = {};
          row[asX] = [x01, x11, x11, x01];
          row[asY] = [y01, y01, y11, y11];
          row[asCount] = count3;
          rows.push(row);
        });
      }
      dataView.rows = rows;
    }
    registerTransform("bin.rectangle", transform);
    registerTransform("bin.rect", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/geo/centroid.js
var require_centroid = __commonJS({
  "node_modules/@antv/data-set/lib/transform/geo/centroid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var registerTransform = data_set_1.DataSet.registerTransform;
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      as: ["_centroid_x", "_centroid_y"]
    };
    function transform(view, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var field = option_parser_1.getField(options);
      var geoView = options.geoView || options.geoDataView;
      if (util_1.isString(geoView) && view.dataSet) {
        geoView = view.dataSet.getView(geoView);
      }
      if (!geoView || geoView.dataType !== "geo") {
        throw new TypeError("Invalid geoView: must be a DataView of GEO dataType!");
      }
      var as = options.as;
      if (!util_1.isArray(as) || as.length !== 2) {
        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "cX", "cY" ])!');
      }
      var centroidX = as[0];
      var centroidY = as[1];
      view.rows.forEach(function(row) {
        var feature2 = geoView.geoFeatureByName(row[field]);
        if (feature2) {
          if (geoView._projectedAs) {
            row[centroidX] = feature2[geoView._projectedAs[2]];
            row[centroidY] = feature2[geoView._projectedAs[3]];
          } else {
            row[centroidX] = feature2.centroidX;
            row[centroidY] = feature2.centroidY;
          }
        }
      });
    }
    registerTransform("geo.centroid", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/geo/projection.js
var require_projection = __commonJS({
  "node_modules/@antv/data-set/lib/transform/geo/projection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var d3_geo_1 = (init_d3_geo(), d3_geo_exports);
    var point_at_length_1 = tslib_1.__importDefault(require_point_at_length());
    var data_set_1 = require_data_set();
    var registerTransform = data_set_1.DataSet.registerTransform;
    var get_geo_projection_1 = tslib_1.__importDefault(require_get_geo_projection());
    var DEFAULT_OPTIONS = {
      as: ["_x", "_y", "_centroid_x", "_centroid_y"]
    };
    function transform(dataView, options) {
      if (dataView.dataType !== "geo" && dataView.dataType !== "geo-graticule") {
        throw new TypeError("Invalid dataView: this transform is for Geo data only!");
      }
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var projection4 = options.projection;
      if (!projection4) {
        throw new TypeError("Invalid projection!");
      }
      projection4 = get_geo_projection_1.default(projection4);
      var geoPathGenerator = d3_geo_1.geoPath(projection4);
      var as = options.as;
      if (!util_1.isArray(as) || as.length !== 4) {
        throw new TypeError('Invalid as: it must be an array with 4 strings (e.g. [ "x", "y", "cX", "cY" ])!');
      }
      dataView._projectedAs = as;
      var _a = tslib_1.__read(as, 4), lonField = _a[0], latField = _a[1], centroidX = _a[2], centroidY = _a[3];
      dataView.rows.forEach(function(row) {
        row[lonField] = [];
        row[latField] = [];
        var pathData = geoPathGenerator(row);
        if (pathData) {
          var points2 = point_at_length_1.default(pathData);
          points2._path.forEach(function(point5) {
            row[lonField].push(point5[1]);
            row[latField].push(point5[2]);
          });
          var centroid = geoPathGenerator.centroid(row);
          row[centroidX] = centroid[0];
          row[centroidY] = centroid[1];
        }
      });
      dataView.rows = dataView.rows.filter(function(row) {
        return row[lonField].length !== 0;
      });
    }
    registerTransform("geo.projection", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/geo/region.js
var require_region = __commonJS({
  "node_modules/@antv/data-set/lib/transform/geo/region.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var registerTransform = data_set_1.DataSet.registerTransform;
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      as: ["_x", "_y"]
    };
    function transform(view, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var field = option_parser_1.getField(options);
      var geoView = options.geoView || options.geoDataView;
      if (util_1.isString(geoView)) {
        geoView = view.dataSet.getView(geoView);
      }
      if (!geoView || geoView.dataType !== "geo") {
        throw new TypeError("Invalid geoView: must be a DataView of GEO dataType!");
      }
      var as = options.as;
      if (!util_1.isArray(as) || as.length !== 2) {
        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
      }
      var lonField = as[0];
      var latField = as[1];
      view.rows.forEach(function(row) {
        var feature2 = geoView.geoFeatureByName(row[field]);
        if (feature2) {
          if (geoView._projectedAs) {
            row[lonField] = feature2[geoView._projectedAs[0]];
            row[latField] = feature2[geoView._projectedAs[1]];
          } else {
            row[lonField] = feature2.longitude;
            row[latField] = feature2.latitude;
          }
        }
      });
    }
    registerTransform("geo.region", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/diagram/arc.js
var require_arc = __commonJS({
  "node_modules/@antv/data-set/lib/transform/diagram/arc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var DEFAULT_OPTIONS = {
      y: 0,
      thickness: 0.05,
      weight: false,
      marginRatio: 0.1,
      id: function(node) {
        return node.id;
      },
      source: function(edge) {
        return edge.source;
      },
      target: function(edge) {
        return edge.target;
      },
      sourceWeight: function(edge) {
        return edge.value || 1;
      },
      targetWeight: function(edge) {
        return edge.value || 1;
      },
      sortBy: null
    };
    function _nodesFromEdges(edges2, options, map5) {
      if (map5 === void 0) {
        map5 = {};
      }
      edges2.forEach(function(edge) {
        var sId = options.edgeSource(edge);
        var tId = options.edgeTarget(edge);
        if (!map5[sId]) {
          map5[sId] = {
            id: sId
          };
        }
        if (!map5[tId]) {
          map5[tId] = {
            id: tId
          };
        }
      });
      return util_1.values(map5);
    }
    function _processGraph(nodeById, edges2, options) {
      util_1.forIn(nodeById, function(node, id) {
        node.inEdges = edges2.filter(function(edge) {
          return "" + options.target(edge) === "" + id;
        });
        node.outEdges = edges2.filter(function(edge) {
          return "" + options.source(edge) === "" + id;
        });
        node.edges = node.outEdges.concat(node.inEdges);
        node.frequency = node.edges.length;
        node.value = 0;
        node.inEdges.forEach(function(edge) {
          node.value += options.targetWeight(edge);
        });
        node.outEdges.forEach(function(edge) {
          node.value += options.sourceWeight(edge);
        });
      });
    }
    function _sortNodes(nodes, options) {
      var sortMethods = {
        weight: function(a3, b2) {
          return b2.value - a3.value;
        },
        frequency: function(a3, b2) {
          return b2.frequency - a3.frequency;
        },
        id: function(a3, b2) {
          return ("" + options.id(a3)).localeCompare("" + options.id(b2));
        }
      };
      var method = sortMethods[options.sortBy];
      if (!method && util_1.isFunction(options.sortBy)) {
        method = options.sortBy;
      }
      if (method) {
        nodes.sort(method);
      }
    }
    function _layoutNodes(nodes, options) {
      var len = nodes.length;
      if (!len) {
        throw new TypeError("Invalid nodes: it's empty!");
      }
      if (options.weight) {
        var marginRatio_1 = options.marginRatio;
        if (marginRatio_1 < 0 || marginRatio_1 >= 1) {
          throw new TypeError("Invalid marginRatio: it must be in range [0, 1)!");
        }
        var margin_1 = marginRatio_1 / (2 * len);
        var thickness_1 = options.thickness;
        if (thickness_1 <= 0 || thickness_1 >= 1) {
          throw new TypeError("Invalid thickness: it must be in range (0, 1)!");
        }
        var totalValue_1 = 0;
        nodes.forEach(function(node) {
          totalValue_1 += node.value;
        });
        nodes.forEach(function(node) {
          node.weight = node.value / totalValue_1;
          node.width = node.weight * (1 - marginRatio_1);
          node.height = thickness_1;
        });
        nodes.forEach(function(node, index2) {
          var deltaX = 0;
          for (var i2 = index2 - 1; i2 >= 0; i2--) {
            deltaX += nodes[i2].width + 2 * margin_1;
          }
          var minX = node.minX = margin_1 + deltaX;
          var maxX = node.maxX = node.minX + node.width;
          var minY = node.minY = options.y - thickness_1 / 2;
          var maxY2 = node.maxY = minY + thickness_1;
          node.x = [minX, maxX, maxX, minX];
          node.y = [minY, minY, maxY2, maxY2];
        });
      } else {
        var deltaX_1 = 1 / len;
        nodes.forEach(function(node, index2) {
          node.x = (index2 + 0.5) * deltaX_1;
          node.y = options.y;
        });
      }
    }
    function _locatingEdges(nodeById, edges2, options) {
      if (options.weight) {
        var valueById_1 = {};
        util_1.forIn(nodeById, function(node, id) {
          valueById_1[id] = node.value;
        });
        edges2.forEach(function(edge) {
          var sId = options.source(edge);
          var tId = options.target(edge);
          var sNode = nodeById[sId];
          var tNode = nodeById[tId];
          if (sNode && tNode) {
            var sValue = valueById_1[sId];
            var currentSValue = options.sourceWeight(edge);
            var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;
            var sEnd = sStart + currentSValue / sNode.value * sNode.width;
            valueById_1[sId] -= currentSValue;
            var tValue = valueById_1[tId];
            var currentTValue = options.targetWeight(edge);
            var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;
            var tEnd = tStart + currentTValue / tNode.value * tNode.width;
            valueById_1[tId] -= currentTValue;
            var y4 = options.y;
            edge.x = [sStart, sEnd, tStart, tEnd];
            edge.y = [y4, y4, y4, y4];
          }
        });
      } else {
        edges2.forEach(function(edge) {
          var sNode = nodeById[options.source(edge)];
          var tNode = nodeById[options.target(edge)];
          if (sNode && tNode) {
            edge.x = [sNode.x, tNode.x];
            edge.y = [sNode.y, tNode.y];
          }
        });
      }
    }
    function transform(dv, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var nodeById = {};
      var nodes = dv.nodes;
      var edges2 = dv.edges;
      if (!util_1.isArray(nodes) || nodes.length === 0) {
        nodes = _nodesFromEdges(edges2, options, nodeById);
      }
      nodes.forEach(function(node) {
        var id = options.id(node);
        nodeById[id] = node;
      });
      _processGraph(nodeById, edges2, options);
      _sortNodes(nodes, options);
      _layoutNodes(nodes, options);
      _locatingEdges(nodeById, edges2, options);
      dv.nodes = nodes;
      dv.edges = edges2;
    }
    data_set_1.DataSet.registerTransform("diagram.arc", transform);
    data_set_1.DataSet.registerTransform("arc", transform);
  }
});

// node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/lodash/clone.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value2) {
      return baseClone(value2, CLONE_SYMBOLS_FLAG);
    }
    module.exports = clone;
  }
});

// node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "node_modules/lodash/forEach.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module.exports = forEach;
  }
});

// node_modules/lodash/each.js
var require_each = __commonJS({
  "node_modules/lodash/each.js"(exports, module) {
    module.exports = require_forEach();
  }
});

// node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/lodash/_baseFilter.js"(exports, module) {
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value2, index2, collection2) {
        if (predicate(value2, index2, collection2)) {
          result.push(value2);
        }
      });
      return result;
    }
    module.exports = baseFilter;
  }
});

// node_modules/lodash/filter.js
var require_filter2 = __commonJS({
  "node_modules/lodash/filter.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter2(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    module.exports = filter2;
  }
});

// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/lodash/isEmpty.js"(exports, module) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty(value2) {
      if (value2 == null) {
        return true;
      }
      if (isArrayLike(value2) && (isArray(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer(value2) || isTypedArray(value2) || isArguments(value2))) {
        return !value2.length;
      }
      var tag = getTag(value2);
      if (tag == mapTag || tag == setTag) {
        return !value2.size;
      }
      if (isPrototype(value2)) {
        return !baseKeys(value2).length;
      }
      for (var key in value2) {
        if (hasOwnProperty.call(value2, key)) {
          return false;
        }
      }
      return true;
    }
    module.exports = isEmpty;
  }
});

// node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/lodash/isUndefined.js"(exports, module) {
    function isUndefined(value2) {
      return value2 === void 0;
    }
    module.exports = isUndefined;
  }
});

// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/lodash/_arrayReduce.js"(exports, module) {
    function arrayReduce(array3, iteratee, accumulator, initAccum) {
      var index2 = -1, length2 = array3 == null ? 0 : array3.length;
      if (initAccum && length2) {
        accumulator = array3[++index2];
      }
      while (++index2 < length2) {
        accumulator = iteratee(accumulator, array3[index2], index2, array3);
      }
      return accumulator;
    }
    module.exports = arrayReduce;
  }
});

// node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "node_modules/lodash/_baseReduce.js"(exports, module) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value2, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value2) : iteratee(accumulator, value2, index2, collection2);
      });
      return accumulator;
    }
    module.exports = baseReduce;
  }
});

// node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "node_modules/lodash/reduce.js"(exports, module) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray = require_isArray();
    function reduce2(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module.exports = reduce2;
  }
});

// node_modules/lodash/_asciiSize.js
var require_asciiSize = __commonJS({
  "node_modules/lodash/_asciiSize.js"(exports, module) {
    var baseProperty = require_baseProperty();
    var asciiSize = baseProperty("length");
    module.exports = asciiSize;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module.exports = hasUnicode;
  }
});

// node_modules/lodash/_unicodeSize.js
var require_unicodeSize = __commonJS({
  "node_modules/lodash/_unicodeSize.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    module.exports = unicodeSize;
  }
});

// node_modules/lodash/_stringSize.js
var require_stringSize = __commonJS({
  "node_modules/lodash/_stringSize.js"(exports, module) {
    var asciiSize = require_asciiSize();
    var hasUnicode = require_hasUnicode();
    var unicodeSize = require_unicodeSize();
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    module.exports = stringSize;
  }
});

// node_modules/lodash/size.js
var require_size = __commonJS({
  "node_modules/lodash/size.js"(exports, module) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var stringSize = require_stringSize();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }
    module.exports = size;
  }
});

// node_modules/lodash/transform.js
var require_transform = __commonJS({
  "node_modules/lodash/transform.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var baseCreate = require_baseCreate();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    var getPrototype = require_getPrototype();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isTypedArray = require_isTypedArray();
    function transform(object3, iteratee, accumulator) {
      var isArr = isArray(object3), isArrLike = isArr || isBuffer(object3) || isTypedArray(object3);
      iteratee = baseIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object3 && object3.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor() : [];
        } else if (isObject(object3)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object3)) : {};
        } else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object3, function(value2, index2, object4) {
        return iteratee(accumulator, value2, index2, object4);
      });
      return accumulator;
    }
    module.exports = transform;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    function baseFindIndex(array3, predicate, fromIndex, fromRight) {
      var length2 = array3.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (predicate(array3[index2], index2, array3)) {
          return index2;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    function baseIsNaN(value2) {
      return value2 !== value2;
    }
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    function strictIndexOf(array3, value2, fromIndex) {
      var index2 = fromIndex - 1, length2 = array3.length;
      while (++index2 < length2) {
        if (array3[index2] === value2) {
          return index2;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array3, value2, fromIndex) {
      return value2 === value2 ? strictIndexOf(array3, value2, fromIndex) : baseFindIndex(array3, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array3, value2) {
      var length2 = array3 == null ? 0 : array3.length;
      return !!length2 && baseIndexOf(array3, value2, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    function arrayIncludesWith(array3, value2, comparator) {
      var index2 = -1, length2 = array3 == null ? 0 : array3.length;
      while (++index2 < length2) {
        if (comparator(value2, array3[index2])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop5() {
    }
    module.exports = noop5;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module) {
    var Set3 = require_Set();
    var noop5 = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set3 && 1 / setToArray(new Set3([, -0]))[1] == INFINITY) ? noop5 : function(values) {
      return new Set3(values);
    };
    module.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array3, iteratee, comparator) {
      var index2 = -1, includes = arrayIncludes, length2 = array3.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length2 >= LARGE_ARRAY_SIZE) {
        var set3 = iteratee ? null : createSet(array3);
        if (set3) {
          return setToArray(set3);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index2 < length2) {
          var value2 = array3[index2], computed = iteratee ? iteratee(value2) : value2;
          value2 = comparator || value2 !== 0 ? value2 : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value2);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value2);
          }
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// node_modules/lodash/union.js
var require_union = __commonJS({
  "node_modules/lodash/union.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var baseUniq = require_baseUniq();
    var isArrayLikeObject = require_isArrayLikeObject();
    var union2 = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    module.exports = union2;
  }
});

// node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/lodash/_baseValues.js"(exports, module) {
    var arrayMap = require_arrayMap();
    function baseValues(object3, props) {
      return arrayMap(props, function(key) {
        return object3[key];
      });
    }
    module.exports = baseValues;
  }
});

// node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/lodash/values.js"(exports, module) {
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object3) {
      return object3 == null ? [] : baseValues(object3, keys(object3));
    }
    module.exports = values;
  }
});

// node_modules/graphlib/lib/lodash.js
var require_lodash = __commonJS({
  "node_modules/graphlib/lib/lodash.js"(exports, module) {
    var lodash;
    if (typeof __require === "function") {
      try {
        lodash = {
          clone: require_clone(),
          constant: require_constant(),
          each: require_each(),
          filter: require_filter2(),
          has: require_has(),
          isArray: require_isArray(),
          isEmpty: require_isEmpty(),
          isFunction: require_isFunction(),
          isUndefined: require_isUndefined(),
          keys: require_keys(),
          map: require_map(),
          reduce: require_reduce(),
          size: require_size(),
          transform: require_transform(),
          union: require_union(),
          values: require_values()
        };
      } catch (e3) {
      }
    }
    if (!lodash) {
      lodash = window._;
    }
    module.exports = lodash;
  }
});

// node_modules/graphlib/lib/graph.js
var require_graph2 = __commonJS({
  "node_modules/graphlib/lib/graph.js"(exports, module) {
    "use strict";
    var _2 = require_lodash();
    module.exports = Graph;
    var DEFAULT_EDGE_NAME = "\0";
    var GRAPH_NODE = "\0";
    var EDGE_KEY_DELIM = "";
    function Graph(opts) {
      this._isDirected = _2.has(opts, "directed") ? opts.directed : true;
      this._isMultigraph = _2.has(opts, "multigraph") ? opts.multigraph : false;
      this._isCompound = _2.has(opts, "compound") ? opts.compound : false;
      this._label = void 0;
      this._defaultNodeLabelFn = _2.constant(void 0);
      this._defaultEdgeLabelFn = _2.constant(void 0);
      this._nodes = {};
      if (this._isCompound) {
        this._parent = {};
        this._children = {};
        this._children[GRAPH_NODE] = {};
      }
      this._in = {};
      this._preds = {};
      this._out = {};
      this._sucs = {};
      this._edgeObjs = {};
      this._edgeLabels = {};
    }
    Graph.prototype._nodeCount = 0;
    Graph.prototype._edgeCount = 0;
    Graph.prototype.isDirected = function() {
      return this._isDirected;
    };
    Graph.prototype.isMultigraph = function() {
      return this._isMultigraph;
    };
    Graph.prototype.isCompound = function() {
      return this._isCompound;
    };
    Graph.prototype.setGraph = function(label) {
      this._label = label;
      return this;
    };
    Graph.prototype.graph = function() {
      return this._label;
    };
    Graph.prototype.setDefaultNodeLabel = function(newDefault) {
      if (!_2.isFunction(newDefault)) {
        newDefault = _2.constant(newDefault);
      }
      this._defaultNodeLabelFn = newDefault;
      return this;
    };
    Graph.prototype.nodeCount = function() {
      return this._nodeCount;
    };
    Graph.prototype.nodes = function() {
      return _2.keys(this._nodes);
    };
    Graph.prototype.sources = function() {
      var self = this;
      return _2.filter(this.nodes(), function(v2) {
        return _2.isEmpty(self._in[v2]);
      });
    };
    Graph.prototype.sinks = function() {
      var self = this;
      return _2.filter(this.nodes(), function(v2) {
        return _2.isEmpty(self._out[v2]);
      });
    };
    Graph.prototype.setNodes = function(vs, value2) {
      var args = arguments;
      var self = this;
      _2.each(vs, function(v2) {
        if (args.length > 1) {
          self.setNode(v2, value2);
        } else {
          self.setNode(v2);
        }
      });
      return this;
    };
    Graph.prototype.setNode = function(v2, value2) {
      if (_2.has(this._nodes, v2)) {
        if (arguments.length > 1) {
          this._nodes[v2] = value2;
        }
        return this;
      }
      this._nodes[v2] = arguments.length > 1 ? value2 : this._defaultNodeLabelFn(v2);
      if (this._isCompound) {
        this._parent[v2] = GRAPH_NODE;
        this._children[v2] = {};
        this._children[GRAPH_NODE][v2] = true;
      }
      this._in[v2] = {};
      this._preds[v2] = {};
      this._out[v2] = {};
      this._sucs[v2] = {};
      ++this._nodeCount;
      return this;
    };
    Graph.prototype.node = function(v2) {
      return this._nodes[v2];
    };
    Graph.prototype.hasNode = function(v2) {
      return _2.has(this._nodes, v2);
    };
    Graph.prototype.removeNode = function(v2) {
      var self = this;
      if (_2.has(this._nodes, v2)) {
        var removeEdge = function(e3) {
          self.removeEdge(self._edgeObjs[e3]);
        };
        delete this._nodes[v2];
        if (this._isCompound) {
          this._removeFromParentsChildList(v2);
          delete this._parent[v2];
          _2.each(this.children(v2), function(child) {
            self.setParent(child);
          });
          delete this._children[v2];
        }
        _2.each(_2.keys(this._in[v2]), removeEdge);
        delete this._in[v2];
        delete this._preds[v2];
        _2.each(_2.keys(this._out[v2]), removeEdge);
        delete this._out[v2];
        delete this._sucs[v2];
        --this._nodeCount;
      }
      return this;
    };
    Graph.prototype.setParent = function(v2, parent) {
      if (!this._isCompound) {
        throw new Error("Cannot set parent in a non-compound graph");
      }
      if (_2.isUndefined(parent)) {
        parent = GRAPH_NODE;
      } else {
        parent += "";
        for (var ancestor = parent; !_2.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
          if (ancestor === v2) {
            throw new Error("Setting " + parent + " as parent of " + v2 + " would create a cycle");
          }
        }
        this.setNode(parent);
      }
      this.setNode(v2);
      this._removeFromParentsChildList(v2);
      this._parent[v2] = parent;
      this._children[parent][v2] = true;
      return this;
    };
    Graph.prototype._removeFromParentsChildList = function(v2) {
      delete this._children[this._parent[v2]][v2];
    };
    Graph.prototype.parent = function(v2) {
      if (this._isCompound) {
        var parent = this._parent[v2];
        if (parent !== GRAPH_NODE) {
          return parent;
        }
      }
    };
    Graph.prototype.children = function(v2) {
      if (_2.isUndefined(v2)) {
        v2 = GRAPH_NODE;
      }
      if (this._isCompound) {
        var children = this._children[v2];
        if (children) {
          return _2.keys(children);
        }
      } else if (v2 === GRAPH_NODE) {
        return this.nodes();
      } else if (this.hasNode(v2)) {
        return [];
      }
    };
    Graph.prototype.predecessors = function(v2) {
      var predsV = this._preds[v2];
      if (predsV) {
        return _2.keys(predsV);
      }
    };
    Graph.prototype.successors = function(v2) {
      var sucsV = this._sucs[v2];
      if (sucsV) {
        return _2.keys(sucsV);
      }
    };
    Graph.prototype.neighbors = function(v2) {
      var preds = this.predecessors(v2);
      if (preds) {
        return _2.union(preds, this.successors(v2));
      }
    };
    Graph.prototype.isLeaf = function(v2) {
      var neighbors;
      if (this.isDirected()) {
        neighbors = this.successors(v2);
      } else {
        neighbors = this.neighbors(v2);
      }
      return neighbors.length === 0;
    };
    Graph.prototype.filterNodes = function(filter2) {
      var copy = new this.constructor({
        directed: this._isDirected,
        multigraph: this._isMultigraph,
        compound: this._isCompound
      });
      copy.setGraph(this.graph());
      var self = this;
      _2.each(this._nodes, function(value2, v2) {
        if (filter2(v2)) {
          copy.setNode(v2, value2);
        }
      });
      _2.each(this._edgeObjs, function(e3) {
        if (copy.hasNode(e3.v) && copy.hasNode(e3.w)) {
          copy.setEdge(e3, self.edge(e3));
        }
      });
      var parents = {};
      function findParent(v2) {
        var parent = self.parent(v2);
        if (parent === void 0 || copy.hasNode(parent)) {
          parents[v2] = parent;
          return parent;
        } else if (parent in parents) {
          return parents[parent];
        } else {
          return findParent(parent);
        }
      }
      if (this._isCompound) {
        _2.each(copy.nodes(), function(v2) {
          copy.setParent(v2, findParent(v2));
        });
      }
      return copy;
    };
    Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
      if (!_2.isFunction(newDefault)) {
        newDefault = _2.constant(newDefault);
      }
      this._defaultEdgeLabelFn = newDefault;
      return this;
    };
    Graph.prototype.edgeCount = function() {
      return this._edgeCount;
    };
    Graph.prototype.edges = function() {
      return _2.values(this._edgeObjs);
    };
    Graph.prototype.setPath = function(vs, value2) {
      var self = this;
      var args = arguments;
      _2.reduce(vs, function(v2, w3) {
        if (args.length > 1) {
          self.setEdge(v2, w3, value2);
        } else {
          self.setEdge(v2, w3);
        }
        return w3;
      });
      return this;
    };
    Graph.prototype.setEdge = function() {
      var v2, w3, name, value2;
      var valueSpecified = false;
      var arg0 = arguments[0];
      if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
        v2 = arg0.v;
        w3 = arg0.w;
        name = arg0.name;
        if (arguments.length === 2) {
          value2 = arguments[1];
          valueSpecified = true;
        }
      } else {
        v2 = arg0;
        w3 = arguments[1];
        name = arguments[3];
        if (arguments.length > 2) {
          value2 = arguments[2];
          valueSpecified = true;
        }
      }
      v2 = "" + v2;
      w3 = "" + w3;
      if (!_2.isUndefined(name)) {
        name = "" + name;
      }
      var e3 = edgeArgsToId(this._isDirected, v2, w3, name);
      if (_2.has(this._edgeLabels, e3)) {
        if (valueSpecified) {
          this._edgeLabels[e3] = value2;
        }
        return this;
      }
      if (!_2.isUndefined(name) && !this._isMultigraph) {
        throw new Error("Cannot set a named edge when isMultigraph = false");
      }
      this.setNode(v2);
      this.setNode(w3);
      this._edgeLabels[e3] = valueSpecified ? value2 : this._defaultEdgeLabelFn(v2, w3, name);
      var edgeObj = edgeArgsToObj(this._isDirected, v2, w3, name);
      v2 = edgeObj.v;
      w3 = edgeObj.w;
      Object.freeze(edgeObj);
      this._edgeObjs[e3] = edgeObj;
      incrementOrInitEntry(this._preds[w3], v2);
      incrementOrInitEntry(this._sucs[v2], w3);
      this._in[w3][e3] = edgeObj;
      this._out[v2][e3] = edgeObj;
      this._edgeCount++;
      return this;
    };
    Graph.prototype.edge = function(v2, w3, name) {
      var e3 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w3, name);
      return this._edgeLabels[e3];
    };
    Graph.prototype.hasEdge = function(v2, w3, name) {
      var e3 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w3, name);
      return _2.has(this._edgeLabels, e3);
    };
    Graph.prototype.removeEdge = function(v2, w3, name) {
      var e3 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w3, name);
      var edge = this._edgeObjs[e3];
      if (edge) {
        v2 = edge.v;
        w3 = edge.w;
        delete this._edgeLabels[e3];
        delete this._edgeObjs[e3];
        decrementOrRemoveEntry(this._preds[w3], v2);
        decrementOrRemoveEntry(this._sucs[v2], w3);
        delete this._in[w3][e3];
        delete this._out[v2][e3];
        this._edgeCount--;
      }
      return this;
    };
    Graph.prototype.inEdges = function(v2, u2) {
      var inV = this._in[v2];
      if (inV) {
        var edges2 = _2.values(inV);
        if (!u2) {
          return edges2;
        }
        return _2.filter(edges2, function(edge) {
          return edge.v === u2;
        });
      }
    };
    Graph.prototype.outEdges = function(v2, w3) {
      var outV = this._out[v2];
      if (outV) {
        var edges2 = _2.values(outV);
        if (!w3) {
          return edges2;
        }
        return _2.filter(edges2, function(edge) {
          return edge.w === w3;
        });
      }
    };
    Graph.prototype.nodeEdges = function(v2, w3) {
      var inEdges = this.inEdges(v2, w3);
      if (inEdges) {
        return inEdges.concat(this.outEdges(v2, w3));
      }
    };
    function incrementOrInitEntry(map5, k4) {
      if (map5[k4]) {
        map5[k4]++;
      } else {
        map5[k4] = 1;
      }
    }
    function decrementOrRemoveEntry(map5, k4) {
      if (!--map5[k4]) {
        delete map5[k4];
      }
    }
    function edgeArgsToId(isDirected, v_, w_, name) {
      var v2 = "" + v_;
      var w3 = "" + w_;
      if (!isDirected && v2 > w3) {
        var tmp = v2;
        v2 = w3;
        w3 = tmp;
      }
      return v2 + EDGE_KEY_DELIM + w3 + EDGE_KEY_DELIM + (_2.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
    }
    function edgeArgsToObj(isDirected, v_, w_, name) {
      var v2 = "" + v_;
      var w3 = "" + w_;
      if (!isDirected && v2 > w3) {
        var tmp = v2;
        v2 = w3;
        w3 = tmp;
      }
      var edgeObj = { v: v2, w: w3 };
      if (name) {
        edgeObj.name = name;
      }
      return edgeObj;
    }
    function edgeObjToId(isDirected, edgeObj) {
      return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
    }
  }
});

// node_modules/graphlib/lib/version.js
var require_version = __commonJS({
  "node_modules/graphlib/lib/version.js"(exports, module) {
    module.exports = "2.1.8";
  }
});

// node_modules/graphlib/lib/index.js
var require_lib = __commonJS({
  "node_modules/graphlib/lib/index.js"(exports, module) {
    module.exports = {
      Graph: require_graph2(),
      version: require_version()
    };
  }
});

// node_modules/graphlib/lib/json.js
var require_json = __commonJS({
  "node_modules/graphlib/lib/json.js"(exports, module) {
    var _2 = require_lodash();
    var Graph = require_graph2();
    module.exports = {
      write,
      read
    };
    function write(g2) {
      var json = {
        options: {
          directed: g2.isDirected(),
          multigraph: g2.isMultigraph(),
          compound: g2.isCompound()
        },
        nodes: writeNodes(g2),
        edges: writeEdges(g2)
      };
      if (!_2.isUndefined(g2.graph())) {
        json.value = _2.clone(g2.graph());
      }
      return json;
    }
    function writeNodes(g2) {
      return _2.map(g2.nodes(), function(v2) {
        var nodeValue = g2.node(v2);
        var parent = g2.parent(v2);
        var node = { v: v2 };
        if (!_2.isUndefined(nodeValue)) {
          node.value = nodeValue;
        }
        if (!_2.isUndefined(parent)) {
          node.parent = parent;
        }
        return node;
      });
    }
    function writeEdges(g2) {
      return _2.map(g2.edges(), function(e3) {
        var edgeValue = g2.edge(e3);
        var edge = { v: e3.v, w: e3.w };
        if (!_2.isUndefined(e3.name)) {
          edge.name = e3.name;
        }
        if (!_2.isUndefined(edgeValue)) {
          edge.value = edgeValue;
        }
        return edge;
      });
    }
    function read(json) {
      var g2 = new Graph(json.options).setGraph(json.value);
      _2.each(json.nodes, function(entry) {
        g2.setNode(entry.v, entry.value);
        if (entry.parent) {
          g2.setParent(entry.v, entry.parent);
        }
      });
      _2.each(json.edges, function(entry) {
        g2.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
      });
      return g2;
    }
  }
});

// node_modules/graphlib/lib/alg/components.js
var require_components = __commonJS({
  "node_modules/graphlib/lib/alg/components.js"(exports, module) {
    var _2 = require_lodash();
    module.exports = components;
    function components(g2) {
      var visited = {};
      var cmpts = [];
      var cmpt;
      function dfs(v2) {
        if (_2.has(visited, v2))
          return;
        visited[v2] = true;
        cmpt.push(v2);
        _2.each(g2.successors(v2), dfs);
        _2.each(g2.predecessors(v2), dfs);
      }
      _2.each(g2.nodes(), function(v2) {
        cmpt = [];
        dfs(v2);
        if (cmpt.length) {
          cmpts.push(cmpt);
        }
      });
      return cmpts;
    }
  }
});

// node_modules/graphlib/lib/data/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/graphlib/lib/data/priority-queue.js"(exports, module) {
    var _2 = require_lodash();
    module.exports = PriorityQueue;
    function PriorityQueue() {
      this._arr = [];
      this._keyIndices = {};
    }
    PriorityQueue.prototype.size = function() {
      return this._arr.length;
    };
    PriorityQueue.prototype.keys = function() {
      return this._arr.map(function(x4) {
        return x4.key;
      });
    };
    PriorityQueue.prototype.has = function(key) {
      return _2.has(this._keyIndices, key);
    };
    PriorityQueue.prototype.priority = function(key) {
      var index2 = this._keyIndices[key];
      if (index2 !== void 0) {
        return this._arr[index2].priority;
      }
    };
    PriorityQueue.prototype.min = function() {
      if (this.size() === 0) {
        throw new Error("Queue underflow");
      }
      return this._arr[0].key;
    };
    PriorityQueue.prototype.add = function(key, priority) {
      var keyIndices = this._keyIndices;
      key = String(key);
      if (!_2.has(keyIndices, key)) {
        var arr = this._arr;
        var index2 = arr.length;
        keyIndices[key] = index2;
        arr.push({ key, priority });
        this._decrease(index2);
        return true;
      }
      return false;
    };
    PriorityQueue.prototype.removeMin = function() {
      this._swap(0, this._arr.length - 1);
      var min4 = this._arr.pop();
      delete this._keyIndices[min4.key];
      this._heapify(0);
      return min4.key;
    };
    PriorityQueue.prototype.decrease = function(key, priority) {
      var index2 = this._keyIndices[key];
      if (priority > this._arr[index2].priority) {
        throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
      }
      this._arr[index2].priority = priority;
      this._decrease(index2);
    };
    PriorityQueue.prototype._heapify = function(i2) {
      var arr = this._arr;
      var l2 = 2 * i2;
      var r2 = l2 + 1;
      var largest = i2;
      if (l2 < arr.length) {
        largest = arr[l2].priority < arr[largest].priority ? l2 : largest;
        if (r2 < arr.length) {
          largest = arr[r2].priority < arr[largest].priority ? r2 : largest;
        }
        if (largest !== i2) {
          this._swap(i2, largest);
          this._heapify(largest);
        }
      }
    };
    PriorityQueue.prototype._decrease = function(index2) {
      var arr = this._arr;
      var priority = arr[index2].priority;
      var parent;
      while (index2 !== 0) {
        parent = index2 >> 1;
        if (arr[parent].priority < priority) {
          break;
        }
        this._swap(index2, parent);
        index2 = parent;
      }
    };
    PriorityQueue.prototype._swap = function(i2, j2) {
      var arr = this._arr;
      var keyIndices = this._keyIndices;
      var origArrI = arr[i2];
      var origArrJ = arr[j2];
      arr[i2] = origArrJ;
      arr[j2] = origArrI;
      keyIndices[origArrJ.key] = i2;
      keyIndices[origArrI.key] = j2;
    };
  }
});

// node_modules/graphlib/lib/alg/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/graphlib/lib/alg/dijkstra.js"(exports, module) {
    var _2 = require_lodash();
    var PriorityQueue = require_priority_queue();
    module.exports = dijkstra;
    var DEFAULT_WEIGHT_FUNC = _2.constant(1);
    function dijkstra(g2, source, weightFn, edgeFn) {
      return runDijkstra(g2, String(source), weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function(v2) {
        return g2.outEdges(v2);
      });
    }
    function runDijkstra(g2, source, weightFn, edgeFn) {
      var results = {};
      var pq = new PriorityQueue();
      var v2, vEntry;
      var updateNeighbors = function(edge) {
        var w3 = edge.v !== v2 ? edge.v : edge.w;
        var wEntry = results[w3];
        var weight = weightFn(edge);
        var distance2 = vEntry.distance + weight;
        if (weight < 0) {
          throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
        }
        if (distance2 < wEntry.distance) {
          wEntry.distance = distance2;
          wEntry.predecessor = v2;
          pq.decrease(w3, distance2);
        }
      };
      g2.nodes().forEach(function(v3) {
        var distance2 = v3 === source ? 0 : Number.POSITIVE_INFINITY;
        results[v3] = { distance: distance2 };
        pq.add(v3, distance2);
      });
      while (pq.size() > 0) {
        v2 = pq.removeMin();
        vEntry = results[v2];
        if (vEntry.distance === Number.POSITIVE_INFINITY) {
          break;
        }
        edgeFn(v2).forEach(updateNeighbors);
      }
      return results;
    }
  }
});

// node_modules/graphlib/lib/alg/dijkstra-all.js
var require_dijkstra_all = __commonJS({
  "node_modules/graphlib/lib/alg/dijkstra-all.js"(exports, module) {
    var dijkstra = require_dijkstra();
    var _2 = require_lodash();
    module.exports = dijkstraAll;
    function dijkstraAll(g2, weightFunc, edgeFunc) {
      return _2.transform(g2.nodes(), function(acc, v2) {
        acc[v2] = dijkstra(g2, v2, weightFunc, edgeFunc);
      }, {});
    }
  }
});

// node_modules/graphlib/lib/alg/tarjan.js
var require_tarjan = __commonJS({
  "node_modules/graphlib/lib/alg/tarjan.js"(exports, module) {
    var _2 = require_lodash();
    module.exports = tarjan;
    function tarjan(g2) {
      var index2 = 0;
      var stack = [];
      var visited = {};
      var results = [];
      function dfs(v2) {
        var entry = visited[v2] = {
          onStack: true,
          lowlink: index2,
          index: index2++
        };
        stack.push(v2);
        g2.successors(v2).forEach(function(w4) {
          if (!_2.has(visited, w4)) {
            dfs(w4);
            entry.lowlink = Math.min(entry.lowlink, visited[w4].lowlink);
          } else if (visited[w4].onStack) {
            entry.lowlink = Math.min(entry.lowlink, visited[w4].index);
          }
        });
        if (entry.lowlink === entry.index) {
          var cmpt = [];
          var w3;
          do {
            w3 = stack.pop();
            visited[w3].onStack = false;
            cmpt.push(w3);
          } while (v2 !== w3);
          results.push(cmpt);
        }
      }
      g2.nodes().forEach(function(v2) {
        if (!_2.has(visited, v2)) {
          dfs(v2);
        }
      });
      return results;
    }
  }
});

// node_modules/graphlib/lib/alg/find-cycles.js
var require_find_cycles = __commonJS({
  "node_modules/graphlib/lib/alg/find-cycles.js"(exports, module) {
    var _2 = require_lodash();
    var tarjan = require_tarjan();
    module.exports = findCycles;
    function findCycles(g2) {
      return _2.filter(tarjan(g2), function(cmpt) {
        return cmpt.length > 1 || cmpt.length === 1 && g2.hasEdge(cmpt[0], cmpt[0]);
      });
    }
  }
});

// node_modules/graphlib/lib/alg/floyd-warshall.js
var require_floyd_warshall = __commonJS({
  "node_modules/graphlib/lib/alg/floyd-warshall.js"(exports, module) {
    var _2 = require_lodash();
    module.exports = floydWarshall;
    var DEFAULT_WEIGHT_FUNC = _2.constant(1);
    function floydWarshall(g2, weightFn, edgeFn) {
      return runFloydWarshall(g2, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function(v2) {
        return g2.outEdges(v2);
      });
    }
    function runFloydWarshall(g2, weightFn, edgeFn) {
      var results = {};
      var nodes = g2.nodes();
      nodes.forEach(function(v2) {
        results[v2] = {};
        results[v2][v2] = { distance: 0 };
        nodes.forEach(function(w3) {
          if (v2 !== w3) {
            results[v2][w3] = { distance: Number.POSITIVE_INFINITY };
          }
        });
        edgeFn(v2).forEach(function(edge) {
          var w3 = edge.v === v2 ? edge.w : edge.v;
          var d2 = weightFn(edge);
          results[v2][w3] = { distance: d2, predecessor: v2 };
        });
      });
      nodes.forEach(function(k4) {
        var rowK = results[k4];
        nodes.forEach(function(i2) {
          var rowI = results[i2];
          nodes.forEach(function(j2) {
            var ik = rowI[k4];
            var kj = rowK[j2];
            var ij = rowI[j2];
            var altDistance = ik.distance + kj.distance;
            if (altDistance < ij.distance) {
              ij.distance = altDistance;
              ij.predecessor = kj.predecessor;
            }
          });
        });
      });
      return results;
    }
  }
});

// node_modules/graphlib/lib/alg/topsort.js
var require_topsort = __commonJS({
  "node_modules/graphlib/lib/alg/topsort.js"(exports, module) {
    var _2 = require_lodash();
    module.exports = topsort;
    topsort.CycleException = CycleException;
    function topsort(g2) {
      var visited = {};
      var stack = {};
      var results = [];
      function visit(node) {
        if (_2.has(stack, node)) {
          throw new CycleException();
        }
        if (!_2.has(visited, node)) {
          stack[node] = true;
          visited[node] = true;
          _2.each(g2.predecessors(node), visit);
          delete stack[node];
          results.push(node);
        }
      }
      _2.each(g2.sinks(), visit);
      if (_2.size(visited) !== g2.nodeCount()) {
        throw new CycleException();
      }
      return results;
    }
    function CycleException() {
    }
    CycleException.prototype = new Error();
  }
});

// node_modules/graphlib/lib/alg/is-acyclic.js
var require_is_acyclic = __commonJS({
  "node_modules/graphlib/lib/alg/is-acyclic.js"(exports, module) {
    var topsort = require_topsort();
    module.exports = isAcyclic;
    function isAcyclic(g2) {
      try {
        topsort(g2);
      } catch (e3) {
        if (e3 instanceof topsort.CycleException) {
          return false;
        }
        throw e3;
      }
      return true;
    }
  }
});

// node_modules/graphlib/lib/alg/dfs.js
var require_dfs = __commonJS({
  "node_modules/graphlib/lib/alg/dfs.js"(exports, module) {
    var _2 = require_lodash();
    module.exports = dfs;
    function dfs(g2, vs, order) {
      if (!_2.isArray(vs)) {
        vs = [vs];
      }
      var navigation = (g2.isDirected() ? g2.successors : g2.neighbors).bind(g2);
      var acc = [];
      var visited = {};
      _2.each(vs, function(v2) {
        if (!g2.hasNode(v2)) {
          throw new Error("Graph does not have node: " + v2);
        }
        doDfs(g2, v2, order === "post", visited, navigation, acc);
      });
      return acc;
    }
    function doDfs(g2, v2, postorder, visited, navigation, acc) {
      if (!_2.has(visited, v2)) {
        visited[v2] = true;
        if (!postorder) {
          acc.push(v2);
        }
        _2.each(navigation(v2), function(w3) {
          doDfs(g2, w3, postorder, visited, navigation, acc);
        });
        if (postorder) {
          acc.push(v2);
        }
      }
    }
  }
});

// node_modules/graphlib/lib/alg/postorder.js
var require_postorder = __commonJS({
  "node_modules/graphlib/lib/alg/postorder.js"(exports, module) {
    var dfs = require_dfs();
    module.exports = postorder;
    function postorder(g2, vs) {
      return dfs(g2, vs, "post");
    }
  }
});

// node_modules/graphlib/lib/alg/preorder.js
var require_preorder = __commonJS({
  "node_modules/graphlib/lib/alg/preorder.js"(exports, module) {
    var dfs = require_dfs();
    module.exports = preorder;
    function preorder(g2, vs) {
      return dfs(g2, vs, "pre");
    }
  }
});

// node_modules/graphlib/lib/alg/prim.js
var require_prim = __commonJS({
  "node_modules/graphlib/lib/alg/prim.js"(exports, module) {
    var _2 = require_lodash();
    var Graph = require_graph2();
    var PriorityQueue = require_priority_queue();
    module.exports = prim;
    function prim(g2, weightFunc) {
      var result = new Graph();
      var parents = {};
      var pq = new PriorityQueue();
      var v2;
      function updateNeighbors(edge) {
        var w3 = edge.v === v2 ? edge.w : edge.v;
        var pri = pq.priority(w3);
        if (pri !== void 0) {
          var edgeWeight = weightFunc(edge);
          if (edgeWeight < pri) {
            parents[w3] = v2;
            pq.decrease(w3, edgeWeight);
          }
        }
      }
      if (g2.nodeCount() === 0) {
        return result;
      }
      _2.each(g2.nodes(), function(v3) {
        pq.add(v3, Number.POSITIVE_INFINITY);
        result.setNode(v3);
      });
      pq.decrease(g2.nodes()[0], 0);
      var init = false;
      while (pq.size() > 0) {
        v2 = pq.removeMin();
        if (_2.has(parents, v2)) {
          result.setEdge(v2, parents[v2]);
        } else if (init) {
          throw new Error("Input graph is not connected: " + g2);
        } else {
          init = true;
        }
        g2.nodeEdges(v2).forEach(updateNeighbors);
      }
      return result;
    }
  }
});

// node_modules/graphlib/lib/alg/index.js
var require_alg = __commonJS({
  "node_modules/graphlib/lib/alg/index.js"(exports, module) {
    module.exports = {
      components: require_components(),
      dijkstra: require_dijkstra(),
      dijkstraAll: require_dijkstra_all(),
      findCycles: require_find_cycles(),
      floydWarshall: require_floyd_warshall(),
      isAcyclic: require_is_acyclic(),
      postorder: require_postorder(),
      preorder: require_preorder(),
      prim: require_prim(),
      tarjan: require_tarjan(),
      topsort: require_topsort()
    };
  }
});

// node_modules/graphlib/index.js
var require_graphlib = __commonJS({
  "node_modules/graphlib/index.js"(exports, module) {
    var lib = require_lib();
    module.exports = {
      Graph: lib.Graph,
      json: require_json(),
      alg: require_alg(),
      version: lib.version
    };
  }
});

// node_modules/dagre/lib/graphlib.js
var require_graphlib2 = __commonJS({
  "node_modules/dagre/lib/graphlib.js"(exports, module) {
    var graphlib;
    if (typeof __require === "function") {
      try {
        graphlib = require_graphlib();
      } catch (e3) {
      }
    }
    if (!graphlib) {
      graphlib = window.graphlib;
    }
    module.exports = graphlib;
  }
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/lodash/defaults.js"(exports, module) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object3, sources) {
      object3 = Object(object3);
      var index2 = -1;
      var length2 = sources.length;
      var guard = length2 > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length2 = 1;
      }
      while (++index2 < length2) {
        var source = sources[index2];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value2 = object3[key];
          if (value2 === void 0 || eq(value2, objectProto[key]) && !hasOwnProperty.call(object3, key)) {
            object3[key] = source[key];
          }
        }
      }
      return object3;
    });
    module.exports = defaults;
  }
});

// node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
  "node_modules/lodash/_createFind.js"(exports, module) {
    var baseIteratee = require_baseIteratee();
    var isArrayLike = require_isArrayLike();
    var keys = require_keys();
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index2 = findIndexFunc(collection, predicate, fromIndex);
        return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
      };
    }
    module.exports = createFind;
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports, module) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value2) {
      if (!value2) {
        return value2 === 0 ? value2 : 0;
      }
      value2 = toNumber(value2);
      if (value2 === INFINITY || value2 === -INFINITY) {
        var sign6 = value2 < 0 ? -1 : 1;
        return sign6 * MAX_INTEGER;
      }
      return value2 === value2 ? value2 : 0;
    }
    module.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports, module) {
    var toFinite = require_toFinite();
    function toInteger(value2) {
      var result = toFinite(value2), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module.exports = toInteger;
  }
});

// node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/lodash/findIndex.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIteratee = require_baseIteratee();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function findIndex(array3, predicate, fromIndex) {
      var length2 = array3 == null ? 0 : array3.length;
      if (!length2) {
        return -1;
      }
      var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index2 < 0) {
        index2 = nativeMax(length2 + index2, 0);
      }
      return baseFindIndex(array3, baseIteratee(predicate, 3), index2);
    }
    module.exports = findIndex;
  }
});

// node_modules/lodash/find.js
var require_find = __commonJS({
  "node_modules/lodash/find.js"(exports, module) {
    var createFind = require_createFind();
    var findIndex = require_findIndex();
    var find2 = createFind(findIndex);
    module.exports = find2;
  }
});

// node_modules/lodash/forIn.js
var require_forIn = __commonJS({
  "node_modules/lodash/forIn.js"(exports, module) {
    var baseFor = require_baseFor();
    var castFunction = require_castFunction();
    var keysIn = require_keysIn();
    function forIn(object3, iteratee) {
      return object3 == null ? object3 : baseFor(object3, castFunction(iteratee), keysIn);
    }
    module.exports = forIn;
  }
});

// node_modules/lodash/mapValues.js
var require_mapValues = __commonJS({
  "node_modules/lodash/mapValues.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    function mapValues(object3, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);
      baseForOwn(object3, function(value2, key, object4) {
        baseAssignValue(result, key, iteratee(value2, key, object4));
      });
      return result;
    }
    module.exports = mapValues;
  }
});

// node_modules/lodash/_baseExtremum.js
var require_baseExtremum = __commonJS({
  "node_modules/lodash/_baseExtremum.js"(exports, module) {
    var isSymbol = require_isSymbol();
    function baseExtremum(array3, iteratee, comparator) {
      var index2 = -1, length2 = array3.length;
      while (++index2 < length2) {
        var value2 = array3[index2], current = iteratee(value2);
        if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
          var computed = current, result = value2;
        }
      }
      return result;
    }
    module.exports = baseExtremum;
  }
});

// node_modules/lodash/_baseGt.js
var require_baseGt = __commonJS({
  "node_modules/lodash/_baseGt.js"(exports, module) {
    function baseGt(value2, other) {
      return value2 > other;
    }
    module.exports = baseGt;
  }
});

// node_modules/lodash/max.js
var require_max = __commonJS({
  "node_modules/lodash/max.js"(exports, module) {
    var baseExtremum = require_baseExtremum();
    var baseGt = require_baseGt();
    var identity = require_identity();
    function max4(array3) {
      return array3 && array3.length ? baseExtremum(array3, identity, baseGt) : void 0;
    }
    module.exports = max4;
  }
});

// node_modules/lodash/_baseLt.js
var require_baseLt = __commonJS({
  "node_modules/lodash/_baseLt.js"(exports, module) {
    function baseLt(value2, other) {
      return value2 < other;
    }
    module.exports = baseLt;
  }
});

// node_modules/lodash/min.js
var require_min = __commonJS({
  "node_modules/lodash/min.js"(exports, module) {
    var baseExtremum = require_baseExtremum();
    var baseLt = require_baseLt();
    var identity = require_identity();
    function min4(array3) {
      return array3 && array3.length ? baseExtremum(array3, identity, baseLt) : void 0;
    }
    module.exports = min4;
  }
});

// node_modules/lodash/minBy.js
var require_minBy = __commonJS({
  "node_modules/lodash/minBy.js"(exports, module) {
    var baseExtremum = require_baseExtremum();
    var baseIteratee = require_baseIteratee();
    var baseLt = require_baseLt();
    function minBy(array3, iteratee) {
      return array3 && array3.length ? baseExtremum(array3, baseIteratee(iteratee, 2), baseLt) : void 0;
    }
    module.exports = minBy;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports, module) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object3, paths, predicate) {
      var index2 = -1, length2 = paths.length, result = {};
      while (++index2 < length2) {
        var path3 = paths[index2], value2 = baseGet(object3, path3);
        if (predicate(value2, path3)) {
          baseSet(result, castPath(path3, object3), value2);
        }
      }
      return result;
    }
    module.exports = basePickBy;
  }
});

// node_modules/lodash/_basePick.js
var require_basePick = __commonJS({
  "node_modules/lodash/_basePick.js"(exports, module) {
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object3, paths) {
      return basePickBy(object3, paths, function(value2, path3) {
        return hasIn(object3, path3);
      });
    }
    module.exports = basePick;
  }
});

// node_modules/lodash/pick.js
var require_pick2 = __commonJS({
  "node_modules/lodash/pick.js"(exports, module) {
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick = flatRest(function(object3, paths) {
      return object3 == null ? {} : basePick(object3, paths);
    });
    module.exports = pick;
  }
});

// node_modules/lodash/_baseRange.js
var require_baseRange = __commonJS({
  "node_modules/lodash/_baseRange.js"(exports, module) {
    var nativeCeil = Math.ceil;
    var nativeMax = Math.max;
    function baseRange(start, end, step, fromRight) {
      var index2 = -1, length2 = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length2);
      while (length2--) {
        result[fromRight ? length2 : ++index2] = start;
        start += step;
      }
      return result;
    }
    module.exports = baseRange;
  }
});

// node_modules/lodash/_createRange.js
var require_createRange = __commonJS({
  "node_modules/lodash/_createRange.js"(exports, module) {
    var baseRange = require_baseRange();
    var isIterateeCall = require_isIterateeCall();
    var toFinite = require_toFinite();
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
          end = step = void 0;
        }
        start = toFinite(start);
        if (end === void 0) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }
    module.exports = createRange;
  }
});

// node_modules/lodash/range.js
var require_range = __commonJS({
  "node_modules/lodash/range.js"(exports, module) {
    var createRange = require_createRange();
    var range3 = createRange();
    module.exports = range3;
  }
});

// node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "node_modules/lodash/_baseSortBy.js"(exports, module) {
    function baseSortBy(array3, comparer) {
      var length2 = array3.length;
      array3.sort(comparer);
      while (length2--) {
        array3[length2] = array3[length2].value;
      }
      return array3;
    }
    module.exports = baseSortBy;
  }
});

// node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "node_modules/lodash/_compareAscending.js"(exports, module) {
    var isSymbol = require_isSymbol();
    function compareAscending(value2, other) {
      if (value2 !== other) {
        var valIsDefined = value2 !== void 0, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol(value2);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module.exports = compareAscending;
  }
});

// node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "node_modules/lodash/_compareMultiple.js"(exports, module) {
    var compareAscending = require_compareAscending();
    function compareMultiple(object3, other, orders) {
      var index2 = -1, objCriteria = object3.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
      while (++index2 < length2) {
        var result = compareAscending(objCriteria[index2], othCriteria[index2]);
        if (result) {
          if (index2 >= ordersLength) {
            return result;
          }
          var order = orders[index2];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object3.index - other.index;
    }
    module.exports = compareMultiple;
  }
});

// node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "node_modules/lodash/_baseOrderBy.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value2) {
              return baseGet(value2, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index2 = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value2, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value2);
        });
        return { "criteria": criteria, "index": ++index2, "value": value2 };
      });
      return baseSortBy(result, function(object3, other) {
        return compareMultiple(object3, other, orders);
      });
    }
    module.exports = baseOrderBy;
  }
});

// node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/lodash/sortBy.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length2 = iteratees.length;
      if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module.exports = sortBy;
  }
});

// node_modules/lodash/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/lodash/uniqueId.js"(exports, module) {
    var toString = require_toString();
    var idCounter = 0;
    function uniqueId(prefix2) {
      var id = ++idCounter;
      return toString(prefix2) + id;
    }
    module.exports = uniqueId;
  }
});

// node_modules/lodash/_baseZipObject.js
var require_baseZipObject = __commonJS({
  "node_modules/lodash/_baseZipObject.js"(exports, module) {
    function baseZipObject(props, values, assignFunc) {
      var index2 = -1, length2 = props.length, valsLength = values.length, result = {};
      while (++index2 < length2) {
        var value2 = index2 < valsLength ? values[index2] : void 0;
        assignFunc(result, props[index2], value2);
      }
      return result;
    }
    module.exports = baseZipObject;
  }
});

// node_modules/lodash/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/lodash/zipObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseZipObject = require_baseZipObject();
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }
    module.exports = zipObject;
  }
});

// node_modules/dagre/lib/lodash.js
var require_lodash2 = __commonJS({
  "node_modules/dagre/lib/lodash.js"(exports, module) {
    var lodash;
    if (typeof __require === "function") {
      try {
        lodash = {
          cloneDeep: require_cloneDeep(),
          constant: require_constant(),
          defaults: require_defaults(),
          each: require_each(),
          filter: require_filter2(),
          find: require_find(),
          flatten: require_flatten(),
          forEach: require_forEach(),
          forIn: require_forIn(),
          has: require_has(),
          isUndefined: require_isUndefined(),
          last: require_last(),
          map: require_map(),
          mapValues: require_mapValues(),
          max: require_max(),
          merge: require_merge(),
          min: require_min(),
          minBy: require_minBy(),
          now: require_now(),
          pick: require_pick2(),
          range: require_range(),
          reduce: require_reduce(),
          sortBy: require_sortBy(),
          uniqueId: require_uniqueId(),
          values: require_values(),
          zipObject: require_zipObject()
        };
      } catch (e3) {
      }
    }
    if (!lodash) {
      lodash = window._;
    }
    module.exports = lodash;
  }
});

// node_modules/dagre/lib/data/list.js
var require_list = __commonJS({
  "node_modules/dagre/lib/data/list.js"(exports, module) {
    module.exports = List;
    function List() {
      var sentinel = {};
      sentinel._next = sentinel._prev = sentinel;
      this._sentinel = sentinel;
    }
    List.prototype.dequeue = function() {
      var sentinel = this._sentinel;
      var entry = sentinel._prev;
      if (entry !== sentinel) {
        unlink(entry);
        return entry;
      }
    };
    List.prototype.enqueue = function(entry) {
      var sentinel = this._sentinel;
      if (entry._prev && entry._next) {
        unlink(entry);
      }
      entry._next = sentinel._next;
      sentinel._next._prev = entry;
      sentinel._next = entry;
      entry._prev = sentinel;
    };
    List.prototype.toString = function() {
      var strs = [];
      var sentinel = this._sentinel;
      var curr = sentinel._prev;
      while (curr !== sentinel) {
        strs.push(JSON.stringify(curr, filterOutLinks));
        curr = curr._prev;
      }
      return "[" + strs.join(", ") + "]";
    };
    function unlink(entry) {
      entry._prev._next = entry._next;
      entry._next._prev = entry._prev;
      delete entry._next;
      delete entry._prev;
    }
    function filterOutLinks(k4, v2) {
      if (k4 !== "_next" && k4 !== "_prev") {
        return v2;
      }
    }
  }
});

// node_modules/dagre/lib/greedy-fas.js
var require_greedy_fas = __commonJS({
  "node_modules/dagre/lib/greedy-fas.js"(exports, module) {
    var _2 = require_lodash2();
    var Graph = require_graphlib2().Graph;
    var List = require_list();
    module.exports = greedyFAS;
    var DEFAULT_WEIGHT_FN = _2.constant(1);
    function greedyFAS(g2, weightFn) {
      if (g2.nodeCount() <= 1) {
        return [];
      }
      var state = buildState(g2, weightFn || DEFAULT_WEIGHT_FN);
      var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
      return _2.flatten(_2.map(results, function(e3) {
        return g2.outEdges(e3.v, e3.w);
      }), true);
    }
    function doGreedyFAS(g2, buckets, zeroIdx) {
      var results = [];
      var sources = buckets[buckets.length - 1];
      var sinks = buckets[0];
      var entry;
      while (g2.nodeCount()) {
        while (entry = sinks.dequeue()) {
          removeNode(g2, buckets, zeroIdx, entry);
        }
        while (entry = sources.dequeue()) {
          removeNode(g2, buckets, zeroIdx, entry);
        }
        if (g2.nodeCount()) {
          for (var i2 = buckets.length - 2; i2 > 0; --i2) {
            entry = buckets[i2].dequeue();
            if (entry) {
              results = results.concat(removeNode(g2, buckets, zeroIdx, entry, true));
              break;
            }
          }
        }
      }
      return results;
    }
    function removeNode(g2, buckets, zeroIdx, entry, collectPredecessors) {
      var results = collectPredecessors ? [] : void 0;
      _2.forEach(g2.inEdges(entry.v), function(edge) {
        var weight = g2.edge(edge);
        var uEntry = g2.node(edge.v);
        if (collectPredecessors) {
          results.push({ v: edge.v, w: edge.w });
        }
        uEntry.out -= weight;
        assignBucket(buckets, zeroIdx, uEntry);
      });
      _2.forEach(g2.outEdges(entry.v), function(edge) {
        var weight = g2.edge(edge);
        var w3 = edge.w;
        var wEntry = g2.node(w3);
        wEntry["in"] -= weight;
        assignBucket(buckets, zeroIdx, wEntry);
      });
      g2.removeNode(entry.v);
      return results;
    }
    function buildState(g2, weightFn) {
      var fasGraph = new Graph();
      var maxIn = 0;
      var maxOut = 0;
      _2.forEach(g2.nodes(), function(v2) {
        fasGraph.setNode(v2, { v: v2, "in": 0, out: 0 });
      });
      _2.forEach(g2.edges(), function(e3) {
        var prevWeight = fasGraph.edge(e3.v, e3.w) || 0;
        var weight = weightFn(e3);
        var edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e3.v, e3.w, edgeWeight);
        maxOut = Math.max(maxOut, fasGraph.node(e3.v).out += weight);
        maxIn = Math.max(maxIn, fasGraph.node(e3.w)["in"] += weight);
      });
      var buckets = _2.range(maxOut + maxIn + 3).map(function() {
        return new List();
      });
      var zeroIdx = maxIn + 1;
      _2.forEach(fasGraph.nodes(), function(v2) {
        assignBucket(buckets, zeroIdx, fasGraph.node(v2));
      });
      return { graph: fasGraph, buckets, zeroIdx };
    }
    function assignBucket(buckets, zeroIdx, entry) {
      if (!entry.out) {
        buckets[0].enqueue(entry);
      } else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
      } else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
      }
    }
  }
});

// node_modules/dagre/lib/acyclic.js
var require_acyclic = __commonJS({
  "node_modules/dagre/lib/acyclic.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    var greedyFAS = require_greedy_fas();
    module.exports = {
      run,
      undo
    };
    function run(g2) {
      var fas = g2.graph().acyclicer === "greedy" ? greedyFAS(g2, weightFn(g2)) : dfsFAS(g2);
      _2.forEach(fas, function(e3) {
        var label = g2.edge(e3);
        g2.removeEdge(e3);
        label.forwardName = e3.name;
        label.reversed = true;
        g2.setEdge(e3.w, e3.v, label, _2.uniqueId("rev"));
      });
      function weightFn(g3) {
        return function(e3) {
          return g3.edge(e3).weight;
        };
      }
    }
    function dfsFAS(g2) {
      var fas = [];
      var stack = {};
      var visited = {};
      function dfs(v2) {
        if (_2.has(visited, v2)) {
          return;
        }
        visited[v2] = true;
        stack[v2] = true;
        _2.forEach(g2.outEdges(v2), function(e3) {
          if (_2.has(stack, e3.w)) {
            fas.push(e3);
          } else {
            dfs(e3.w);
          }
        });
        delete stack[v2];
      }
      _2.forEach(g2.nodes(), dfs);
      return fas;
    }
    function undo(g2) {
      _2.forEach(g2.edges(), function(e3) {
        var label = g2.edge(e3);
        if (label.reversed) {
          g2.removeEdge(e3);
          var forwardName = label.forwardName;
          delete label.reversed;
          delete label.forwardName;
          g2.setEdge(e3.w, e3.v, label, forwardName);
        }
      });
    }
  }
});

// node_modules/dagre/lib/util.js
var require_util = __commonJS({
  "node_modules/dagre/lib/util.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    var Graph = require_graphlib2().Graph;
    module.exports = {
      addDummyNode,
      simplify,
      asNonCompoundGraph,
      successorWeights,
      predecessorWeights,
      intersectRect,
      buildLayerMatrix,
      normalizeRanks,
      removeEmptyRanks,
      addBorderNode,
      maxRank,
      partition,
      time,
      notime
    };
    function addDummyNode(g2, type, attrs, name) {
      var v2;
      do {
        v2 = _2.uniqueId(name);
      } while (g2.hasNode(v2));
      attrs.dummy = type;
      g2.setNode(v2, attrs);
      return v2;
    }
    function simplify(g2) {
      var simplified = new Graph().setGraph(g2.graph());
      _2.forEach(g2.nodes(), function(v2) {
        simplified.setNode(v2, g2.node(v2));
      });
      _2.forEach(g2.edges(), function(e3) {
        var simpleLabel = simplified.edge(e3.v, e3.w) || { weight: 0, minlen: 1 };
        var label = g2.edge(e3);
        simplified.setEdge(e3.v, e3.w, {
          weight: simpleLabel.weight + label.weight,
          minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
      });
      return simplified;
    }
    function asNonCompoundGraph(g2) {
      var simplified = new Graph({ multigraph: g2.isMultigraph() }).setGraph(g2.graph());
      _2.forEach(g2.nodes(), function(v2) {
        if (!g2.children(v2).length) {
          simplified.setNode(v2, g2.node(v2));
        }
      });
      _2.forEach(g2.edges(), function(e3) {
        simplified.setEdge(e3, g2.edge(e3));
      });
      return simplified;
    }
    function successorWeights(g2) {
      var weightMap = _2.map(g2.nodes(), function(v2) {
        var sucs = {};
        _2.forEach(g2.outEdges(v2), function(e3) {
          sucs[e3.w] = (sucs[e3.w] || 0) + g2.edge(e3).weight;
        });
        return sucs;
      });
      return _2.zipObject(g2.nodes(), weightMap);
    }
    function predecessorWeights(g2) {
      var weightMap = _2.map(g2.nodes(), function(v2) {
        var preds = {};
        _2.forEach(g2.inEdges(v2), function(e3) {
          preds[e3.v] = (preds[e3.v] || 0) + g2.edge(e3).weight;
        });
        return preds;
      });
      return _2.zipObject(g2.nodes(), weightMap);
    }
    function intersectRect(rect, point5) {
      var x4 = rect.x;
      var y4 = rect.y;
      var dx = point5.x - x4;
      var dy = point5.y - y4;
      var w3 = rect.width / 2;
      var h2 = rect.height / 2;
      if (!dx && !dy) {
        throw new Error("Not possible to find intersection inside of the rectangle");
      }
      var sx, sy;
      if (Math.abs(dy) * w3 > Math.abs(dx) * h2) {
        if (dy < 0) {
          h2 = -h2;
        }
        sx = h2 * dx / dy;
        sy = h2;
      } else {
        if (dx < 0) {
          w3 = -w3;
        }
        sx = w3;
        sy = w3 * dy / dx;
      }
      return { x: x4 + sx, y: y4 + sy };
    }
    function buildLayerMatrix(g2) {
      var layering = _2.map(_2.range(maxRank(g2) + 1), function() {
        return [];
      });
      _2.forEach(g2.nodes(), function(v2) {
        var node = g2.node(v2);
        var rank = node.rank;
        if (!_2.isUndefined(rank)) {
          layering[rank][node.order] = v2;
        }
      });
      return layering;
    }
    function normalizeRanks(g2) {
      var min4 = _2.min(_2.map(g2.nodes(), function(v2) {
        return g2.node(v2).rank;
      }));
      _2.forEach(g2.nodes(), function(v2) {
        var node = g2.node(v2);
        if (_2.has(node, "rank")) {
          node.rank -= min4;
        }
      });
    }
    function removeEmptyRanks(g2) {
      var offset = _2.min(_2.map(g2.nodes(), function(v2) {
        return g2.node(v2).rank;
      }));
      var layers = [];
      _2.forEach(g2.nodes(), function(v2) {
        var rank = g2.node(v2).rank - offset;
        if (!layers[rank]) {
          layers[rank] = [];
        }
        layers[rank].push(v2);
      });
      var delta = 0;
      var nodeRankFactor = g2.graph().nodeRankFactor;
      _2.forEach(layers, function(vs, i2) {
        if (_2.isUndefined(vs) && i2 % nodeRankFactor !== 0) {
          --delta;
        } else if (delta) {
          _2.forEach(vs, function(v2) {
            g2.node(v2).rank += delta;
          });
        }
      });
    }
    function addBorderNode(g2, prefix2, rank, order) {
      var node = {
        width: 0,
        height: 0
      };
      if (arguments.length >= 4) {
        node.rank = rank;
        node.order = order;
      }
      return addDummyNode(g2, "border", node, prefix2);
    }
    function maxRank(g2) {
      return _2.max(_2.map(g2.nodes(), function(v2) {
        var rank = g2.node(v2).rank;
        if (!_2.isUndefined(rank)) {
          return rank;
        }
      }));
    }
    function partition(collection, fn) {
      var result = { lhs: [], rhs: [] };
      _2.forEach(collection, function(value2) {
        if (fn(value2)) {
          result.lhs.push(value2);
        } else {
          result.rhs.push(value2);
        }
      });
      return result;
    }
    function time(name, fn) {
      var start = _2.now();
      try {
        return fn();
      } finally {
        console.log(name + " time: " + (_2.now() - start) + "ms");
      }
    }
    function notime(name, fn) {
      return fn();
    }
  }
});

// node_modules/dagre/lib/normalize.js
var require_normalize = __commonJS({
  "node_modules/dagre/lib/normalize.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    var util = require_util();
    module.exports = {
      run,
      undo
    };
    function run(g2) {
      g2.graph().dummyChains = [];
      _2.forEach(g2.edges(), function(edge) {
        normalizeEdge(g2, edge);
      });
    }
    function normalizeEdge(g2, e3) {
      var v2 = e3.v;
      var vRank = g2.node(v2).rank;
      var w3 = e3.w;
      var wRank = g2.node(w3).rank;
      var name = e3.name;
      var edgeLabel = g2.edge(e3);
      var labelRank = edgeLabel.labelRank;
      if (wRank === vRank + 1)
        return;
      g2.removeEdge(e3);
      var dummy, attrs, i2;
      for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank) {
        edgeLabel.points = [];
        attrs = {
          width: 0,
          height: 0,
          edgeLabel,
          edgeObj: e3,
          rank: vRank
        };
        dummy = util.addDummyNode(g2, "edge", attrs, "_d");
        if (vRank === labelRank) {
          attrs.width = edgeLabel.width;
          attrs.height = edgeLabel.height;
          attrs.dummy = "edge-label";
          attrs.labelpos = edgeLabel.labelpos;
        }
        g2.setEdge(v2, dummy, { weight: edgeLabel.weight }, name);
        if (i2 === 0) {
          g2.graph().dummyChains.push(dummy);
        }
        v2 = dummy;
      }
      g2.setEdge(v2, w3, { weight: edgeLabel.weight }, name);
    }
    function undo(g2) {
      _2.forEach(g2.graph().dummyChains, function(v2) {
        var node = g2.node(v2);
        var origLabel = node.edgeLabel;
        var w3;
        g2.setEdge(node.edgeObj, origLabel);
        while (node.dummy) {
          w3 = g2.successors(v2)[0];
          g2.removeNode(v2);
          origLabel.points.push({ x: node.x, y: node.y });
          if (node.dummy === "edge-label") {
            origLabel.x = node.x;
            origLabel.y = node.y;
            origLabel.width = node.width;
            origLabel.height = node.height;
          }
          v2 = w3;
          node = g2.node(v2);
        }
      });
    }
  }
});

// node_modules/dagre/lib/rank/util.js
var require_util2 = __commonJS({
  "node_modules/dagre/lib/rank/util.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    module.exports = {
      longestPath,
      slack
    };
    function longestPath(g2) {
      var visited = {};
      function dfs(v2) {
        var label = g2.node(v2);
        if (_2.has(visited, v2)) {
          return label.rank;
        }
        visited[v2] = true;
        var rank = _2.min(_2.map(g2.outEdges(v2), function(e3) {
          return dfs(e3.w) - g2.edge(e3).minlen;
        }));
        if (rank === Number.POSITIVE_INFINITY || rank === void 0 || rank === null) {
          rank = 0;
        }
        return label.rank = rank;
      }
      _2.forEach(g2.sources(), dfs);
    }
    function slack(g2, e3) {
      return g2.node(e3.w).rank - g2.node(e3.v).rank - g2.edge(e3).minlen;
    }
  }
});

// node_modules/dagre/lib/rank/feasible-tree.js
var require_feasible_tree = __commonJS({
  "node_modules/dagre/lib/rank/feasible-tree.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    var Graph = require_graphlib2().Graph;
    var slack = require_util2().slack;
    module.exports = feasibleTree;
    function feasibleTree(g2) {
      var t2 = new Graph({ directed: false });
      var start = g2.nodes()[0];
      var size = g2.nodeCount();
      t2.setNode(start, {});
      var edge, delta;
      while (tightTree(t2, g2) < size) {
        edge = findMinSlackEdge(t2, g2);
        delta = t2.hasNode(edge.v) ? slack(g2, edge) : -slack(g2, edge);
        shiftRanks(t2, g2, delta);
      }
      return t2;
    }
    function tightTree(t2, g2) {
      function dfs(v2) {
        _2.forEach(g2.nodeEdges(v2), function(e3) {
          var edgeV = e3.v, w3 = v2 === edgeV ? e3.w : edgeV;
          if (!t2.hasNode(w3) && !slack(g2, e3)) {
            t2.setNode(w3, {});
            t2.setEdge(v2, w3, {});
            dfs(w3);
          }
        });
      }
      _2.forEach(t2.nodes(), dfs);
      return t2.nodeCount();
    }
    function findMinSlackEdge(t2, g2) {
      return _2.minBy(g2.edges(), function(e3) {
        if (t2.hasNode(e3.v) !== t2.hasNode(e3.w)) {
          return slack(g2, e3);
        }
      });
    }
    function shiftRanks(t2, g2, delta) {
      _2.forEach(t2.nodes(), function(v2) {
        g2.node(v2).rank += delta;
      });
    }
  }
});

// node_modules/dagre/lib/rank/network-simplex.js
var require_network_simplex = __commonJS({
  "node_modules/dagre/lib/rank/network-simplex.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    var feasibleTree = require_feasible_tree();
    var slack = require_util2().slack;
    var initRank = require_util2().longestPath;
    var preorder = require_graphlib2().alg.preorder;
    var postorder = require_graphlib2().alg.postorder;
    var simplify = require_util().simplify;
    module.exports = networkSimplex;
    networkSimplex.initLowLimValues = initLowLimValues;
    networkSimplex.initCutValues = initCutValues;
    networkSimplex.calcCutValue = calcCutValue;
    networkSimplex.leaveEdge = leaveEdge;
    networkSimplex.enterEdge = enterEdge;
    networkSimplex.exchangeEdges = exchangeEdges;
    function networkSimplex(g2) {
      g2 = simplify(g2);
      initRank(g2);
      var t2 = feasibleTree(g2);
      initLowLimValues(t2);
      initCutValues(t2, g2);
      var e3, f2;
      while (e3 = leaveEdge(t2)) {
        f2 = enterEdge(t2, g2, e3);
        exchangeEdges(t2, g2, e3, f2);
      }
    }
    function initCutValues(t2, g2) {
      var vs = postorder(t2, t2.nodes());
      vs = vs.slice(0, vs.length - 1);
      _2.forEach(vs, function(v2) {
        assignCutValue(t2, g2, v2);
      });
    }
    function assignCutValue(t2, g2, child) {
      var childLab = t2.node(child);
      var parent = childLab.parent;
      t2.edge(child, parent).cutvalue = calcCutValue(t2, g2, child);
    }
    function calcCutValue(t2, g2, child) {
      var childLab = t2.node(child);
      var parent = childLab.parent;
      var childIsTail = true;
      var graphEdge = g2.edge(child, parent);
      var cutValue = 0;
      if (!graphEdge) {
        childIsTail = false;
        graphEdge = g2.edge(parent, child);
      }
      cutValue = graphEdge.weight;
      _2.forEach(g2.nodeEdges(child), function(e3) {
        var isOutEdge = e3.v === child, other = isOutEdge ? e3.w : e3.v;
        if (other !== parent) {
          var pointsToHead = isOutEdge === childIsTail, otherWeight = g2.edge(e3).weight;
          cutValue += pointsToHead ? otherWeight : -otherWeight;
          if (isTreeEdge(t2, child, other)) {
            var otherCutValue = t2.edge(child, other).cutvalue;
            cutValue += pointsToHead ? -otherCutValue : otherCutValue;
          }
        }
      });
      return cutValue;
    }
    function initLowLimValues(tree, root) {
      if (arguments.length < 2) {
        root = tree.nodes()[0];
      }
      dfsAssignLowLim(tree, {}, 1, root);
    }
    function dfsAssignLowLim(tree, visited, nextLim, v2, parent) {
      var low = nextLim;
      var label = tree.node(v2);
      visited[v2] = true;
      _2.forEach(tree.neighbors(v2), function(w3) {
        if (!_2.has(visited, w3)) {
          nextLim = dfsAssignLowLim(tree, visited, nextLim, w3, v2);
        }
      });
      label.low = low;
      label.lim = nextLim++;
      if (parent) {
        label.parent = parent;
      } else {
        delete label.parent;
      }
      return nextLim;
    }
    function leaveEdge(tree) {
      return _2.find(tree.edges(), function(e3) {
        return tree.edge(e3).cutvalue < 0;
      });
    }
    function enterEdge(t2, g2, edge) {
      var v2 = edge.v;
      var w3 = edge.w;
      if (!g2.hasEdge(v2, w3)) {
        v2 = edge.w;
        w3 = edge.v;
      }
      var vLabel = t2.node(v2);
      var wLabel = t2.node(w3);
      var tailLabel = vLabel;
      var flip = false;
      if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip = true;
      }
      var candidates = _2.filter(g2.edges(), function(edge2) {
        return flip === isDescendant(t2, t2.node(edge2.v), tailLabel) && flip !== isDescendant(t2, t2.node(edge2.w), tailLabel);
      });
      return _2.minBy(candidates, function(edge2) {
        return slack(g2, edge2);
      });
    }
    function exchangeEdges(t2, g2, e3, f2) {
      var v2 = e3.v;
      var w3 = e3.w;
      t2.removeEdge(v2, w3);
      t2.setEdge(f2.v, f2.w, {});
      initLowLimValues(t2);
      initCutValues(t2, g2);
      updateRanks(t2, g2);
    }
    function updateRanks(t2, g2) {
      var root = _2.find(t2.nodes(), function(v2) {
        return !g2.node(v2).parent;
      });
      var vs = preorder(t2, root);
      vs = vs.slice(1);
      _2.forEach(vs, function(v2) {
        var parent = t2.node(v2).parent, edge = g2.edge(v2, parent), flipped = false;
        if (!edge) {
          edge = g2.edge(parent, v2);
          flipped = true;
        }
        g2.node(v2).rank = g2.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
      });
    }
    function isTreeEdge(tree, u2, v2) {
      return tree.hasEdge(u2, v2);
    }
    function isDescendant(tree, vLabel, rootLabel) {
      return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
    }
  }
});

// node_modules/dagre/lib/rank/index.js
var require_rank = __commonJS({
  "node_modules/dagre/lib/rank/index.js"(exports, module) {
    "use strict";
    var rankUtil = require_util2();
    var longestPath = rankUtil.longestPath;
    var feasibleTree = require_feasible_tree();
    var networkSimplex = require_network_simplex();
    module.exports = rank;
    function rank(g2) {
      switch (g2.graph().ranker) {
        case "network-simplex":
          networkSimplexRanker(g2);
          break;
        case "tight-tree":
          tightTreeRanker(g2);
          break;
        case "longest-path":
          longestPathRanker(g2);
          break;
        default:
          networkSimplexRanker(g2);
      }
    }
    var longestPathRanker = longestPath;
    function tightTreeRanker(g2) {
      longestPath(g2);
      feasibleTree(g2);
    }
    function networkSimplexRanker(g2) {
      networkSimplex(g2);
    }
  }
});

// node_modules/dagre/lib/parent-dummy-chains.js
var require_parent_dummy_chains = __commonJS({
  "node_modules/dagre/lib/parent-dummy-chains.js"(exports, module) {
    var _2 = require_lodash2();
    module.exports = parentDummyChains;
    function parentDummyChains(g2) {
      var postorderNums = postorder(g2);
      _2.forEach(g2.graph().dummyChains, function(v2) {
        var node = g2.node(v2);
        var edgeObj = node.edgeObj;
        var pathData = findPath(g2, postorderNums, edgeObj.v, edgeObj.w);
        var path3 = pathData.path;
        var lca = pathData.lca;
        var pathIdx = 0;
        var pathV = path3[pathIdx];
        var ascending = true;
        while (v2 !== edgeObj.w) {
          node = g2.node(v2);
          if (ascending) {
            while ((pathV = path3[pathIdx]) !== lca && g2.node(pathV).maxRank < node.rank) {
              pathIdx++;
            }
            if (pathV === lca) {
              ascending = false;
            }
          }
          if (!ascending) {
            while (pathIdx < path3.length - 1 && g2.node(pathV = path3[pathIdx + 1]).minRank <= node.rank) {
              pathIdx++;
            }
            pathV = path3[pathIdx];
          }
          g2.setParent(v2, pathV);
          v2 = g2.successors(v2)[0];
        }
      });
    }
    function findPath(g2, postorderNums, v2, w3) {
      var vPath = [];
      var wPath = [];
      var low = Math.min(postorderNums[v2].low, postorderNums[w3].low);
      var lim = Math.max(postorderNums[v2].lim, postorderNums[w3].lim);
      var parent;
      var lca;
      parent = v2;
      do {
        parent = g2.parent(parent);
        vPath.push(parent);
      } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
      lca = parent;
      parent = w3;
      while ((parent = g2.parent(parent)) !== lca) {
        wPath.push(parent);
      }
      return { path: vPath.concat(wPath.reverse()), lca };
    }
    function postorder(g2) {
      var result = {};
      var lim = 0;
      function dfs(v2) {
        var low = lim;
        _2.forEach(g2.children(v2), dfs);
        result[v2] = { low, lim: lim++ };
      }
      _2.forEach(g2.children(), dfs);
      return result;
    }
  }
});

// node_modules/dagre/lib/nesting-graph.js
var require_nesting_graph = __commonJS({
  "node_modules/dagre/lib/nesting-graph.js"(exports, module) {
    var _2 = require_lodash2();
    var util = require_util();
    module.exports = {
      run,
      cleanup
    };
    function run(g2) {
      var root = util.addDummyNode(g2, "root", {}, "_root");
      var depths = treeDepths(g2);
      var height = _2.max(_2.values(depths)) - 1;
      var nodeSep = 2 * height + 1;
      g2.graph().nestingRoot = root;
      _2.forEach(g2.edges(), function(e3) {
        g2.edge(e3).minlen *= nodeSep;
      });
      var weight = sumWeights(g2) + 1;
      _2.forEach(g2.children(), function(child) {
        dfs(g2, root, nodeSep, weight, height, depths, child);
      });
      g2.graph().nodeRankFactor = nodeSep;
    }
    function dfs(g2, root, nodeSep, weight, height, depths, v2) {
      var children = g2.children(v2);
      if (!children.length) {
        if (v2 !== root) {
          g2.setEdge(root, v2, { weight: 0, minlen: nodeSep });
        }
        return;
      }
      var top = util.addBorderNode(g2, "_bt");
      var bottom = util.addBorderNode(g2, "_bb");
      var label = g2.node(v2);
      g2.setParent(top, v2);
      label.borderTop = top;
      g2.setParent(bottom, v2);
      label.borderBottom = bottom;
      _2.forEach(children, function(child) {
        dfs(g2, root, nodeSep, weight, height, depths, child);
        var childNode = g2.node(child);
        var childTop = childNode.borderTop ? childNode.borderTop : child;
        var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
        var thisWeight = childNode.borderTop ? weight : 2 * weight;
        var minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
        g2.setEdge(top, childTop, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
        g2.setEdge(childBottom, bottom, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
      });
      if (!g2.parent(v2)) {
        g2.setEdge(root, top, { weight: 0, minlen: height + depths[v2] });
      }
    }
    function treeDepths(g2) {
      var depths = {};
      function dfs2(v2, depth) {
        var children = g2.children(v2);
        if (children && children.length) {
          _2.forEach(children, function(child) {
            dfs2(child, depth + 1);
          });
        }
        depths[v2] = depth;
      }
      _2.forEach(g2.children(), function(v2) {
        dfs2(v2, 1);
      });
      return depths;
    }
    function sumWeights(g2) {
      return _2.reduce(g2.edges(), function(acc, e3) {
        return acc + g2.edge(e3).weight;
      }, 0);
    }
    function cleanup(g2) {
      var graphLabel = g2.graph();
      g2.removeNode(graphLabel.nestingRoot);
      delete graphLabel.nestingRoot;
      _2.forEach(g2.edges(), function(e3) {
        var edge = g2.edge(e3);
        if (edge.nestingEdge) {
          g2.removeEdge(e3);
        }
      });
    }
  }
});

// node_modules/dagre/lib/add-border-segments.js
var require_add_border_segments = __commonJS({
  "node_modules/dagre/lib/add-border-segments.js"(exports, module) {
    var _2 = require_lodash2();
    var util = require_util();
    module.exports = addBorderSegments;
    function addBorderSegments(g2) {
      function dfs(v2) {
        var children = g2.children(v2);
        var node = g2.node(v2);
        if (children.length) {
          _2.forEach(children, dfs);
        }
        if (_2.has(node, "minRank")) {
          node.borderLeft = [];
          node.borderRight = [];
          for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {
            addBorderNode(g2, "borderLeft", "_bl", v2, node, rank);
            addBorderNode(g2, "borderRight", "_br", v2, node, rank);
          }
        }
      }
      _2.forEach(g2.children(), dfs);
    }
    function addBorderNode(g2, prop, prefix2, sg, sgNode, rank) {
      var label = { width: 0, height: 0, rank, borderType: prop };
      var prev = sgNode[prop][rank - 1];
      var curr = util.addDummyNode(g2, "border", label, prefix2);
      sgNode[prop][rank] = curr;
      g2.setParent(curr, sg);
      if (prev) {
        g2.setEdge(prev, curr, { weight: 1 });
      }
    }
  }
});

// node_modules/dagre/lib/coordinate-system.js
var require_coordinate_system = __commonJS({
  "node_modules/dagre/lib/coordinate-system.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    module.exports = {
      adjust,
      undo
    };
    function adjust(g2) {
      var rankDir = g2.graph().rankdir.toLowerCase();
      if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight(g2);
      }
    }
    function undo(g2) {
      var rankDir = g2.graph().rankdir.toLowerCase();
      if (rankDir === "bt" || rankDir === "rl") {
        reverseY(g2);
      }
      if (rankDir === "lr" || rankDir === "rl") {
        swapXY(g2);
        swapWidthHeight(g2);
      }
    }
    function swapWidthHeight(g2) {
      _2.forEach(g2.nodes(), function(v2) {
        swapWidthHeightOne(g2.node(v2));
      });
      _2.forEach(g2.edges(), function(e3) {
        swapWidthHeightOne(g2.edge(e3));
      });
    }
    function swapWidthHeightOne(attrs) {
      var w3 = attrs.width;
      attrs.width = attrs.height;
      attrs.height = w3;
    }
    function reverseY(g2) {
      _2.forEach(g2.nodes(), function(v2) {
        reverseYOne(g2.node(v2));
      });
      _2.forEach(g2.edges(), function(e3) {
        var edge = g2.edge(e3);
        _2.forEach(edge.points, reverseYOne);
        if (_2.has(edge, "y")) {
          reverseYOne(edge);
        }
      });
    }
    function reverseYOne(attrs) {
      attrs.y = -attrs.y;
    }
    function swapXY(g2) {
      _2.forEach(g2.nodes(), function(v2) {
        swapXYOne(g2.node(v2));
      });
      _2.forEach(g2.edges(), function(e3) {
        var edge = g2.edge(e3);
        _2.forEach(edge.points, swapXYOne);
        if (_2.has(edge, "x")) {
          swapXYOne(edge);
        }
      });
    }
    function swapXYOne(attrs) {
      var x4 = attrs.x;
      attrs.x = attrs.y;
      attrs.y = x4;
    }
  }
});

// node_modules/dagre/lib/order/init-order.js
var require_init_order = __commonJS({
  "node_modules/dagre/lib/order/init-order.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    module.exports = initOrder;
    function initOrder(g2) {
      var visited = {};
      var simpleNodes = _2.filter(g2.nodes(), function(v2) {
        return !g2.children(v2).length;
      });
      var maxRank = _2.max(_2.map(simpleNodes, function(v2) {
        return g2.node(v2).rank;
      }));
      var layers = _2.map(_2.range(maxRank + 1), function() {
        return [];
      });
      function dfs(v2) {
        if (_2.has(visited, v2))
          return;
        visited[v2] = true;
        var node = g2.node(v2);
        layers[node.rank].push(v2);
        _2.forEach(g2.successors(v2), dfs);
      }
      var orderedVs = _2.sortBy(simpleNodes, function(v2) {
        return g2.node(v2).rank;
      });
      _2.forEach(orderedVs, dfs);
      return layers;
    }
  }
});

// node_modules/dagre/lib/order/cross-count.js
var require_cross_count = __commonJS({
  "node_modules/dagre/lib/order/cross-count.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    module.exports = crossCount;
    function crossCount(g2, layering) {
      var cc = 0;
      for (var i2 = 1; i2 < layering.length; ++i2) {
        cc += twoLayerCrossCount(g2, layering[i2 - 1], layering[i2]);
      }
      return cc;
    }
    function twoLayerCrossCount(g2, northLayer, southLayer) {
      var southPos = _2.zipObject(southLayer, _2.map(southLayer, function(v2, i2) {
        return i2;
      }));
      var southEntries = _2.flatten(_2.map(northLayer, function(v2) {
        return _2.sortBy(_2.map(g2.outEdges(v2), function(e3) {
          return { pos: southPos[e3.w], weight: g2.edge(e3).weight };
        }), "pos");
      }), true);
      var firstIndex = 1;
      while (firstIndex < southLayer.length)
        firstIndex <<= 1;
      var treeSize = 2 * firstIndex - 1;
      firstIndex -= 1;
      var tree = _2.map(new Array(treeSize), function() {
        return 0;
      });
      var cc = 0;
      _2.forEach(southEntries.forEach(function(entry) {
        var index2 = entry.pos + firstIndex;
        tree[index2] += entry.weight;
        var weightSum = 0;
        while (index2 > 0) {
          if (index2 % 2) {
            weightSum += tree[index2 + 1];
          }
          index2 = index2 - 1 >> 1;
          tree[index2] += entry.weight;
        }
        cc += entry.weight * weightSum;
      }));
      return cc;
    }
  }
});

// node_modules/dagre/lib/order/barycenter.js
var require_barycenter = __commonJS({
  "node_modules/dagre/lib/order/barycenter.js"(exports, module) {
    var _2 = require_lodash2();
    module.exports = barycenter;
    function barycenter(g2, movable) {
      return _2.map(movable, function(v2) {
        var inV = g2.inEdges(v2);
        if (!inV.length) {
          return { v: v2 };
        } else {
          var result = _2.reduce(inV, function(acc, e3) {
            var edge = g2.edge(e3), nodeU = g2.node(e3.v);
            return {
              sum: acc.sum + edge.weight * nodeU.order,
              weight: acc.weight + edge.weight
            };
          }, { sum: 0, weight: 0 });
          return {
            v: v2,
            barycenter: result.sum / result.weight,
            weight: result.weight
          };
        }
      });
    }
  }
});

// node_modules/dagre/lib/order/resolve-conflicts.js
var require_resolve_conflicts = __commonJS({
  "node_modules/dagre/lib/order/resolve-conflicts.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    module.exports = resolveConflicts;
    function resolveConflicts(entries, cg) {
      var mappedEntries = {};
      _2.forEach(entries, function(entry, i2) {
        var tmp = mappedEntries[entry.v] = {
          indegree: 0,
          "in": [],
          out: [],
          vs: [entry.v],
          i: i2
        };
        if (!_2.isUndefined(entry.barycenter)) {
          tmp.barycenter = entry.barycenter;
          tmp.weight = entry.weight;
        }
      });
      _2.forEach(cg.edges(), function(e3) {
        var entryV = mappedEntries[e3.v];
        var entryW = mappedEntries[e3.w];
        if (!_2.isUndefined(entryV) && !_2.isUndefined(entryW)) {
          entryW.indegree++;
          entryV.out.push(mappedEntries[e3.w]);
        }
      });
      var sourceSet = _2.filter(mappedEntries, function(entry) {
        return !entry.indegree;
      });
      return doResolveConflicts(sourceSet);
    }
    function doResolveConflicts(sourceSet) {
      var entries = [];
      function handleIn(vEntry) {
        return function(uEntry) {
          if (uEntry.merged) {
            return;
          }
          if (_2.isUndefined(uEntry.barycenter) || _2.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
            mergeEntries(vEntry, uEntry);
          }
        };
      }
      function handleOut(vEntry) {
        return function(wEntry) {
          wEntry["in"].push(vEntry);
          if (--wEntry.indegree === 0) {
            sourceSet.push(wEntry);
          }
        };
      }
      while (sourceSet.length) {
        var entry = sourceSet.pop();
        entries.push(entry);
        _2.forEach(entry["in"].reverse(), handleIn(entry));
        _2.forEach(entry.out, handleOut(entry));
      }
      return _2.map(_2.filter(entries, function(entry2) {
        return !entry2.merged;
      }), function(entry2) {
        return _2.pick(entry2, ["vs", "i", "barycenter", "weight"]);
      });
    }
    function mergeEntries(target, source) {
      var sum5 = 0;
      var weight = 0;
      if (target.weight) {
        sum5 += target.barycenter * target.weight;
        weight += target.weight;
      }
      if (source.weight) {
        sum5 += source.barycenter * source.weight;
        weight += source.weight;
      }
      target.vs = source.vs.concat(target.vs);
      target.barycenter = sum5 / weight;
      target.weight = weight;
      target.i = Math.min(source.i, target.i);
      source.merged = true;
    }
  }
});

// node_modules/dagre/lib/order/sort.js
var require_sort2 = __commonJS({
  "node_modules/dagre/lib/order/sort.js"(exports, module) {
    var _2 = require_lodash2();
    var util = require_util();
    module.exports = sort2;
    function sort2(entries, biasRight) {
      var parts = util.partition(entries, function(entry) {
        return _2.has(entry, "barycenter");
      });
      var sortable = parts.lhs, unsortable = _2.sortBy(parts.rhs, function(entry) {
        return -entry.i;
      }), vs = [], sum5 = 0, weight = 0, vsIndex = 0;
      sortable.sort(compareWithBias(!!biasRight));
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      _2.forEach(sortable, function(entry) {
        vsIndex += entry.vs.length;
        vs.push(entry.vs);
        sum5 += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      });
      var result = { vs: _2.flatten(vs, true) };
      if (weight) {
        result.barycenter = sum5 / weight;
        result.weight = weight;
      }
      return result;
    }
    function consumeUnsortable(vs, unsortable, index2) {
      var last;
      while (unsortable.length && (last = _2.last(unsortable)).i <= index2) {
        unsortable.pop();
        vs.push(last.vs);
        index2++;
      }
      return index2;
    }
    function compareWithBias(bias) {
      return function(entryV, entryW) {
        if (entryV.barycenter < entryW.barycenter) {
          return -1;
        } else if (entryV.barycenter > entryW.barycenter) {
          return 1;
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
      };
    }
  }
});

// node_modules/dagre/lib/order/sort-subgraph.js
var require_sort_subgraph = __commonJS({
  "node_modules/dagre/lib/order/sort-subgraph.js"(exports, module) {
    var _2 = require_lodash2();
    var barycenter = require_barycenter();
    var resolveConflicts = require_resolve_conflicts();
    var sort2 = require_sort2();
    module.exports = sortSubgraph;
    function sortSubgraph(g2, v2, cg, biasRight) {
      var movable = g2.children(v2);
      var node = g2.node(v2);
      var bl = node ? node.borderLeft : void 0;
      var br = node ? node.borderRight : void 0;
      var subgraphs = {};
      if (bl) {
        movable = _2.filter(movable, function(w3) {
          return w3 !== bl && w3 !== br;
        });
      }
      var barycenters = barycenter(g2, movable);
      _2.forEach(barycenters, function(entry) {
        if (g2.children(entry.v).length) {
          var subgraphResult = sortSubgraph(g2, entry.v, cg, biasRight);
          subgraphs[entry.v] = subgraphResult;
          if (_2.has(subgraphResult, "barycenter")) {
            mergeBarycenters(entry, subgraphResult);
          }
        }
      });
      var entries = resolveConflicts(barycenters, cg);
      expandSubgraphs(entries, subgraphs);
      var result = sort2(entries, biasRight);
      if (bl) {
        result.vs = _2.flatten([bl, result.vs, br], true);
        if (g2.predecessors(bl).length) {
          var blPred = g2.node(g2.predecessors(bl)[0]), brPred = g2.node(g2.predecessors(br)[0]);
          if (!_2.has(result, "barycenter")) {
            result.barycenter = 0;
            result.weight = 0;
          }
          result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
          result.weight += 2;
        }
      }
      return result;
    }
    function expandSubgraphs(entries, subgraphs) {
      _2.forEach(entries, function(entry) {
        entry.vs = _2.flatten(entry.vs.map(function(v2) {
          if (subgraphs[v2]) {
            return subgraphs[v2].vs;
          }
          return v2;
        }), true);
      });
    }
    function mergeBarycenters(target, other) {
      if (!_2.isUndefined(target.barycenter)) {
        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
        target.weight += other.weight;
      } else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
      }
    }
  }
});

// node_modules/dagre/lib/order/build-layer-graph.js
var require_build_layer_graph = __commonJS({
  "node_modules/dagre/lib/order/build-layer-graph.js"(exports, module) {
    var _2 = require_lodash2();
    var Graph = require_graphlib2().Graph;
    module.exports = buildLayerGraph;
    function buildLayerGraph(g2, rank, relationship) {
      var root = createRootNode(g2), result = new Graph({ compound: true }).setGraph({ root }).setDefaultNodeLabel(function(v2) {
        return g2.node(v2);
      });
      _2.forEach(g2.nodes(), function(v2) {
        var node = g2.node(v2), parent = g2.parent(v2);
        if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
          result.setNode(v2);
          result.setParent(v2, parent || root);
          _2.forEach(g2[relationship](v2), function(e3) {
            var u2 = e3.v === v2 ? e3.w : e3.v, edge = result.edge(u2, v2), weight = !_2.isUndefined(edge) ? edge.weight : 0;
            result.setEdge(u2, v2, { weight: g2.edge(e3).weight + weight });
          });
          if (_2.has(node, "minRank")) {
            result.setNode(v2, {
              borderLeft: node.borderLeft[rank],
              borderRight: node.borderRight[rank]
            });
          }
        }
      });
      return result;
    }
    function createRootNode(g2) {
      var v2;
      while (g2.hasNode(v2 = _2.uniqueId("_root")))
        ;
      return v2;
    }
  }
});

// node_modules/dagre/lib/order/add-subgraph-constraints.js
var require_add_subgraph_constraints = __commonJS({
  "node_modules/dagre/lib/order/add-subgraph-constraints.js"(exports, module) {
    var _2 = require_lodash2();
    module.exports = addSubgraphConstraints;
    function addSubgraphConstraints(g2, cg, vs) {
      var prev = {}, rootPrev;
      _2.forEach(vs, function(v2) {
        var child = g2.parent(v2), parent, prevChild;
        while (child) {
          parent = g2.parent(child);
          if (parent) {
            prevChild = prev[parent];
            prev[parent] = child;
          } else {
            prevChild = rootPrev;
            rootPrev = child;
          }
          if (prevChild && prevChild !== child) {
            cg.setEdge(prevChild, child);
            return;
          }
          child = parent;
        }
      });
    }
  }
});

// node_modules/dagre/lib/order/index.js
var require_order = __commonJS({
  "node_modules/dagre/lib/order/index.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    var initOrder = require_init_order();
    var crossCount = require_cross_count();
    var sortSubgraph = require_sort_subgraph();
    var buildLayerGraph = require_build_layer_graph();
    var addSubgraphConstraints = require_add_subgraph_constraints();
    var Graph = require_graphlib2().Graph;
    var util = require_util();
    module.exports = order;
    function order(g2) {
      var maxRank = util.maxRank(g2), downLayerGraphs = buildLayerGraphs(g2, _2.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g2, _2.range(maxRank - 1, -1, -1), "outEdges");
      var layering = initOrder(g2);
      assignOrder(g2, layering);
      var bestCC = Number.POSITIVE_INFINITY, best;
      for (var i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
        sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2);
        layering = util.buildLayerMatrix(g2);
        var cc = crossCount(g2, layering);
        if (cc < bestCC) {
          lastBest = 0;
          best = _2.cloneDeep(layering);
          bestCC = cc;
        }
      }
      assignOrder(g2, best);
    }
    function buildLayerGraphs(g2, ranks, relationship) {
      return _2.map(ranks, function(rank) {
        return buildLayerGraph(g2, rank, relationship);
      });
    }
    function sweepLayerGraphs(layerGraphs, biasRight) {
      var cg = new Graph();
      _2.forEach(layerGraphs, function(lg) {
        var root = lg.graph().root;
        var sorted = sortSubgraph(lg, root, cg, biasRight);
        _2.forEach(sorted.vs, function(v2, i2) {
          lg.node(v2).order = i2;
        });
        addSubgraphConstraints(lg, cg, sorted.vs);
      });
    }
    function assignOrder(g2, layering) {
      _2.forEach(layering, function(layer) {
        _2.forEach(layer, function(v2, i2) {
          g2.node(v2).order = i2;
        });
      });
    }
  }
});

// node_modules/dagre/lib/position/bk.js
var require_bk = __commonJS({
  "node_modules/dagre/lib/position/bk.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    var Graph = require_graphlib2().Graph;
    var util = require_util();
    module.exports = {
      positionX,
      findType1Conflicts,
      findType2Conflicts,
      addConflict,
      hasConflict,
      verticalAlignment,
      horizontalCompaction,
      alignCoordinates,
      findSmallestWidthAlignment,
      balance
    };
    function findType1Conflicts(g2, layering) {
      var conflicts = {};
      function visitLayer(prevLayer, layer) {
        var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _2.last(layer);
        _2.forEach(layer, function(v2, i2) {
          var w3 = findOtherInnerSegmentNode(g2, v2), k1 = w3 ? g2.node(w3).order : prevLayerLength;
          if (w3 || v2 === lastNode) {
            _2.forEach(layer.slice(scanPos, i2 + 1), function(scanNode) {
              _2.forEach(g2.predecessors(scanNode), function(u2) {
                var uLabel = g2.node(u2), uPos = uLabel.order;
                if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g2.node(scanNode).dummy)) {
                  addConflict(conflicts, u2, scanNode);
                }
              });
            });
            scanPos = i2 + 1;
            k0 = k1;
          }
        });
        return layer;
      }
      _2.reduce(layering, visitLayer);
      return conflicts;
    }
    function findType2Conflicts(g2, layering) {
      var conflicts = {};
      function scan2(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        var v2;
        _2.forEach(_2.range(southPos, southEnd), function(i2) {
          v2 = south[i2];
          if (g2.node(v2).dummy) {
            _2.forEach(g2.predecessors(v2), function(u2) {
              var uNode = g2.node(u2);
              if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                addConflict(conflicts, u2, v2);
              }
            });
          }
        });
      }
      function visitLayer(north, south) {
        var prevNorthPos = -1, nextNorthPos, southPos = 0;
        _2.forEach(south, function(v2, southLookahead) {
          if (g2.node(v2).dummy === "border") {
            var predecessors = g2.predecessors(v2);
            if (predecessors.length) {
              nextNorthPos = g2.node(predecessors[0]).order;
              scan2(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
              southPos = southLookahead;
              prevNorthPos = nextNorthPos;
            }
          }
          scan2(south, southPos, south.length, nextNorthPos, north.length);
        });
        return south;
      }
      _2.reduce(layering, visitLayer);
      return conflicts;
    }
    function findOtherInnerSegmentNode(g2, v2) {
      if (g2.node(v2).dummy) {
        return _2.find(g2.predecessors(v2), function(u2) {
          return g2.node(u2).dummy;
        });
      }
    }
    function addConflict(conflicts, v2, w3) {
      if (v2 > w3) {
        var tmp = v2;
        v2 = w3;
        w3 = tmp;
      }
      var conflictsV = conflicts[v2];
      if (!conflictsV) {
        conflicts[v2] = conflictsV = {};
      }
      conflictsV[w3] = true;
    }
    function hasConflict(conflicts, v2, w3) {
      if (v2 > w3) {
        var tmp = v2;
        v2 = w3;
        w3 = tmp;
      }
      return _2.has(conflicts[v2], w3);
    }
    function verticalAlignment(g2, layering, conflicts, neighborFn) {
      var root = {}, align = {}, pos = {};
      _2.forEach(layering, function(layer) {
        _2.forEach(layer, function(v2, order) {
          root[v2] = v2;
          align[v2] = v2;
          pos[v2] = order;
        });
      });
      _2.forEach(layering, function(layer) {
        var prevIdx = -1;
        _2.forEach(layer, function(v2) {
          var ws = neighborFn(v2);
          if (ws.length) {
            ws = _2.sortBy(ws, function(w4) {
              return pos[w4];
            });
            var mp = (ws.length - 1) / 2;
            for (var i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
              var w3 = ws[i2];
              if (align[v2] === v2 && prevIdx < pos[w3] && !hasConflict(conflicts, v2, w3)) {
                align[w3] = v2;
                align[v2] = root[v2] = root[w3];
                prevIdx = pos[w3];
              }
            }
          }
        });
      });
      return { root, align };
    }
    function horizontalCompaction(g2, layering, root, align, reverseSep) {
      var xs = {}, blockG = buildBlockGraph(g2, layering, root, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
      function iterate(setXsFunc, nextNodesFunc) {
        var stack = blockG.nodes();
        var elem = stack.pop();
        var visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack.push(elem);
            stack = stack.concat(nextNodesFunc(elem));
          }
          elem = stack.pop();
        }
      }
      function pass1(elem) {
        xs[elem] = blockG.inEdges(elem).reduce(function(acc, e3) {
          return Math.max(acc, xs[e3.v] + blockG.edge(e3));
        }, 0);
      }
      function pass2(elem) {
        var min4 = blockG.outEdges(elem).reduce(function(acc, e3) {
          return Math.min(acc, xs[e3.w] - blockG.edge(e3));
        }, Number.POSITIVE_INFINITY);
        var node = g2.node(elem);
        if (min4 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
          xs[elem] = Math.max(xs[elem], min4);
        }
      }
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
      _2.forEach(align, function(v2) {
        xs[v2] = xs[root[v2]];
      });
      return xs;
    }
    function buildBlockGraph(g2, layering, root, reverseSep) {
      var blockGraph = new Graph(), graphLabel = g2.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
      _2.forEach(layering, function(layer) {
        var u2;
        _2.forEach(layer, function(v2) {
          var vRoot = root[v2];
          blockGraph.setNode(vRoot);
          if (u2) {
            var uRoot = root[u2], prevMax = blockGraph.edge(uRoot, vRoot);
            blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g2, v2, u2), prevMax || 0));
          }
          u2 = v2;
        });
      });
      return blockGraph;
    }
    function findSmallestWidthAlignment(g2, xss) {
      return _2.minBy(_2.values(xss), function(xs) {
        var max4 = Number.NEGATIVE_INFINITY;
        var min4 = Number.POSITIVE_INFINITY;
        _2.forIn(xs, function(x4, v2) {
          var halfWidth = width(g2, v2) / 2;
          max4 = Math.max(x4 + halfWidth, max4);
          min4 = Math.min(x4 - halfWidth, min4);
        });
        return max4 - min4;
      });
    }
    function alignCoordinates(xss, alignTo) {
      var alignToVals = _2.values(alignTo), alignToMin = _2.min(alignToVals), alignToMax = _2.max(alignToVals);
      _2.forEach(["u", "d"], function(vert) {
        _2.forEach(["l", "r"], function(horiz) {
          var alignment = vert + horiz, xs = xss[alignment], delta;
          if (xs === alignTo)
            return;
          var xsVals = _2.values(xs);
          delta = horiz === "l" ? alignToMin - _2.min(xsVals) : alignToMax - _2.max(xsVals);
          if (delta) {
            xss[alignment] = _2.mapValues(xs, function(x4) {
              return x4 + delta;
            });
          }
        });
      });
    }
    function balance(xss, align) {
      return _2.mapValues(xss.ul, function(ignore, v2) {
        if (align) {
          return xss[align.toLowerCase()][v2];
        } else {
          var xs = _2.sortBy(_2.map(xss, v2));
          return (xs[1] + xs[2]) / 2;
        }
      });
    }
    function positionX(g2) {
      var layering = util.buildLayerMatrix(g2);
      var conflicts = _2.merge(findType1Conflicts(g2, layering), findType2Conflicts(g2, layering));
      var xss = {};
      var adjustedLayering;
      _2.forEach(["u", "d"], function(vert) {
        adjustedLayering = vert === "u" ? layering : _2.values(layering).reverse();
        _2.forEach(["l", "r"], function(horiz) {
          if (horiz === "r") {
            adjustedLayering = _2.map(adjustedLayering, function(inner) {
              return _2.values(inner).reverse();
            });
          }
          var neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2);
          var align = verticalAlignment(g2, adjustedLayering, conflicts, neighborFn);
          var xs = horizontalCompaction(g2, adjustedLayering, align.root, align.align, horiz === "r");
          if (horiz === "r") {
            xs = _2.mapValues(xs, function(x4) {
              return -x4;
            });
          }
          xss[vert + horiz] = xs;
        });
      });
      var smallestWidth = findSmallestWidthAlignment(g2, xss);
      alignCoordinates(xss, smallestWidth);
      return balance(xss, g2.graph().align);
    }
    function sep(nodeSep, edgeSep, reverseSep) {
      return function(g2, v2, w3) {
        var vLabel = g2.node(v2);
        var wLabel = g2.node(w3);
        var sum5 = 0;
        var delta;
        sum5 += vLabel.width / 2;
        if (_2.has(vLabel, "labelpos")) {
          switch (vLabel.labelpos.toLowerCase()) {
            case "l":
              delta = -vLabel.width / 2;
              break;
            case "r":
              delta = vLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum5 += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum5 += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum5 += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum5 += wLabel.width / 2;
        if (_2.has(wLabel, "labelpos")) {
          switch (wLabel.labelpos.toLowerCase()) {
            case "l":
              delta = wLabel.width / 2;
              break;
            case "r":
              delta = -wLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum5 += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum5;
      };
    }
    function width(g2, v2) {
      return g2.node(v2).width;
    }
  }
});

// node_modules/dagre/lib/position/index.js
var require_position = __commonJS({
  "node_modules/dagre/lib/position/index.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    var util = require_util();
    var positionX = require_bk().positionX;
    module.exports = position;
    function position(g2) {
      g2 = util.asNonCompoundGraph(g2);
      positionY(g2);
      _2.forEach(positionX(g2), function(x4, v2) {
        g2.node(v2).x = x4;
      });
    }
    function positionY(g2) {
      var layering = util.buildLayerMatrix(g2);
      var rankSep = g2.graph().ranksep;
      var prevY = 0;
      _2.forEach(layering, function(layer) {
        var maxHeight = _2.max(_2.map(layer, function(v2) {
          return g2.node(v2).height;
        }));
        _2.forEach(layer, function(v2) {
          g2.node(v2).y = prevY + maxHeight / 2;
        });
        prevY += maxHeight + rankSep;
      });
    }
  }
});

// node_modules/dagre/lib/layout.js
var require_layout = __commonJS({
  "node_modules/dagre/lib/layout.js"(exports, module) {
    "use strict";
    var _2 = require_lodash2();
    var acyclic = require_acyclic();
    var normalize = require_normalize();
    var rank = require_rank();
    var normalizeRanks = require_util().normalizeRanks;
    var parentDummyChains = require_parent_dummy_chains();
    var removeEmptyRanks = require_util().removeEmptyRanks;
    var nestingGraph = require_nesting_graph();
    var addBorderSegments = require_add_border_segments();
    var coordinateSystem = require_coordinate_system();
    var order = require_order();
    var position = require_position();
    var util = require_util();
    var Graph = require_graphlib2().Graph;
    module.exports = layout;
    function layout(g2, opts) {
      var time = opts && opts.debugTiming ? util.time : util.notime;
      time("layout", function() {
        var layoutGraph = time("  buildLayoutGraph", function() {
          return buildLayoutGraph(g2);
        });
        time("  runLayout", function() {
          runLayout(layoutGraph, time);
        });
        time("  updateInputGraph", function() {
          updateInputGraph(g2, layoutGraph);
        });
      });
    }
    function runLayout(g2, time) {
      time("    makeSpaceForEdgeLabels", function() {
        makeSpaceForEdgeLabels(g2);
      });
      time("    removeSelfEdges", function() {
        removeSelfEdges(g2);
      });
      time("    acyclic", function() {
        acyclic.run(g2);
      });
      time("    nestingGraph.run", function() {
        nestingGraph.run(g2);
      });
      time("    rank", function() {
        rank(util.asNonCompoundGraph(g2));
      });
      time("    injectEdgeLabelProxies", function() {
        injectEdgeLabelProxies(g2);
      });
      time("    removeEmptyRanks", function() {
        removeEmptyRanks(g2);
      });
      time("    nestingGraph.cleanup", function() {
        nestingGraph.cleanup(g2);
      });
      time("    normalizeRanks", function() {
        normalizeRanks(g2);
      });
      time("    assignRankMinMax", function() {
        assignRankMinMax(g2);
      });
      time("    removeEdgeLabelProxies", function() {
        removeEdgeLabelProxies(g2);
      });
      time("    normalize.run", function() {
        normalize.run(g2);
      });
      time("    parentDummyChains", function() {
        parentDummyChains(g2);
      });
      time("    addBorderSegments", function() {
        addBorderSegments(g2);
      });
      time("    order", function() {
        order(g2);
      });
      time("    insertSelfEdges", function() {
        insertSelfEdges(g2);
      });
      time("    adjustCoordinateSystem", function() {
        coordinateSystem.adjust(g2);
      });
      time("    position", function() {
        position(g2);
      });
      time("    positionSelfEdges", function() {
        positionSelfEdges(g2);
      });
      time("    removeBorderNodes", function() {
        removeBorderNodes(g2);
      });
      time("    normalize.undo", function() {
        normalize.undo(g2);
      });
      time("    fixupEdgeLabelCoords", function() {
        fixupEdgeLabelCoords(g2);
      });
      time("    undoCoordinateSystem", function() {
        coordinateSystem.undo(g2);
      });
      time("    translateGraph", function() {
        translateGraph(g2);
      });
      time("    assignNodeIntersects", function() {
        assignNodeIntersects(g2);
      });
      time("    reversePoints", function() {
        reversePointsForReversedEdges(g2);
      });
      time("    acyclic.undo", function() {
        acyclic.undo(g2);
      });
    }
    function updateInputGraph(inputGraph, layoutGraph) {
      _2.forEach(inputGraph.nodes(), function(v2) {
        var inputLabel = inputGraph.node(v2);
        var layoutLabel = layoutGraph.node(v2);
        if (inputLabel) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
          if (layoutGraph.children(v2).length) {
            inputLabel.width = layoutLabel.width;
            inputLabel.height = layoutLabel.height;
          }
        }
      });
      _2.forEach(inputGraph.edges(), function(e3) {
        var inputLabel = inputGraph.edge(e3);
        var layoutLabel = layoutGraph.edge(e3);
        inputLabel.points = layoutLabel.points;
        if (_2.has(layoutLabel, "x")) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
        }
      });
      inputGraph.graph().width = layoutGraph.graph().width;
      inputGraph.graph().height = layoutGraph.graph().height;
    }
    var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
    var nodeNumAttrs = ["width", "height"];
    var nodeDefaults = { width: 0, height: 0 };
    var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
    var edgeDefaults = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    };
    var edgeAttrs = ["labelpos"];
    function buildLayoutGraph(inputGraph) {
      var g2 = new Graph({ multigraph: true, compound: true });
      var graph = canonicalize(inputGraph.graph());
      g2.setGraph(_2.merge({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), _2.pick(graph, graphAttrs)));
      _2.forEach(inputGraph.nodes(), function(v2) {
        var node = canonicalize(inputGraph.node(v2));
        g2.setNode(v2, _2.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
        g2.setParent(v2, inputGraph.parent(v2));
      });
      _2.forEach(inputGraph.edges(), function(e3) {
        var edge = canonicalize(inputGraph.edge(e3));
        g2.setEdge(e3, _2.merge({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), _2.pick(edge, edgeAttrs)));
      });
      return g2;
    }
    function makeSpaceForEdgeLabels(g2) {
      var graph = g2.graph();
      graph.ranksep /= 2;
      _2.forEach(g2.edges(), function(e3) {
        var edge = g2.edge(e3);
        edge.minlen *= 2;
        if (edge.labelpos.toLowerCase() !== "c") {
          if (graph.rankdir === "TB" || graph.rankdir === "BT") {
            edge.width += edge.labeloffset;
          } else {
            edge.height += edge.labeloffset;
          }
        }
      });
    }
    function injectEdgeLabelProxies(g2) {
      _2.forEach(g2.edges(), function(e3) {
        var edge = g2.edge(e3);
        if (edge.width && edge.height) {
          var v2 = g2.node(e3.v);
          var w3 = g2.node(e3.w);
          var label = { rank: (w3.rank - v2.rank) / 2 + v2.rank, e: e3 };
          util.addDummyNode(g2, "edge-proxy", label, "_ep");
        }
      });
    }
    function assignRankMinMax(g2) {
      var maxRank = 0;
      _2.forEach(g2.nodes(), function(v2) {
        var node = g2.node(v2);
        if (node.borderTop) {
          node.minRank = g2.node(node.borderTop).rank;
          node.maxRank = g2.node(node.borderBottom).rank;
          maxRank = _2.max(maxRank, node.maxRank);
        }
      });
      g2.graph().maxRank = maxRank;
    }
    function removeEdgeLabelProxies(g2) {
      _2.forEach(g2.nodes(), function(v2) {
        var node = g2.node(v2);
        if (node.dummy === "edge-proxy") {
          g2.edge(node.e).labelRank = node.rank;
          g2.removeNode(v2);
        }
      });
    }
    function translateGraph(g2) {
      var minX = Number.POSITIVE_INFINITY;
      var maxX = 0;
      var minY = Number.POSITIVE_INFINITY;
      var maxY2 = 0;
      var graphLabel = g2.graph();
      var marginX = graphLabel.marginx || 0;
      var marginY = graphLabel.marginy || 0;
      function getExtremes(attrs) {
        var x4 = attrs.x;
        var y4 = attrs.y;
        var w3 = attrs.width;
        var h2 = attrs.height;
        minX = Math.min(minX, x4 - w3 / 2);
        maxX = Math.max(maxX, x4 + w3 / 2);
        minY = Math.min(minY, y4 - h2 / 2);
        maxY2 = Math.max(maxY2, y4 + h2 / 2);
      }
      _2.forEach(g2.nodes(), function(v2) {
        getExtremes(g2.node(v2));
      });
      _2.forEach(g2.edges(), function(e3) {
        var edge = g2.edge(e3);
        if (_2.has(edge, "x")) {
          getExtremes(edge);
        }
      });
      minX -= marginX;
      minY -= marginY;
      _2.forEach(g2.nodes(), function(v2) {
        var node = g2.node(v2);
        node.x -= minX;
        node.y -= minY;
      });
      _2.forEach(g2.edges(), function(e3) {
        var edge = g2.edge(e3);
        _2.forEach(edge.points, function(p2) {
          p2.x -= minX;
          p2.y -= minY;
        });
        if (_2.has(edge, "x")) {
          edge.x -= minX;
        }
        if (_2.has(edge, "y")) {
          edge.y -= minY;
        }
      });
      graphLabel.width = maxX - minX + marginX;
      graphLabel.height = maxY2 - minY + marginY;
    }
    function assignNodeIntersects(g2) {
      _2.forEach(g2.edges(), function(e3) {
        var edge = g2.edge(e3);
        var nodeV = g2.node(e3.v);
        var nodeW = g2.node(e3.w);
        var p1, p2;
        if (!edge.points) {
          edge.points = [];
          p1 = nodeW;
          p2 = nodeV;
        } else {
          p1 = edge.points[0];
          p2 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift(util.intersectRect(nodeV, p1));
        edge.points.push(util.intersectRect(nodeW, p2));
      });
    }
    function fixupEdgeLabelCoords(g2) {
      _2.forEach(g2.edges(), function(e3) {
        var edge = g2.edge(e3);
        if (_2.has(edge, "x")) {
          if (edge.labelpos === "l" || edge.labelpos === "r") {
            edge.width -= edge.labeloffset;
          }
          switch (edge.labelpos) {
            case "l":
              edge.x -= edge.width / 2 + edge.labeloffset;
              break;
            case "r":
              edge.x += edge.width / 2 + edge.labeloffset;
              break;
          }
        }
      });
    }
    function reversePointsForReversedEdges(g2) {
      _2.forEach(g2.edges(), function(e3) {
        var edge = g2.edge(e3);
        if (edge.reversed) {
          edge.points.reverse();
        }
      });
    }
    function removeBorderNodes(g2) {
      _2.forEach(g2.nodes(), function(v2) {
        if (g2.children(v2).length) {
          var node = g2.node(v2);
          var t2 = g2.node(node.borderTop);
          var b2 = g2.node(node.borderBottom);
          var l2 = g2.node(_2.last(node.borderLeft));
          var r2 = g2.node(_2.last(node.borderRight));
          node.width = Math.abs(r2.x - l2.x);
          node.height = Math.abs(b2.y - t2.y);
          node.x = l2.x + node.width / 2;
          node.y = t2.y + node.height / 2;
        }
      });
      _2.forEach(g2.nodes(), function(v2) {
        if (g2.node(v2).dummy === "border") {
          g2.removeNode(v2);
        }
      });
    }
    function removeSelfEdges(g2) {
      _2.forEach(g2.edges(), function(e3) {
        if (e3.v === e3.w) {
          var node = g2.node(e3.v);
          if (!node.selfEdges) {
            node.selfEdges = [];
          }
          node.selfEdges.push({ e: e3, label: g2.edge(e3) });
          g2.removeEdge(e3);
        }
      });
    }
    function insertSelfEdges(g2) {
      var layers = util.buildLayerMatrix(g2);
      _2.forEach(layers, function(layer) {
        var orderShift = 0;
        _2.forEach(layer, function(v2, i2) {
          var node = g2.node(v2);
          node.order = i2 + orderShift;
          _2.forEach(node.selfEdges, function(selfEdge) {
            util.addDummyNode(g2, "selfedge", {
              width: selfEdge.label.width,
              height: selfEdge.label.height,
              rank: node.rank,
              order: i2 + ++orderShift,
              e: selfEdge.e,
              label: selfEdge.label
            }, "_se");
          });
          delete node.selfEdges;
        });
      });
    }
    function positionSelfEdges(g2) {
      _2.forEach(g2.nodes(), function(v2) {
        var node = g2.node(v2);
        if (node.dummy === "selfedge") {
          var selfNode = g2.node(node.e.v);
          var x4 = selfNode.x + selfNode.width / 2;
          var y4 = selfNode.y;
          var dx = node.x - x4;
          var dy = selfNode.height / 2;
          g2.setEdge(node.e, node.label);
          g2.removeNode(v2);
          node.label.points = [
            { x: x4 + 2 * dx / 3, y: y4 - dy },
            { x: x4 + 5 * dx / 6, y: y4 - dy },
            { x: x4 + dx, y: y4 },
            { x: x4 + 5 * dx / 6, y: y4 + dy },
            { x: x4 + 2 * dx / 3, y: y4 + dy }
          ];
          node.label.x = node.x;
          node.label.y = node.y;
        }
      });
    }
    function selectNumberAttrs(obj, attrs) {
      return _2.mapValues(_2.pick(obj, attrs), Number);
    }
    function canonicalize(attrs) {
      var newAttrs = {};
      _2.forEach(attrs, function(v2, k4) {
        newAttrs[k4.toLowerCase()] = v2;
      });
      return newAttrs;
    }
  }
});

// node_modules/dagre/lib/debug.js
var require_debug = __commonJS({
  "node_modules/dagre/lib/debug.js"(exports, module) {
    var _2 = require_lodash2();
    var util = require_util();
    var Graph = require_graphlib2().Graph;
    module.exports = {
      debugOrdering
    };
    function debugOrdering(g2) {
      var layerMatrix = util.buildLayerMatrix(g2);
      var h2 = new Graph({ compound: true, multigraph: true }).setGraph({});
      _2.forEach(g2.nodes(), function(v2) {
        h2.setNode(v2, { label: v2 });
        h2.setParent(v2, "layer" + g2.node(v2).rank);
      });
      _2.forEach(g2.edges(), function(e3) {
        h2.setEdge(e3.v, e3.w, {}, e3.name);
      });
      _2.forEach(layerMatrix, function(layer, i2) {
        var layerV = "layer" + i2;
        h2.setNode(layerV, { rank: "same" });
        _2.reduce(layer, function(u2, v2) {
          h2.setEdge(u2, v2, { style: "invis" });
          return v2;
        });
      });
      return h2;
    }
  }
});

// node_modules/dagre/lib/version.js
var require_version2 = __commonJS({
  "node_modules/dagre/lib/version.js"(exports, module) {
    module.exports = "0.8.5";
  }
});

// node_modules/dagre/index.js
var require_dagre = __commonJS({
  "node_modules/dagre/index.js"(exports, module) {
    module.exports = {
      graphlib: require_graphlib2(),
      layout: require_layout(),
      debug: require_debug(),
      util: {
        time: require_util().time,
        notime: require_util().notime
      },
      version: require_version2()
    };
  }
});

// node_modules/@antv/data-set/lib/transform/diagram/dagre.js
var require_dagre2 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/diagram/dagre.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var dagre_1 = tslib_1.__importDefault(require_dagre());
    var data_set_1 = require_data_set();
    var DEFAULT_OPTIONS = {
      rankdir: "TB",
      align: "TB",
      nodesep: 50,
      edgesep: 10,
      ranksep: 50,
      source: function(edge) {
        return edge.source;
      },
      target: function(edge) {
        return edge.target;
      }
    };
    function transform(dv, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var g2 = new dagre_1.default.graphlib.Graph();
      g2.setGraph({});
      g2.setDefaultEdgeLabel(function() {
        return {};
      });
      dv.nodes.forEach(function(node) {
        var nodeId = options.nodeId ? options.nodeId(node) : node.id;
        if (!node.height && !node.width) {
          node.height = node.width = options.edgesep;
        }
        g2.setNode(nodeId, node);
      });
      dv.edges.forEach(function(edge) {
        g2.setEdge(options.source(edge), options.target(edge));
      });
      dagre_1.default.layout(g2);
      var nodes = [];
      var edges2 = [];
      g2.nodes().forEach(function(node) {
        var n2 = g2.node(node);
        var x4 = n2.x, y4 = n2.y, height = n2.height, width = n2.width;
        n2.x = [x4 - width / 2, x4 + width / 2, x4 + width / 2, x4 - width / 2];
        n2.y = [y4 + height / 2, y4 + height / 2, y4 - height / 2, y4 - height / 2];
        nodes.push(n2);
      });
      g2.edges().forEach(function(edge) {
        var points2 = g2.edge(edge).points;
        var e3 = {};
        e3.x = points2.map(function(p2) {
          return p2.x;
        });
        e3.y = points2.map(function(p2) {
          return p2.y;
        });
        edges2.push(e3);
      });
      dv.nodes = nodes;
      dv.edges = edges2;
    }
    data_set_1.DataSet.registerTransform("diagram.dagre", transform);
    data_set_1.DataSet.registerTransform("dagre", transform);
  }
});

// node_modules/d3-collection/src/map.js
function Map2() {
}
function map4(object3, f2) {
  var map5 = new Map2();
  if (object3 instanceof Map2)
    object3.each(function(value2, key2) {
      map5.set(key2, value2);
    });
  else if (Array.isArray(object3)) {
    var i2 = -1, n2 = object3.length, o2;
    if (f2 == null)
      while (++i2 < n2)
        map5.set(i2, object3[i2]);
    else
      while (++i2 < n2)
        map5.set(f2(o2 = object3[i2], i2, object3), o2);
  } else if (object3)
    for (var key in object3)
      map5.set(key, object3[key]);
  return map5;
}
var prefix, map_default;
var init_map2 = __esm({
  "node_modules/d3-collection/src/map.js"() {
    prefix = "$";
    Map2.prototype = map4.prototype = {
      constructor: Map2,
      has: function(key) {
        return prefix + key in this;
      },
      get: function(key) {
        return this[prefix + key];
      },
      set: function(key, value2) {
        this[prefix + key] = value2;
        return this;
      },
      remove: function(key) {
        var property = prefix + key;
        return property in this && delete this[property];
      },
      clear: function() {
        for (var property in this)
          if (property[0] === prefix)
            delete this[property];
      },
      keys: function() {
        var keys = [];
        for (var property in this)
          if (property[0] === prefix)
            keys.push(property.slice(1));
        return keys;
      },
      values: function() {
        var values = [];
        for (var property in this)
          if (property[0] === prefix)
            values.push(this[property]);
        return values;
      },
      entries: function() {
        var entries = [];
        for (var property in this)
          if (property[0] === prefix)
            entries.push({ key: property.slice(1), value: this[property] });
        return entries;
      },
      size: function() {
        var size = 0;
        for (var property in this)
          if (property[0] === prefix)
            ++size;
        return size;
      },
      empty: function() {
        for (var property in this)
          if (property[0] === prefix)
            return false;
        return true;
      },
      each: function(f2) {
        for (var property in this)
          if (property[0] === prefix)
            f2(this[property], property.slice(1), this);
      }
    };
    map_default = map4;
  }
});

// node_modules/d3-collection/src/nest.js
function nest_default() {
  var keys = [], sortKeys = [], sortValues, rollup2, nest;
  function apply(array3, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null)
        array3.sort(sortValues);
      return rollup2 != null ? rollup2(array3) : array3;
    }
    var i2 = -1, n2 = array3.length, key = keys[depth++], keyValue, value2, valuesByKey = map_default(), values, result = createResult();
    while (++i2 < n2) {
      if (values = valuesByKey.get(keyValue = key(value2 = array3[i2]) + "")) {
        values.push(value2);
      } else {
        valuesByKey.set(keyValue, [value2]);
      }
    }
    valuesByKey.each(function(values2, key2) {
      setResult(result, key2, apply(values2, depth, createResult, setResult));
    });
    return result;
  }
  function entries(map5, depth) {
    if (++depth > keys.length)
      return map5;
    var array3, sortKey = sortKeys[depth - 1];
    if (rollup2 != null && depth >= keys.length)
      array3 = map5.entries();
    else
      array3 = [], map5.each(function(v2, k4) {
        array3.push({ key: k4, values: entries(v2, depth) });
      });
    return sortKey != null ? array3.sort(function(a3, b2) {
      return sortKey(a3.key, b2.key);
    }) : array3;
  }
  return nest = {
    object: function(array3) {
      return apply(array3, 0, createObject, setObject);
    },
    map: function(array3) {
      return apply(array3, 0, createMap, setMap);
    },
    entries: function(array3) {
      return entries(apply(array3, 0, createMap, setMap), 0);
    },
    key: function(d2) {
      keys.push(d2);
      return nest;
    },
    sortKeys: function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    },
    sortValues: function(order) {
      sortValues = order;
      return nest;
    },
    rollup: function(f2) {
      rollup2 = f2;
      return nest;
    }
  };
}
function createObject() {
  return {};
}
function setObject(object3, key, value2) {
  object3[key] = value2;
}
function createMap() {
  return map_default();
}
function setMap(map5, key, value2) {
  map5.set(key, value2);
}
var init_nest = __esm({
  "node_modules/d3-collection/src/nest.js"() {
    init_map2();
  }
});

// node_modules/d3-collection/src/set.js
function Set2() {
}
function set2(object3, f2) {
  var set3 = new Set2();
  if (object3 instanceof Set2)
    object3.each(function(value2) {
      set3.add(value2);
    });
  else if (object3) {
    var i2 = -1, n2 = object3.length;
    if (f2 == null)
      while (++i2 < n2)
        set3.add(object3[i2]);
    else
      while (++i2 < n2)
        set3.add(f2(object3[i2], i2, object3));
  }
  return set3;
}
var proto;
var init_set2 = __esm({
  "node_modules/d3-collection/src/set.js"() {
    init_map2();
    proto = map_default.prototype;
    Set2.prototype = set2.prototype = {
      constructor: Set2,
      has: proto.has,
      add: function(value2) {
        value2 += "";
        this[prefix + value2] = value2;
        return this;
      },
      remove: proto.remove,
      clear: proto.clear,
      values: proto.keys,
      size: proto.size,
      empty: proto.empty,
      each: proto.each
    };
  }
});

// node_modules/d3-collection/src/keys.js
var init_keys = __esm({
  "node_modules/d3-collection/src/keys.js"() {
  }
});

// node_modules/d3-collection/src/values.js
var init_values = __esm({
  "node_modules/d3-collection/src/values.js"() {
  }
});

// node_modules/d3-collection/src/entries.js
var init_entries = __esm({
  "node_modules/d3-collection/src/entries.js"() {
  }
});

// node_modules/d3-collection/src/index.js
var init_src10 = __esm({
  "node_modules/d3-collection/src/index.js"() {
    init_nest();
    init_set2();
    init_map2();
    init_keys();
    init_values();
    init_entries();
  }
});

// node_modules/d3-sankey/src/align.js
function targetDepth(d2) {
  return d2.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n2) {
  return n2 - 1 - node.height;
}
function justify(node, n2) {
  return node.sourceLinks.length ? node.depth : n2 - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min_default(node.sourceLinks, targetDepth) - 1 : 0;
}
var init_align = __esm({
  "node_modules/d3-sankey/src/align.js"() {
    init_src();
  }
});

// node_modules/d3-sankey/src/constant.js
function constant(x4) {
  return function() {
    return x4;
  };
}
var init_constant7 = __esm({
  "node_modules/d3-sankey/src/constant.js"() {
  }
});

// node_modules/d3-sankey/src/sankey.js
function ascendingSourceBreadth(a3, b2) {
  return ascendingBreadth(a3.source, b2.source) || a3.index - b2.index;
}
function ascendingTargetBreadth(a3, b2) {
  return ascendingBreadth(a3.target, b2.target) || a3.index - b2.index;
}
function ascendingBreadth(a3, b2) {
  return a3.y0 - b2.y0;
}
function value(d2) {
  return d2.value;
}
function defaultId2(d2) {
  return d2.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id) {
  var node = nodeById.get(id);
  if (!node)
    throw new Error("missing: " + id);
  return node;
}
function Sankey() {
  var x011 = 0, y011 = 0, x16 = 1, y16 = 1, dx = 24, py = 8, id = defaultId2, align = justify, sort2, nodes = defaultNodes, links = defaultLinks, iterations3 = 6;
  function sankey() {
    var graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_2) {
    return arguments.length ? (id = typeof _2 === "function" ? _2 : constant(_2), sankey) : id;
  };
  sankey.nodeAlign = function(_2) {
    return arguments.length ? (align = typeof _2 === "function" ? _2 : constant(_2), sankey) : align;
  };
  sankey.nodeSort = function(_2) {
    return arguments.length ? (sort2 = _2, sankey) : sort2;
  };
  sankey.nodeWidth = function(_2) {
    return arguments.length ? (dx = +_2, sankey) : dx;
  };
  sankey.nodePadding = function(_2) {
    return arguments.length ? (py = +_2, sankey) : py;
  };
  sankey.nodes = function(_2) {
    return arguments.length ? (nodes = typeof _2 === "function" ? _2 : constant(_2), sankey) : nodes;
  };
  sankey.links = function(_2) {
    return arguments.length ? (links = typeof _2 === "function" ? _2 : constant(_2), sankey) : links;
  };
  sankey.size = function(_2) {
    return arguments.length ? (x011 = y011 = 0, x16 = +_2[0], y16 = +_2[1], sankey) : [x16 - x011, y16 - y011];
  };
  sankey.extent = function(_2) {
    return arguments.length ? (x011 = +_2[0][0], x16 = +_2[1][0], y011 = +_2[0][1], y16 = +_2[1][1], sankey) : [[x011, y011], [x16, y16]];
  };
  sankey.iterations = function(_2) {
    return arguments.length ? (iterations3 = +_2, sankey) : iterations3;
  };
  function computeNodeLinks(graph) {
    graph.nodes.forEach(function(node, i2) {
      node.index = i2;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    var nodeById = map_default(graph.nodes, id);
    graph.links.forEach(function(link5, i2) {
      link5.index = i2;
      var source = link5.source, target = link5.target;
      if (typeof source !== "object")
        source = link5.source = find(nodeById, source);
      if (typeof target !== "object")
        target = link5.target = find(nodeById, target);
      source.sourceLinks.push(link5);
      target.targetLinks.push(link5);
    });
  }
  function computeNodeValues(graph) {
    graph.nodes.forEach(function(node) {
      node.value = Math.max(sum_default(node.sourceLinks, value), sum_default(node.targetLinks, value));
    });
  }
  function computeNodeDepths(graph) {
    var nodes2, next, x4, n2 = graph.nodes.length;
    for (nodes2 = graph.nodes, next = [], x4 = 0; nodes2.length; ++x4, nodes2 = next, next = []) {
      if (x4 > n2)
        throw new Error("circular link");
      nodes2.forEach(function(node) {
        node.depth = x4;
        node.sourceLinks.forEach(function(link5) {
          if (next.indexOf(link5.target) < 0) {
            next.push(link5.target);
          }
        });
      });
    }
    for (nodes2 = graph.nodes, next = [], x4 = 0; nodes2.length; ++x4, nodes2 = next, next = []) {
      if (x4 > n2)
        throw new Error("circular link");
      nodes2.forEach(function(node) {
        node.height = x4;
        node.targetLinks.forEach(function(link5) {
          if (next.indexOf(link5.source) < 0) {
            next.push(link5.source);
          }
        });
      });
    }
    var kx3 = (x16 - x011 - dx) / (x4 - 1);
    graph.nodes.forEach(function(node) {
      node.x1 = (node.x0 = x011 + Math.max(0, Math.min(x4 - 1, Math.floor(align.call(null, node, x4)))) * kx3) + dx;
    });
  }
  function computeNodeBreadths(graph) {
    var columns = nest_default().key(function(d2) {
      return d2.x0;
    }).sortKeys(ascending_default).entries(graph.nodes).map(function(d2) {
      return d2.values;
    });
    initializeNodeBreadth();
    resolveCollisions();
    for (var alpha = 0.9, n2 = iterations3; n2 > 0; --n2, alpha *= 0.9) {
      relaxRightToLeft(alpha);
      resolveCollisions();
      relaxLeftToRight(alpha);
      resolveCollisions();
    }
    function initializeNodeBreadth() {
      var ky2 = min_default(columns, function(nodes2) {
        return (y16 - y011 - (nodes2.length - 1) * py) / sum_default(nodes2, value);
      });
      columns.forEach(function(nodes2) {
        if (sort2 != null)
          nodes2.sort(sort2);
        nodes2.forEach(function(node, i2) {
          node.y1 = (node.y0 = i2) + node.value * ky2;
        });
      });
      graph.links.forEach(function(link5) {
        link5.width = link5.value * ky2;
      });
    }
    function relaxLeftToRight(alpha2) {
      columns.forEach(function(nodes2) {
        nodes2.forEach(function(node) {
          let y4 = node.y0;
          for (const { target, width, value: value2 } of node.sourceLinks.sort(ascendingTargetBreadth)) {
            if (value2 > 0) {
              let dy = 0;
              for (const { source, width: width2 } of target.targetLinks) {
                if (source === node)
                  break;
                dy += width2 + py / 2;
              }
              dy = (y4 - dy - target.y0) * alpha2 * (value2 / Math.min(node.value, target.value));
              target.y0 += dy;
              target.y1 += dy;
            }
            y4 += width + py / 2;
          }
        });
      });
    }
    function relaxRightToLeft(alpha2) {
      columns.slice().reverse().forEach(function(nodes2) {
        nodes2.forEach(function(node) {
          let y4 = node.y0;
          for (const { source, width, value: value2 } of node.targetLinks.sort(ascendingSourceBreadth)) {
            if (value2 > 0) {
              let dy = 0;
              for (const { target, width: width2 } of source.sourceLinks) {
                if (target === node)
                  break;
                dy += width2 + py / 2;
              }
              dy = (y4 - dy - source.y0) * alpha2 * (value2 / Math.min(node.value, source.value));
              source.y0 += dy;
              source.y1 += dy;
            }
            y4 += width + py / 2;
          }
        });
      });
    }
    function resolveCollisions() {
      columns.forEach(function(nodes2) {
        var node, dy, y4 = y011, n3 = nodes2.length, i2;
        if (sort2 === void 0)
          nodes2.sort(ascendingBreadth);
        for (i2 = 0; i2 < n3; ++i2) {
          node = nodes2[i2];
          dy = y4 - node.y0;
          if (dy > 0)
            node.y0 += dy, node.y1 += dy;
          y4 = node.y1 + py;
        }
        dy = y4 - py - y16;
        if (dy > 0) {
          y4 = node.y0 -= dy, node.y1 -= dy;
          for (i2 = n3 - 2; i2 >= 0; --i2) {
            node = nodes2[i2];
            dy = node.y1 + py - y4;
            if (dy > 0)
              node.y0 -= dy, node.y1 -= dy;
            y4 = node.y0;
          }
        }
      });
    }
  }
  function computeLinkBreadths(graph) {
    graph.nodes.forEach(function(node) {
      node.sourceLinks.sort(ascendingTargetBreadth);
      node.targetLinks.sort(ascendingSourceBreadth);
    });
    graph.nodes.forEach(function(node) {
      var y012 = node.y0, y17 = y012;
      node.sourceLinks.forEach(function(link5) {
        link5.y0 = y012 + link5.width / 2, y012 += link5.width;
      });
      node.targetLinks.forEach(function(link5) {
        link5.y1 = y17 + link5.width / 2, y17 += link5.width;
      });
    });
  }
  return sankey;
}
var init_sankey = __esm({
  "node_modules/d3-sankey/src/sankey.js"() {
    init_src();
    init_src10();
    init_align();
    init_constant7();
  }
});

// node_modules/d3-shape/node_modules/d3-path/src/path.js
function Path2() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path2() {
  return new Path2();
}
var pi6, tau6, epsilon9, tauEpsilon2, path_default6;
var init_path6 = __esm({
  "node_modules/d3-shape/node_modules/d3-path/src/path.js"() {
    pi6 = Math.PI;
    tau6 = 2 * pi6;
    epsilon9 = 1e-6;
    tauEpsilon2 = tau6 - epsilon9;
    Path2.prototype = path2.prototype = {
      constructor: Path2,
      moveTo: function(x4, y4) {
        this._ += "M" + (this._x0 = this._x1 = +x4) + "," + (this._y0 = this._y1 = +y4);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x4, y4) {
        this._ += "L" + (this._x1 = +x4) + "," + (this._y1 = +y4);
      },
      quadraticCurveTo: function(x16, y16, x4, y4) {
        this._ += "Q" + +x16 + "," + +y16 + "," + (this._x1 = +x4) + "," + (this._y1 = +y4);
      },
      bezierCurveTo: function(x16, y16, x22, y22, x4, y4) {
        this._ += "C" + +x16 + "," + +y16 + "," + +x22 + "," + +y22 + "," + (this._x1 = +x4) + "," + (this._y1 = +y4);
      },
      arcTo: function(x16, y16, x22, y22, r2) {
        x16 = +x16, y16 = +y16, x22 = +x22, y22 = +y22, r2 = +r2;
        var x011 = this._x1, y011 = this._y1, x21 = x22 - x16, y21 = y22 - y16, x01 = x011 - x16, y01 = y011 - y16, l01_2 = x01 * x01 + y01 * y01;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x16) + "," + (this._y1 = y16);
        } else if (!(l01_2 > epsilon9))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon9) || !r2) {
          this._ += "L" + (this._x1 = x16) + "," + (this._y1 = y16);
        } else {
          var x20 = x22 - x011, y20 = y22 - y011, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi6 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
          if (Math.abs(t01 - 1) > epsilon9) {
            this._ += "L" + (x16 + t01 * x01) + "," + (y16 + t01 * y01);
          }
          this._ += "A" + r2 + "," + r2 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x16 + t21 * x21) + "," + (this._y1 = y16 + t21 * y21);
        }
      },
      arc: function(x4, y4, r2, a0, a1, ccw) {
        x4 = +x4, y4 = +y4, r2 = +r2, ccw = !!ccw;
        var dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x011 = x4 + dx, y011 = y4 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + x011 + "," + y011;
        } else if (Math.abs(this._x1 - x011) > epsilon9 || Math.abs(this._y1 - y011) > epsilon9) {
          this._ += "L" + x011 + "," + y011;
        }
        if (!r2)
          return;
        if (da < 0)
          da = da % tau6 + tau6;
        if (da > tauEpsilon2) {
          this._ += "A" + r2 + "," + r2 + ",0,1," + cw + "," + (x4 - dx) + "," + (y4 - dy) + "A" + r2 + "," + r2 + ",0,1," + cw + "," + (this._x1 = x011) + "," + (this._y1 = y011);
        } else if (da > epsilon9) {
          this._ += "A" + r2 + "," + r2 + ",0," + +(da >= pi6) + "," + cw + "," + (this._x1 = x4 + r2 * Math.cos(a1)) + "," + (this._y1 = y4 + r2 * Math.sin(a1));
        }
      },
      rect: function(x4, y4, w3, h2) {
        this._ += "M" + (this._x0 = this._x1 = +x4) + "," + (this._y0 = this._y1 = +y4) + "h" + +w3 + "v" + +h2 + "h" + -w3 + "Z";
      },
      toString: function() {
        return this._;
      }
    };
    path_default6 = path2;
  }
});

// node_modules/d3-shape/node_modules/d3-path/src/index.js
var init_src11 = __esm({
  "node_modules/d3-shape/node_modules/d3-path/src/index.js"() {
    init_path6();
  }
});

// node_modules/d3-shape/src/constant.js
function constant_default7(x4) {
  return function constant2() {
    return x4;
  };
}
var init_constant8 = __esm({
  "node_modules/d3-shape/src/constant.js"() {
  }
});

// node_modules/d3-shape/src/math.js
var epsilon10, pi7, halfPi5, tau7;
var init_math6 = __esm({
  "node_modules/d3-shape/src/math.js"() {
    epsilon10 = 1e-12;
    pi7 = Math.PI;
    halfPi5 = pi7 / 2;
    tau7 = 2 * pi7;
  }
});

// node_modules/d3-shape/src/arc.js
var init_arc = __esm({
  "node_modules/d3-shape/src/arc.js"() {
    init_src11();
    init_constant8();
    init_math6();
  }
});

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
function linear_default(context) {
  return new Linear(context);
}
var init_linear = __esm({
  "node_modules/d3-shape/src/curve/linear.js"() {
    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
            break;
          case 1:
            this._point = 2;
          default:
            this._context.lineTo(x4, y4);
            break;
        }
      }
    };
  }
});

// node_modules/d3-shape/src/point.js
function x2(p2) {
  return p2[0];
}
function y2(p2) {
  return p2[1];
}
var init_point = __esm({
  "node_modules/d3-shape/src/point.js"() {
  }
});

// node_modules/d3-shape/src/line.js
var init_line4 = __esm({
  "node_modules/d3-shape/src/line.js"() {
    init_src11();
    init_constant8();
    init_linear();
    init_point();
  }
});

// node_modules/d3-shape/src/area.js
var init_area7 = __esm({
  "node_modules/d3-shape/src/area.js"() {
    init_src11();
    init_constant8();
    init_linear();
    init_line4();
    init_point();
  }
});

// node_modules/d3-shape/src/descending.js
var init_descending3 = __esm({
  "node_modules/d3-shape/src/descending.js"() {
  }
});

// node_modules/d3-shape/src/identity.js
var init_identity10 = __esm({
  "node_modules/d3-shape/src/identity.js"() {
  }
});

// node_modules/d3-shape/src/pie.js
var init_pie = __esm({
  "node_modules/d3-shape/src/pie.js"() {
    init_constant8();
    init_descending3();
    init_identity10();
    init_math6();
  }
});

// node_modules/d3-shape/src/curve/radial.js
function Radial(curve) {
  this._curve = curve;
}
function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }
  radial._curve = curve;
  return radial;
}
var curveRadialLinear;
var init_radial = __esm({
  "node_modules/d3-shape/src/curve/radial.js"() {
    init_linear();
    curveRadialLinear = curveRadial(linear_default);
    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a3, r2) {
        this._curve.point(r2 * Math.sin(a3), r2 * -Math.cos(a3));
      }
    };
  }
});

// node_modules/d3-shape/src/lineRadial.js
var init_lineRadial = __esm({
  "node_modules/d3-shape/src/lineRadial.js"() {
    init_radial();
    init_line4();
  }
});

// node_modules/d3-shape/src/areaRadial.js
var init_areaRadial = __esm({
  "node_modules/d3-shape/src/areaRadial.js"() {
    init_radial();
    init_area7();
    init_lineRadial();
  }
});

// node_modules/d3-shape/src/pointRadial.js
var init_pointRadial = __esm({
  "node_modules/d3-shape/src/pointRadial.js"() {
  }
});

// node_modules/d3-shape/src/array.js
var slice4;
var init_array4 = __esm({
  "node_modules/d3-shape/src/array.js"() {
    slice4 = Array.prototype.slice;
  }
});

// node_modules/d3-shape/src/link/index.js
function linkSource(d2) {
  return d2.source;
}
function linkTarget(d2) {
  return d2.target;
}
function link4(curve) {
  var source = linkSource, target = linkTarget, x4 = x2, y4 = y2, context = null;
  function link5() {
    var buffer, argv = slice4.call(arguments), s3 = source.apply(this, argv), t2 = target.apply(this, argv);
    if (!context)
      context = buffer = path_default6();
    curve(context, +x4.apply(this, (argv[0] = s3, argv)), +y4.apply(this, argv), +x4.apply(this, (argv[0] = t2, argv)), +y4.apply(this, argv));
    if (buffer)
      return context = null, buffer + "" || null;
  }
  link5.source = function(_2) {
    return arguments.length ? (source = _2, link5) : source;
  };
  link5.target = function(_2) {
    return arguments.length ? (target = _2, link5) : target;
  };
  link5.x = function(_2) {
    return arguments.length ? (x4 = typeof _2 === "function" ? _2 : constant_default7(+_2), link5) : x4;
  };
  link5.y = function(_2) {
    return arguments.length ? (y4 = typeof _2 === "function" ? _2 : constant_default7(+_2), link5) : y4;
  };
  link5.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, link5) : context;
  };
  return link5;
}
function curveHorizontal(context, x011, y011, x16, y16) {
  context.moveTo(x011, y011);
  context.bezierCurveTo(x011 = (x011 + x16) / 2, y011, x011, y16, x16, y16);
}
function linkHorizontal() {
  return link4(curveHorizontal);
}
var init_link = __esm({
  "node_modules/d3-shape/src/link/index.js"() {
    init_src11();
    init_array4();
    init_constant8();
    init_point();
    init_pointRadial();
  }
});

// node_modules/d3-shape/src/symbol/circle.js
var init_circle7 = __esm({
  "node_modules/d3-shape/src/symbol/circle.js"() {
    init_math6();
  }
});

// node_modules/d3-shape/src/symbol/cross.js
var init_cross3 = __esm({
  "node_modules/d3-shape/src/symbol/cross.js"() {
  }
});

// node_modules/d3-shape/src/symbol/diamond.js
var tan30, tan30_2;
var init_diamond = __esm({
  "node_modules/d3-shape/src/symbol/diamond.js"() {
    tan30 = Math.sqrt(1 / 3);
    tan30_2 = tan30 * 2;
  }
});

// node_modules/d3-shape/src/symbol/star.js
var kr, kx2, ky;
var init_star = __esm({
  "node_modules/d3-shape/src/symbol/star.js"() {
    init_math6();
    kr = Math.sin(pi7 / 10) / Math.sin(7 * pi7 / 10);
    kx2 = Math.sin(tau7 / 10) * kr;
    ky = -Math.cos(tau7 / 10) * kr;
  }
});

// node_modules/d3-shape/src/symbol/square.js
var init_square2 = __esm({
  "node_modules/d3-shape/src/symbol/square.js"() {
  }
});

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt33;
var init_triangle = __esm({
  "node_modules/d3-shape/src/symbol/triangle.js"() {
    sqrt33 = Math.sqrt(3);
  }
});

// node_modules/d3-shape/src/symbol/wye.js
var s2, k3, a2;
var init_wye = __esm({
  "node_modules/d3-shape/src/symbol/wye.js"() {
    s2 = Math.sqrt(3) / 2;
    k3 = 1 / Math.sqrt(12);
    a2 = (k3 / 2 + 1) * 3;
  }
});

// node_modules/d3-shape/src/symbol.js
var init_symbol = __esm({
  "node_modules/d3-shape/src/symbol.js"() {
    init_src11();
    init_circle7();
    init_cross3();
    init_diamond();
    init_star();
    init_square2();
    init_triangle();
    init_wye();
    init_constant8();
  }
});

// node_modules/d3-shape/src/noop.js
function noop_default2() {
}
var init_noop5 = __esm({
  "node_modules/d3-shape/src/noop.js"() {
  }
});

// node_modules/d3-shape/src/curve/basis.js
function point(that, x4, y4) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x4) / 6, (that._y0 + 4 * that._y1 + y4) / 6);
}
function Basis(context) {
  this._context = context;
}
var init_basis = __esm({
  "node_modules/d3-shape/src/curve/basis.js"() {
    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3:
            point(this, this._x1, this._y1);
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
          default:
            point(this, x4, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = x4;
        this._y0 = this._y1, this._y1 = y4;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
var init_basisClosed = __esm({
  "node_modules/d3-shape/src/curve/basisClosed.js"() {
    init_noop5();
    init_basis();
    BasisClosed.prototype = {
      areaStart: noop_default2,
      areaEnd: noop_default2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x2 = x4, this._y2 = y4;
            break;
          case 1:
            this._point = 2;
            this._x3 = x4, this._y3 = y4;
            break;
          case 2:
            this._point = 3;
            this._x4 = x4, this._y4 = y4;
            this._context.moveTo((this._x0 + 4 * this._x1 + x4) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
            break;
          default:
            point(this, x4, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = x4;
        this._y0 = this._y1, this._y1 = y4;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
var init_basisOpen = __esm({
  "node_modules/d3-shape/src/curve/basisOpen.js"() {
    init_basis();
    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            var x011 = (this._x0 + 4 * this._x1 + x4) / 6, y011 = (this._y0 + 4 * this._y1 + y4) / 6;
            this._line ? this._context.lineTo(x011, y011) : this._context.moveTo(x011, y011);
            break;
          case 3:
            this._point = 4;
          default:
            point(this, x4, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = x4;
        this._y0 = this._y1, this._y1 = y4;
      }
    };
  }
});

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
var bundle_default;
var init_bundle = __esm({
  "node_modules/d3-shape/src/curve/bundle.js"() {
    init_basis();
    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x4 = this._x, y4 = this._y, j2 = x4.length - 1;
        if (j2 > 0) {
          var x011 = x4[0], y011 = y4[0], dx = x4[j2] - x011, dy = y4[j2] - y011, i2 = -1, t2;
          while (++i2 <= j2) {
            t2 = i2 / j2;
            this._basis.point(this._beta * x4[i2] + (1 - this._beta) * (x011 + t2 * dx), this._beta * y4[i2] + (1 - this._beta) * (y011 + t2 * dy));
          }
        }
        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x4, y4) {
        this._x.push(+x4);
        this._y.push(+y4);
      }
    };
    bundle_default = function custom3(beta) {
      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }
      bundle.beta = function(beta2) {
        return custom3(+beta2);
      };
      return bundle;
    }(0.85);
  }
});

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x4, y4) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x4), that._y2 + that._k * (that._y1 - y4), that._x2, that._y2);
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinal_default;
var init_cardinal = __esm({
  "node_modules/d3-shape/src/curve/cardinal.js"() {
    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            point2(this, this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
            break;
          case 1:
            this._point = 2;
            this._x1 = x4, this._y1 = y4;
            break;
          case 2:
            this._point = 3;
          default:
            point2(this, x4, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    cardinal_default = function custom4(tension) {
      function cardinal(context) {
        return new Cardinal(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom4(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinalClosed_default;
var init_cardinalClosed = __esm({
  "node_modules/d3-shape/src/curve/cardinalClosed.js"() {
    init_noop5();
    init_cardinal();
    CardinalClosed.prototype = {
      areaStart: noop_default2,
      areaEnd: noop_default2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x4, this._y3 = y4;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x4, this._y4 = y4);
            break;
          case 2:
            this._point = 3;
            this._x5 = x4, this._y5 = y4;
            break;
          default:
            point2(this, x4, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    cardinalClosed_default = function custom5(tension) {
      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom5(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
var cardinalOpen_default;
var init_cardinalOpen = __esm({
  "node_modules/d3-shape/src/curve/cardinalOpen.js"() {
    init_cardinal();
    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point2(this, x4, y4);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    cardinalOpen_default = function custom6(tension) {
      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom6(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x4, y4) {
  var x16 = that._x1, y16 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon10) {
    var a3 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x16 = (x16 * a3 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2;
    y16 = (y16 * a3 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon10) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b2 + that._x1 * that._l23_2a - x4 * that._l12_2a) / m2;
    y22 = (y22 * b2 + that._y1 * that._l23_2a - y4 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x16, y16, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRom_default;
var init_catmullRom = __esm({
  "node_modules/d3-shape/src/curve/catmullRom.js"() {
    init_math6();
    init_cardinal();
    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            this.point(this._x2, this._y2);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        if (this._point) {
          var x23 = this._x2 - x4, y23 = this._y2 - y4;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
          default:
            point3(this, x4, y4);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    catmullRom_default = function custom7(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom7(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRomClosed_default;
var init_catmullRomClosed = __esm({
  "node_modules/d3-shape/src/curve/catmullRomClosed.js"() {
    init_cardinalClosed();
    init_noop5();
    init_catmullRom();
    CatmullRomClosed.prototype = {
      areaStart: noop_default2,
      areaEnd: noop_default2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        if (this._point) {
          var x23 = this._x2 - x4, y23 = this._y2 - y4;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x4, this._y3 = y4;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x4, this._y4 = y4);
            break;
          case 2:
            this._point = 3;
            this._x5 = x4, this._y5 = y4;
            break;
          default:
            point3(this, x4, y4);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    catmullRomClosed_default = function custom8(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom8(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
var catmullRomOpen_default;
var init_catmullRomOpen = __esm({
  "node_modules/d3-shape/src/curve/catmullRomOpen.js"() {
    init_cardinalOpen();
    init_catmullRom();
    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        if (this._point) {
          var x23 = this._x2 - x4, y23 = this._y2 - y4;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point3(this, x4, y4);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
      }
    };
    catmullRomOpen_default = function custom9(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom9(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
var init_linearClosed = __esm({
  "node_modules/d3-shape/src/curve/linearClosed.js"() {
    init_noop5();
    LinearClosed.prototype = {
      areaStart: noop_default2,
      areaEnd: noop_default2,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point)
          this._context.closePath();
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        if (this._point)
          this._context.lineTo(x4, y4);
        else
          this._point = 1, this._context.moveTo(x4, y4);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/monotone.js
function sign5(x4) {
  return x4 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign5(s0) + sign5(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t2) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t2) / 2 : t2;
}
function point4(that, t0, t1) {
  var x011 = that._x0, y011 = that._y0, x16 = that._x1, y16 = that._y1, dx = (x16 - x011) / 3;
  that._context.bezierCurveTo(x011 + dx, y011 + dx * t0, x16 - dx, y16 - dx * t1, x16, y16);
}
function MonotoneX(context) {
  this._context = context;
}
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
function ReflectContext(context) {
  this._context = context;
}
var init_monotone = __esm({
  "node_modules/d3-shape/src/curve/monotone.js"() {
    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
          case 3:
            point4(this, this._t0, slope2(this, this._t0));
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x4, y4) {
        var t1 = NaN;
        x4 = +x4, y4 = +y4;
        if (x4 === this._x1 && y4 === this._y1)
          return;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            point4(this, slope2(this, t1 = slope3(this, x4, y4)), t1);
            break;
          default:
            point4(this, this._t0, t1 = slope3(this, x4, y4));
            break;
        }
        this._x0 = this._x1, this._x1 = x4;
        this._y0 = this._y1, this._y1 = y4;
        this._t0 = t1;
      }
    };
    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x4, y4) {
      MonotoneX.prototype.point.call(this, y4, x4);
    };
    ReflectContext.prototype = {
      moveTo: function(x4, y4) {
        this._context.moveTo(y4, x4);
      },
      closePath: function() {
        this._context.closePath();
      },
      lineTo: function(x4, y4) {
        this._context.lineTo(y4, x4);
      },
      bezierCurveTo: function(x16, y16, x22, y22, x4, y4) {
        this._context.bezierCurveTo(y16, x16, y22, x22, y4, x4);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
function controlPoints(x4) {
  var i2, n2 = x4.length - 1, m2, a3 = new Array(n2), b2 = new Array(n2), r2 = new Array(n2);
  a3[0] = 0, b2[0] = 2, r2[0] = x4[0] + 2 * x4[1];
  for (i2 = 1; i2 < n2 - 1; ++i2)
    a3[i2] = 1, b2[i2] = 4, r2[i2] = 4 * x4[i2] + 2 * x4[i2 + 1];
  a3[n2 - 1] = 2, b2[n2 - 1] = 7, r2[n2 - 1] = 8 * x4[n2 - 1] + x4[n2];
  for (i2 = 1; i2 < n2; ++i2)
    m2 = a3[i2] / b2[i2 - 1], b2[i2] -= m2, r2[i2] -= m2 * r2[i2 - 1];
  a3[n2 - 1] = r2[n2 - 1] / b2[n2 - 1];
  for (i2 = n2 - 2; i2 >= 0; --i2)
    a3[i2] = (r2[i2] - a3[i2 + 1]) / b2[i2];
  b2[n2 - 1] = (x4[n2] + a3[n2 - 1]) / 2;
  for (i2 = 0; i2 < n2 - 1; ++i2)
    b2[i2] = 2 * x4[i2 + 1] - a3[i2 + 1];
  return [a3, b2];
}
var init_natural = __esm({
  "node_modules/d3-shape/src/curve/natural.js"() {
    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x4 = this._x, y4 = this._y, n2 = x4.length;
        if (n2) {
          this._line ? this._context.lineTo(x4[0], y4[0]) : this._context.moveTo(x4[0], y4[0]);
          if (n2 === 2) {
            this._context.lineTo(x4[1], y4[1]);
          } else {
            var px = controlPoints(x4), py = controlPoints(y4);
            for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x4[i1], y4[i1]);
            }
          }
        }
        if (this._line || this._line !== 0 && n2 === 1)
          this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x4, y4) {
        this._x.push(+x4);
        this._y.push(+y4);
      }
    };
  }
});

// node_modules/d3-shape/src/curve/step.js
function Step(context, t2) {
  this._context = context;
  this._t = t2;
}
var init_step = __esm({
  "node_modules/d3-shape/src/curve/step.js"() {
    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2)
          this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        if (this._line >= 0)
          this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x4, y4) {
        x4 = +x4, y4 = +y4;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
            break;
          case 1:
            this._point = 2;
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y4);
              this._context.lineTo(x4, y4);
            } else {
              var x16 = this._x * (1 - this._t) + x4 * this._t;
              this._context.lineTo(x16, this._y);
              this._context.lineTo(x16, y4);
            }
            break;
          }
        }
        this._x = x4, this._y = y4;
      }
    };
  }
});

// node_modules/d3-shape/src/offset/none.js
var init_none = __esm({
  "node_modules/d3-shape/src/offset/none.js"() {
  }
});

// node_modules/d3-shape/src/order/none.js
var init_none2 = __esm({
  "node_modules/d3-shape/src/order/none.js"() {
  }
});

// node_modules/d3-shape/src/stack.js
var init_stack = __esm({
  "node_modules/d3-shape/src/stack.js"() {
    init_array4();
    init_constant8();
    init_none();
    init_none2();
  }
});

// node_modules/d3-shape/src/offset/expand.js
var init_expand = __esm({
  "node_modules/d3-shape/src/offset/expand.js"() {
    init_none();
  }
});

// node_modules/d3-shape/src/offset/diverging.js
var init_diverging = __esm({
  "node_modules/d3-shape/src/offset/diverging.js"() {
  }
});

// node_modules/d3-shape/src/offset/silhouette.js
var init_silhouette = __esm({
  "node_modules/d3-shape/src/offset/silhouette.js"() {
    init_none();
  }
});

// node_modules/d3-shape/src/offset/wiggle.js
var init_wiggle = __esm({
  "node_modules/d3-shape/src/offset/wiggle.js"() {
    init_none();
  }
});

// node_modules/d3-shape/src/order/appearance.js
var init_appearance = __esm({
  "node_modules/d3-shape/src/order/appearance.js"() {
    init_none2();
  }
});

// node_modules/d3-shape/src/order/ascending.js
var init_ascending3 = __esm({
  "node_modules/d3-shape/src/order/ascending.js"() {
    init_none2();
  }
});

// node_modules/d3-shape/src/order/descending.js
var init_descending4 = __esm({
  "node_modules/d3-shape/src/order/descending.js"() {
    init_ascending3();
  }
});

// node_modules/d3-shape/src/order/insideOut.js
var init_insideOut = __esm({
  "node_modules/d3-shape/src/order/insideOut.js"() {
    init_appearance();
    init_ascending3();
  }
});

// node_modules/d3-shape/src/order/reverse.js
var init_reverse3 = __esm({
  "node_modules/d3-shape/src/order/reverse.js"() {
    init_none2();
  }
});

// node_modules/d3-shape/src/index.js
var init_src12 = __esm({
  "node_modules/d3-shape/src/index.js"() {
    init_arc();
    init_area7();
    init_line4();
    init_pie();
    init_areaRadial();
    init_lineRadial();
    init_pointRadial();
    init_link();
    init_symbol();
    init_circle7();
    init_cross3();
    init_diamond();
    init_square2();
    init_star();
    init_triangle();
    init_wye();
    init_basisClosed();
    init_basisOpen();
    init_basis();
    init_bundle();
    init_cardinalClosed();
    init_cardinalOpen();
    init_cardinal();
    init_catmullRomClosed();
    init_catmullRomOpen();
    init_catmullRom();
    init_linearClosed();
    init_linear();
    init_monotone();
    init_natural();
    init_step();
    init_stack();
    init_expand();
    init_diverging();
    init_none();
    init_silhouette();
    init_wiggle();
    init_appearance();
    init_ascending3();
    init_descending4();
    init_insideOut();
    init_none2();
    init_reverse3();
  }
});

// node_modules/d3-sankey/src/sankeyLinkHorizontal.js
function horizontalSource(d2) {
  return [d2.source.x1, d2.y0];
}
function horizontalTarget(d2) {
  return [d2.target.x0, d2.y1];
}
function sankeyLinkHorizontal_default() {
  return linkHorizontal().source(horizontalSource).target(horizontalTarget);
}
var init_sankeyLinkHorizontal = __esm({
  "node_modules/d3-sankey/src/sankeyLinkHorizontal.js"() {
    init_src12();
  }
});

// node_modules/d3-sankey/src/index.js
var src_exports4 = {};
__export(src_exports4, {
  sankey: () => Sankey,
  sankeyCenter: () => center,
  sankeyJustify: () => justify,
  sankeyLeft: () => left,
  sankeyLinkHorizontal: () => sankeyLinkHorizontal_default,
  sankeyRight: () => right
});
var init_src13 = __esm({
  "node_modules/d3-sankey/src/index.js"() {
    init_sankey();
    init_align();
    init_sankeyLinkHorizontal();
  }
});

// node_modules/@antv/data-set/lib/transform/diagram/sankey.js
var require_sankey = __commonJS({
  "node_modules/@antv/data-set/lib/transform/diagram/sankey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm(), esm_exports);
    var d3_sankey_1 = (init_src13(), src_exports4);
    var data_set_1 = require_data_set();
    var ALIGN_METHOD = {
      sankeyLeft: d3_sankey_1.sankeyLeft,
      sankeyRight: d3_sankey_1.sankeyRight,
      sankeyCenter: d3_sankey_1.sankeyCenter,
      sankeyJustify: d3_sankey_1.sankeyJustify
    };
    var DEFAULT_OPTIONS = {
      value: function(node) {
        return node.value;
      },
      source: function(edge) {
        return edge.source;
      },
      target: function(edge) {
        return edge.target;
      },
      nodeAlign: "sankeyJustify",
      nodeWidth: 0.02,
      nodePadding: 0.02,
      sort: void 0
    };
    function transform(dv, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var nodeAlign = null;
      if (util_1.isString(options.nodeAlign)) {
        nodeAlign = ALIGN_METHOD[options.nodeAlign];
      } else if (util_1.isFunction(options.nodeAlign)) {
        nodeAlign = options.nodeAlign;
      }
      var sankeyProcessor = d3_sankey_1.sankey().nodeSort(options.sort).links(function(d2) {
        return d2.edges;
      }).nodeWidth(options.nodeWidth).nodePadding(options.nodePadding).extent([
        [0, 0],
        [1, 1]
      ]);
      if (util_1.isFunction(options.nodeId)) {
        sankeyProcessor.nodeId(options.nodeId);
      }
      if (nodeAlign) {
        sankeyProcessor.nodeAlign(nodeAlign);
      }
      sankeyProcessor(dv);
      dv.nodes.forEach(function(node) {
        var x011 = node.x0, x16 = node.x1, y011 = node.y0, y16 = node.y1;
        node.x = [x011, x16, x16, x011];
        node.y = [y011, y011, y16, y16];
      });
      dv.edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var sx = source.x1;
        var tx = target.x0;
        edge.x = [sx, sx, tx, tx];
        var offset = edge.width / 2;
        edge.y = [edge.y0 + offset, edge.y0 - offset, edge.y1 + offset, edge.y1 - offset];
      });
    }
    data_set_1.DataSet.registerTransform("diagram.sankey", transform);
    data_set_1.DataSet.registerTransform("sankey", transform);
  }
});

// node_modules/d3-voronoi/src/constant.js
function constant_default8(x4) {
  return function() {
    return x4;
  };
}
var init_constant9 = __esm({
  "node_modules/d3-voronoi/src/constant.js"() {
  }
});

// node_modules/d3-voronoi/src/point.js
function x3(d2) {
  return d2[0];
}
function y3(d2) {
  return d2[1];
}
var init_point2 = __esm({
  "node_modules/d3-voronoi/src/point.js"() {
  }
});

// node_modules/d3-voronoi/src/RedBlackTree.js
function RedBlackTree() {
  this._ = null;
}
function RedBlackNode(node) {
  node.U = node.C = node.L = node.R = node.P = node.N = null;
}
function RedBlackRotateLeft(tree, node) {
  var p2 = node, q2 = node.R, parent = p2.U;
  if (parent) {
    if (parent.L === p2)
      parent.L = q2;
    else
      parent.R = q2;
  } else {
    tree._ = q2;
  }
  q2.U = parent;
  p2.U = q2;
  p2.R = q2.L;
  if (p2.R)
    p2.R.U = p2;
  q2.L = p2;
}
function RedBlackRotateRight(tree, node) {
  var p2 = node, q2 = node.L, parent = p2.U;
  if (parent) {
    if (parent.L === p2)
      parent.L = q2;
    else
      parent.R = q2;
  } else {
    tree._ = q2;
  }
  q2.U = parent;
  p2.U = q2;
  p2.L = q2.R;
  if (p2.L)
    p2.L.U = p2;
  q2.R = p2;
}
function RedBlackFirst(node) {
  while (node.L)
    node = node.L;
  return node;
}
var RedBlackTree_default;
var init_RedBlackTree = __esm({
  "node_modules/d3-voronoi/src/RedBlackTree.js"() {
    RedBlackTree.prototype = {
      constructor: RedBlackTree,
      insert: function(after, node) {
        var parent, grandpa, uncle;
        if (after) {
          node.P = after;
          node.N = after.N;
          if (after.N)
            after.N.P = node;
          after.N = node;
          if (after.R) {
            after = after.R;
            while (after.L)
              after = after.L;
            after.L = node;
          } else {
            after.R = node;
          }
          parent = after;
        } else if (this._) {
          after = RedBlackFirst(this._);
          node.P = null;
          node.N = after;
          after.P = after.L = node;
          parent = after;
        } else {
          node.P = node.N = null;
          this._ = node;
          parent = null;
        }
        node.L = node.R = null;
        node.U = parent;
        node.C = true;
        after = node;
        while (parent && parent.C) {
          grandpa = parent.U;
          if (parent === grandpa.L) {
            uncle = grandpa.R;
            if (uncle && uncle.C) {
              parent.C = uncle.C = false;
              grandpa.C = true;
              after = grandpa;
            } else {
              if (after === parent.R) {
                RedBlackRotateLeft(this, parent);
                after = parent;
                parent = after.U;
              }
              parent.C = false;
              grandpa.C = true;
              RedBlackRotateRight(this, grandpa);
            }
          } else {
            uncle = grandpa.L;
            if (uncle && uncle.C) {
              parent.C = uncle.C = false;
              grandpa.C = true;
              after = grandpa;
            } else {
              if (after === parent.L) {
                RedBlackRotateRight(this, parent);
                after = parent;
                parent = after.U;
              }
              parent.C = false;
              grandpa.C = true;
              RedBlackRotateLeft(this, grandpa);
            }
          }
          parent = after.U;
        }
        this._.C = false;
      },
      remove: function(node) {
        if (node.N)
          node.N.P = node.P;
        if (node.P)
          node.P.N = node.N;
        node.N = node.P = null;
        var parent = node.U, sibling, left2 = node.L, right2 = node.R, next, red;
        if (!left2)
          next = right2;
        else if (!right2)
          next = left2;
        else
          next = RedBlackFirst(right2);
        if (parent) {
          if (parent.L === node)
            parent.L = next;
          else
            parent.R = next;
        } else {
          this._ = next;
        }
        if (left2 && right2) {
          red = next.C;
          next.C = node.C;
          next.L = left2;
          left2.U = next;
          if (next !== right2) {
            parent = next.U;
            next.U = node.U;
            node = next.R;
            parent.L = node;
            next.R = right2;
            right2.U = next;
          } else {
            next.U = parent;
            parent = next;
            node = next.R;
          }
        } else {
          red = node.C;
          node = next;
        }
        if (node)
          node.U = parent;
        if (red)
          return;
        if (node && node.C) {
          node.C = false;
          return;
        }
        do {
          if (node === this._)
            break;
          if (node === parent.L) {
            sibling = parent.R;
            if (sibling.C) {
              sibling.C = false;
              parent.C = true;
              RedBlackRotateLeft(this, parent);
              sibling = parent.R;
            }
            if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
              if (!sibling.R || !sibling.R.C) {
                sibling.L.C = false;
                sibling.C = true;
                RedBlackRotateRight(this, sibling);
                sibling = parent.R;
              }
              sibling.C = parent.C;
              parent.C = sibling.R.C = false;
              RedBlackRotateLeft(this, parent);
              node = this._;
              break;
            }
          } else {
            sibling = parent.L;
            if (sibling.C) {
              sibling.C = false;
              parent.C = true;
              RedBlackRotateRight(this, parent);
              sibling = parent.L;
            }
            if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
              if (!sibling.L || !sibling.L.C) {
                sibling.R.C = false;
                sibling.C = true;
                RedBlackRotateLeft(this, sibling);
                sibling = parent.L;
              }
              sibling.C = parent.C;
              parent.C = sibling.L.C = false;
              RedBlackRotateRight(this, parent);
              node = this._;
              break;
            }
          }
          sibling.C = true;
          node = parent;
          parent = parent.U;
        } while (!node.C);
        if (node)
          node.C = false;
      }
    };
    RedBlackTree_default = RedBlackTree;
  }
});

// node_modules/d3-voronoi/src/Edge.js
function createEdge(left2, right2, v0, v1) {
  var edge = [null, null], index2 = edges.push(edge) - 1;
  edge.left = left2;
  edge.right = right2;
  if (v0)
    setEdgeEnd(edge, left2, right2, v0);
  if (v1)
    setEdgeEnd(edge, right2, left2, v1);
  cells[left2.index].halfedges.push(index2);
  cells[right2.index].halfedges.push(index2);
  return edge;
}
function createBorderEdge(left2, v0, v1) {
  var edge = [v0, v1];
  edge.left = left2;
  return edge;
}
function setEdgeEnd(edge, left2, right2, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left2;
    edge.right = right2;
  } else if (edge.left === right2) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}
function clipEdge(edge, x011, y011, x16, y16) {
  var a3 = edge[0], b2 = edge[1], ax = a3[0], ay = a3[1], bx = b2[0], by = b2[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x011 - ax;
  if (!dx && r2 > 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  } else if (dx > 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  }
  r2 = x16 - ax;
  if (!dx && r2 < 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  } else if (dx > 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  }
  r2 = y011 - ay;
  if (!dy && r2 > 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  } else if (dy > 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  }
  r2 = y16 - ay;
  if (!dy && r2 < 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t1)
      return;
    if (r2 > t0)
      t0 = r2;
  } else if (dy > 0) {
    if (r2 < t0)
      return;
    if (r2 < t1)
      t1 = r2;
  }
  if (!(t0 > 0) && !(t1 < 1))
    return true;
  if (t0 > 0)
    edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1)
    edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}
function connectEdge(edge, x011, y011, x16, y16) {
  var v1 = edge[1];
  if (v1)
    return true;
  var v0 = edge[0], left2 = edge.left, right2 = edge.right, lx = left2[0], ly = left2[1], rx = right2[0], ry = right2[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
  if (ry === ly) {
    if (fx < x011 || fx >= x16)
      return;
    if (lx > rx) {
      if (!v0)
        v0 = [fx, y011];
      else if (v0[1] >= y16)
        return;
      v1 = [fx, y16];
    } else {
      if (!v0)
        v0 = [fx, y16];
      else if (v0[1] < y011)
        return;
      v1 = [fx, y011];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0)
          v0 = [(y011 - fb) / fm, y011];
        else if (v0[1] >= y16)
          return;
        v1 = [(y16 - fb) / fm, y16];
      } else {
        if (!v0)
          v0 = [(y16 - fb) / fm, y16];
        else if (v0[1] < y011)
          return;
        v1 = [(y011 - fb) / fm, y011];
      }
    } else {
      if (ly < ry) {
        if (!v0)
          v0 = [x011, fm * x011 + fb];
        else if (v0[0] >= x16)
          return;
        v1 = [x16, fm * x16 + fb];
      } else {
        if (!v0)
          v0 = [x16, fm * x16 + fb];
        else if (v0[0] < x011)
          return;
        v1 = [x011, fm * x011 + fb];
      }
    }
  }
  edge[0] = v0;
  edge[1] = v1;
  return true;
}
function clipEdges(x011, y011, x16, y16) {
  var i2 = edges.length, edge;
  while (i2--) {
    if (!connectEdge(edge = edges[i2], x011, y011, x16, y16) || !clipEdge(edge, x011, y011, x16, y16) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon11 || Math.abs(edge[0][1] - edge[1][1]) > epsilon11)) {
      delete edges[i2];
    }
  }
}
var init_Edge = __esm({
  "node_modules/d3-voronoi/src/Edge.js"() {
    init_Diagram();
  }
});

// node_modules/d3-voronoi/src/Cell.js
function createCell(site) {
  return cells[site.index] = {
    site,
    halfedges: []
  };
}
function cellHalfedgeAngle(cell, edge) {
  var site = cell.site, va = edge.left, vb = edge.right;
  if (site === vb)
    vb = va, va = site;
  if (vb)
    return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va)
    va = edge[1], vb = edge[0];
  else
    va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}
function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}
function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}
function sortCellHalfedges() {
  for (var i2 = 0, n2 = cells.length, cell, halfedges, j2, m2; i2 < n2; ++i2) {
    if ((cell = cells[i2]) && (m2 = (halfedges = cell.halfedges).length)) {
      var index2 = new Array(m2), array3 = new Array(m2);
      for (j2 = 0; j2 < m2; ++j2)
        index2[j2] = j2, array3[j2] = cellHalfedgeAngle(cell, edges[halfedges[j2]]);
      index2.sort(function(i3, j3) {
        return array3[j3] - array3[i3];
      });
      for (j2 = 0; j2 < m2; ++j2)
        array3[j2] = halfedges[index2[j2]];
      for (j2 = 0; j2 < m2; ++j2)
        halfedges[j2] = array3[j2];
    }
  }
}
function clipCells(x011, y011, x16, y16) {
  var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon11 || Math.abs(endY - startY) > epsilon11) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x011) < epsilon11 && y16 - endY > epsilon11 ? [x011, Math.abs(startX - x011) < epsilon11 ? startY : y16] : Math.abs(endY - y16) < epsilon11 && x16 - endX > epsilon11 ? [Math.abs(startY - y16) < epsilon11 ? startX : x16, y16] : Math.abs(endX - x16) < epsilon11 && endY - y011 > epsilon11 ? [x16, Math.abs(startX - x16) < epsilon11 ? startY : y011] : Math.abs(endY - y011) < epsilon11 && endX - x011 > epsilon11 ? [Math.abs(startY - y011) < epsilon11 ? startX : x011, y011] : null)) - 1);
          ++nHalfedges;
        }
      }
      if (nHalfedges)
        cover = false;
    }
  }
  if (cover) {
    var dx, dy, d2, dc = Infinity;
    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x011;
        dy = site[1] - y011;
        d2 = dx * dx + dy * dy;
        if (d2 < dc)
          dc = d2, cover = cell;
      }
    }
    if (cover) {
      var v00 = [x011, y011], v01 = [x011, y16], v11 = [x16, y16], v10 = [x16, y011];
      cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);
    }
  }
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}
var init_Cell = __esm({
  "node_modules/d3-voronoi/src/Cell.js"() {
    init_Edge();
    init_Diagram();
  }
});

// node_modules/d3-voronoi/src/Circle.js
function Circle() {
  RedBlackNode(this);
  this.x = this.y = this.arc = this.site = this.cy = null;
}
function attachCircle(arc) {
  var lArc = arc.P, rArc = arc.N;
  if (!lArc || !rArc)
    return;
  var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
  if (lSite === rSite)
    return;
  var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
  var d2 = 2 * (ax * cy - ay * cx);
  if (d2 >= -epsilon25)
    return;
  var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x4 = (cy * ha - ay * hc) / d2, y4 = (ax * hc - cx * ha) / d2;
  var circle4 = circlePool.pop() || new Circle();
  circle4.arc = arc;
  circle4.site = cSite;
  circle4.x = x4 + bx;
  circle4.y = (circle4.cy = y4 + by) + Math.sqrt(x4 * x4 + y4 * y4);
  arc.circle = circle4;
  var before = null, node = circles._;
  while (node) {
    if (circle4.y < node.y || circle4.y === node.y && circle4.x <= node.x) {
      if (node.L)
        node = node.L;
      else {
        before = node.P;
        break;
      }
    } else {
      if (node.R)
        node = node.R;
      else {
        before = node;
        break;
      }
    }
  }
  circles.insert(before, circle4);
  if (!before)
    firstCircle = circle4;
}
function detachCircle(arc) {
  var circle4 = arc.circle;
  if (circle4) {
    if (!circle4.P)
      firstCircle = circle4.N;
    circles.remove(circle4);
    circlePool.push(circle4);
    RedBlackNode(circle4);
    arc.circle = null;
  }
}
var circlePool, firstCircle;
var init_Circle = __esm({
  "node_modules/d3-voronoi/src/Circle.js"() {
    init_RedBlackTree();
    init_Diagram();
    circlePool = [];
  }
});

// node_modules/d3-voronoi/src/Beach.js
function Beach() {
  RedBlackNode(this);
  this.edge = this.site = this.circle = null;
}
function createBeach(site) {
  var beach = beachPool.pop() || new Beach();
  beach.site = site;
  return beach;
}
function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}
function removeBeach(beach) {
  var circle4 = beach.circle, x4 = circle4.x, y4 = circle4.cy, vertex = [x4, y4], previous = beach.P, next = beach.N, disappearing = [beach];
  detachBeach(beach);
  var lArc = previous;
  while (lArc.circle && Math.abs(x4 - lArc.circle.x) < epsilon11 && Math.abs(y4 - lArc.circle.cy) < epsilon11) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }
  disappearing.unshift(lArc);
  detachCircle(lArc);
  var rArc = next;
  while (rArc.circle && Math.abs(x4 - rArc.circle.x) < epsilon11 && Math.abs(y4 - rArc.circle.cy) < epsilon11) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }
  disappearing.push(rArc);
  detachCircle(rArc);
  var nArcs = disappearing.length, iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }
  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function addBeach(site) {
  var x4 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
  while (node) {
    dxl = leftBreakPoint(node, directrix) - x4;
    if (dxl > epsilon11)
      node = node.L;
    else {
      dxr = x4 - rightBreakPoint(node, directrix);
      if (dxr > epsilon11) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon11) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon11) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }
  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);
  if (!lArc && !rArc)
    return;
  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }
  if (!rArc) {
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }
  detachCircle(lArc);
  detachCircle(rArc);
  var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d2 = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d2 + ax, (bx * hc - cx * hb) / d2 + ay];
  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function leftBreakPoint(arc, directrix) {
  var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
  if (!pby2)
    return rfocx;
  var lArc = arc.P;
  if (!lArc)
    return -Infinity;
  site = lArc.site;
  var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
  if (!plby2)
    return lfocx;
  var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b2 = hl / plby2;
  if (aby2)
    return (-b2 + Math.sqrt(b2 * b2 - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
  return (rfocx + lfocx) / 2;
}
function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc)
    return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}
var beachPool;
var init_Beach = __esm({
  "node_modules/d3-voronoi/src/Beach.js"() {
    init_RedBlackTree();
    init_Cell();
    init_Circle();
    init_Edge();
    init_Diagram();
    beachPool = [];
  }
});

// node_modules/d3-voronoi/src/Diagram.js
function triangleArea(a3, b2, c2) {
  return (a3[0] - c2[0]) * (b2[1] - a3[1]) - (a3[0] - b2[0]) * (c2[1] - a3[1]);
}
function lexicographic(a3, b2) {
  return b2[1] - a3[1] || b2[0] - a3[0];
}
function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(), x4, y4, circle4;
  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree_default();
  circles = new RedBlackTree_default();
  while (true) {
    circle4 = firstCircle;
    if (site && (!circle4 || site[1] < circle4.y || site[1] === circle4.y && site[0] < circle4.x)) {
      if (site[0] !== x4 || site[1] !== y4) {
        addBeach(site);
        x4 = site[0], y4 = site[1];
      }
      site = sites.pop();
    } else if (circle4) {
      removeBeach(circle4.arc);
    } else {
      break;
    }
  }
  sortCellHalfedges();
  if (extent) {
    var x011 = +extent[0][0], y011 = +extent[0][1], x16 = +extent[1][0], y16 = +extent[1][1];
    clipEdges(x011, y011, x16, y16);
    clipCells(x011, y011, x16, y16);
  }
  this.edges = edges;
  this.cells = cells;
  beaches = circles = edges = cells = null;
}
var epsilon11, epsilon25, beaches, cells, circles, edges;
var init_Diagram = __esm({
  "node_modules/d3-voronoi/src/Diagram.js"() {
    init_Beach();
    init_Cell();
    init_Circle();
    init_Edge();
    init_RedBlackTree();
    epsilon11 = 1e-6;
    epsilon25 = 1e-12;
    Diagram.prototype = {
      constructor: Diagram,
      polygons: function() {
        var edges2 = this.edges;
        return this.cells.map(function(cell) {
          var polygon = cell.halfedges.map(function(i2) {
            return cellHalfedgeStart(cell, edges2[i2]);
          });
          polygon.data = cell.site.data;
          return polygon;
        });
      },
      triangles: function() {
        var triangles = [], edges2 = this.edges;
        this.cells.forEach(function(cell, i2) {
          if (!(m2 = (halfedges = cell.halfedges).length))
            return;
          var site = cell.site, halfedges, j2 = -1, m2, s0, e1 = edges2[halfedges[m2 - 1]], s1 = e1.left === site ? e1.right : e1.left;
          while (++j2 < m2) {
            s0 = s1;
            e1 = edges2[halfedges[j2]];
            s1 = e1.left === site ? e1.right : e1.left;
            if (s0 && s1 && i2 < s0.index && i2 < s1.index && triangleArea(site, s0, s1) < 0) {
              triangles.push([site.data, s0.data, s1.data]);
            }
          }
        });
        return triangles;
      },
      links: function() {
        return this.edges.filter(function(edge) {
          return edge.right;
        }).map(function(edge) {
          return {
            source: edge.left.data,
            target: edge.right.data
          };
        });
      },
      find: function(x4, y4, radius) {
        var that = this, i0, i1 = that._found || 0, n2 = that.cells.length, cell;
        while (!(cell = that.cells[i1]))
          if (++i1 >= n2)
            return null;
        var dx = x4 - cell.site[0], dy = y4 - cell.site[1], d2 = dx * dx + dy * dy;
        do {
          cell = that.cells[i0 = i1], i1 = null;
          cell.halfedges.forEach(function(e3) {
            var edge = that.edges[e3], v2 = edge.left;
            if ((v2 === cell.site || !v2) && !(v2 = edge.right))
              return;
            var vx = x4 - v2[0], vy = y4 - v2[1], v22 = vx * vx + vy * vy;
            if (v22 < d2)
              d2 = v22, i1 = v2.index;
          });
        } while (i1 !== null);
        that._found = i0;
        return radius == null || d2 <= radius * radius ? cell.site : null;
      }
    };
  }
});

// node_modules/d3-voronoi/src/voronoi.js
function voronoi_default() {
  var x4 = x3, y4 = y3, extent = null;
  function voronoi(data) {
    return new Diagram(data.map(function(d2, i2) {
      var s3 = [Math.round(x4(d2, i2, data) / epsilon11) * epsilon11, Math.round(y4(d2, i2, data) / epsilon11) * epsilon11];
      s3.index = i2;
      s3.data = d2;
      return s3;
    }), extent);
  }
  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };
  voronoi.links = function(data) {
    return voronoi(data).links();
  };
  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };
  voronoi.x = function(_2) {
    return arguments.length ? (x4 = typeof _2 === "function" ? _2 : constant_default8(+_2), voronoi) : x4;
  };
  voronoi.y = function(_2) {
    return arguments.length ? (y4 = typeof _2 === "function" ? _2 : constant_default8(+_2), voronoi) : y4;
  };
  voronoi.extent = function(_2) {
    return arguments.length ? (extent = _2 == null ? null : [[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };
  voronoi.size = function(_2) {
    return arguments.length ? (extent = _2 == null ? null : [[0, 0], [+_2[0], +_2[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };
  return voronoi;
}
var init_voronoi = __esm({
  "node_modules/d3-voronoi/src/voronoi.js"() {
    init_constant9();
    init_point2();
    init_Diagram();
  }
});

// node_modules/d3-voronoi/src/index.js
var src_exports5 = {};
__export(src_exports5, {
  voronoi: () => voronoi_default
});
var init_src14 = __esm({
  "node_modules/d3-voronoi/src/index.js"() {
    init_voronoi();
  }
});

// node_modules/@antv/data-set/lib/transform/diagram/voronoi.js
var require_voronoi = __commonJS({
  "node_modules/@antv/data-set/lib/transform/diagram/voronoi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var d3Voronoi = tslib_1.__importStar((init_src14(), src_exports5));
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var registerTransform = data_set_1.DataSet.registerTransform;
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      as: ["_x", "_y"]
    };
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var as = options.as;
      if (!util_1.isArray(as) || as.length !== 2) {
        throw new TypeError("Invalid as: must be an array with two strings!");
      }
      var xField = as[0];
      var yField = as[1];
      var fields = option_parser_1.getFields(options);
      if (!util_1.isArray(fields) || fields.length !== 2) {
        throw new TypeError("Invalid fields: must be an array with two strings!");
      }
      var x4 = fields[0];
      var y4 = fields[1];
      var rows = dataView.rows;
      var data = rows.map(function(row) {
        return [row[x4], row[y4]];
      });
      var voronoi = d3Voronoi.voronoi();
      if (options.extend) {
        voronoi.extent(options.extend);
      }
      if (options.size) {
        voronoi.size(options.size);
      }
      var polygons = voronoi(data).polygons();
      rows.forEach(function(row, i2) {
        var polygon = polygons[i2].filter(function(point5) {
          return !!point5;
        });
        row[xField] = polygon.map(function(point5) {
          return point5[0];
        });
        row[yField] = polygon.map(function(point5) {
          return point5[1];
        });
      });
    }
    registerTransform("diagram.voronoi", transform);
    registerTransform("voronoi", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/hierarchy/cluster.js
var require_cluster = __commonJS({
  "node_modules/@antv/data-set/lib/transform/hierarchy/cluster.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var d3Hierarchy = tslib_1.__importStar((init_src8(), src_exports2));
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      field: "value",
      size: [1, 1],
      nodeSize: null,
      separation: null,
      as: ["x", "y"]
    };
    function transform(dataView, options) {
      if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY || !dataView.root) {
        throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
      }
      var root = dataView.root;
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var as = options.as;
      if (!util_1.isArray(as) || as.length !== 2) {
        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
      }
      var field = void 0;
      try {
        field = option_parser_1.getField(options);
      } catch (e3) {
        console.warn(e3);
      }
      if (field) {
        root.sum(function(d2) {
          return d2[field];
        });
      }
      var clusterLayout = d3Hierarchy.cluster();
      clusterLayout.size(options.size);
      if (options.nodeSize) {
        clusterLayout.nodeSize(options.nodeSize);
      }
      if (options.separation) {
        clusterLayout.separation(options.separation);
      }
      clusterLayout(root);
      var x4 = as[0];
      var y4 = as[1];
      root.each(function(node) {
        node[x4] = node.x;
        node[y4] = node.y;
      });
    }
    data_set_1.DataSet.registerTransform("hierarchy.cluster", transform);
    data_set_1.DataSet.registerTransform("dendrogram", transform);
  }
});

// node_modules/@antv/hierarchy/lib/util.js
var require_util3 = __commonJS({
  "node_modules/@antv/hierarchy/lib/util.js"(exports, module) {
    var _require = (init_esm(), esm_exports);
    var mix = _require.mix;
    module.exports = {
      assign: mix
    };
  }
});

// node_modules/@antv/hierarchy/lib/layout/hierarchy.js
var require_hierarchy3 = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/hierarchy.js"(exports, module) {
    var util = require_util3();
    var PEM = 18;
    var DEFAULT_HEIGHT = PEM * 2;
    var DEFAULT_GAP = PEM;
    var DEFAULT_OPTIONS = {
      getId: function getId(d2) {
        return d2.id || d2.name;
      },
      getPreH: function getPreH(d2) {
        return d2.preH || 0;
      },
      getPreV: function getPreV(d2) {
        return d2.preV || 0;
      },
      getHGap: function getHGap(d2) {
        return d2.hgap || DEFAULT_GAP;
      },
      getVGap: function getVGap(d2) {
        return d2.vgap || DEFAULT_GAP;
      },
      getChildren: function getChildren(d2) {
        return d2.children;
      },
      getHeight: function getHeight(d2) {
        return d2.height || DEFAULT_HEIGHT;
      },
      getWidth: function getWidth(d2) {
        var label = d2.label || " ";
        return d2.width || label.split("").length * PEM;
      }
    };
    function Node3(data, options) {
      var me = this;
      me.vgap = me.hgap = 0;
      if (data instanceof Node3)
        return data;
      me.data = data;
      var hgap = options.getHGap(data);
      var vgap = options.getVGap(data);
      me.preH = options.getPreH(data);
      me.preV = options.getPreV(data);
      me.width = options.getWidth(data);
      me.height = options.getHeight(data);
      me.width += me.preH;
      me.height += me.preV;
      me.id = options.getId(data);
      me.x = me.y = 0;
      me.depth = 0;
      if (!me.children) {
        me.children = [];
      }
      me.addGap(hgap, vgap);
      return me;
    }
    util.assign(Node3.prototype, {
      isRoot: function isRoot() {
        return this.depth === 0;
      },
      isLeaf: function isLeaf() {
        return this.children.length === 0;
      },
      addGap: function addGap(hgap, vgap) {
        var me = this;
        me.hgap += hgap;
        me.vgap += vgap;
        me.width += 2 * hgap;
        me.height += 2 * vgap;
      },
      eachNode: function eachNode(callback) {
        var me = this;
        var nodes = [me];
        var current;
        while (current = nodes.shift()) {
          callback(current);
          nodes = current.children.concat(nodes);
        }
      },
      DFTraverse: function DFTraverse(callback) {
        this.eachNode(callback);
      },
      BFTraverse: function BFTraverse(callback) {
        var me = this;
        var nodes = [me];
        var current;
        while (current = nodes.shift()) {
          callback(current);
          nodes = nodes.concat(current.children);
        }
      },
      getBoundingBox: function getBoundingBox() {
        var bb = {
          left: Number.MAX_VALUE,
          top: Number.MAX_VALUE,
          width: 0,
          height: 0
        };
        this.eachNode(function(node) {
          bb.left = Math.min(bb.left, node.x);
          bb.top = Math.min(bb.top, node.y);
          bb.width = Math.max(bb.width, node.x + node.width);
          bb.height = Math.max(bb.height, node.y + node.height);
        });
        return bb;
      },
      translate: function translate(tx, ty) {
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        this.eachNode(function(node) {
          node.x += tx;
          node.y += ty;
          node.x += node.preH;
          node.y += node.preV;
        });
      },
      right2left: function right2left() {
        var me = this;
        var bb = me.getBoundingBox();
        me.eachNode(function(node) {
          node.x = node.x - (node.x - bb.left) * 2 - node.width;
        });
        me.translate(bb.width, 0);
      },
      bottom2top: function bottom2top() {
        var me = this;
        var bb = me.getBoundingBox();
        me.eachNode(function(node) {
          node.y = node.y - (node.y - bb.top) * 2 - node.height;
        });
        me.translate(0, bb.height);
      }
    });
    function hierarchy2(data, options, isolated) {
      if (options === void 0) {
        options = {};
      }
      options = util.assign({}, DEFAULT_OPTIONS, options);
      var root = new Node3(data, options);
      var nodes = [root];
      var node;
      if (!isolated && !data.collapsed) {
        while (node = nodes.shift()) {
          if (!node.data.collapsed) {
            var children = options.getChildren(node.data);
            var length2 = children ? children.length : 0;
            node.children = new Array(length2);
            if (children && length2) {
              for (var i2 = 0; i2 < length2; i2++) {
                var child = new Node3(children[i2], options);
                node.children[i2] = child;
                nodes.push(child);
                child.parent = node;
                child.depth = node.depth + 1;
              }
            }
          }
        }
      }
      return root;
    }
    module.exports = hierarchy2;
  }
});

// node_modules/@antv/hierarchy/lib/layout/base.js
var require_base = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/base.js"(exports, module) {
    var hierarchy2 = require_hierarchy3();
    var Layout = function() {
      function Layout2(root, options) {
        if (options === void 0) {
          options = {};
        }
        var me = this;
        me.options = options;
        me.rootNode = hierarchy2(root, options);
      }
      var _proto = Layout2.prototype;
      _proto.execute = function execute() {
        throw new Error("please override this method");
      };
      return Layout2;
    }();
    module.exports = Layout;
  }
});

// node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js
var require_non_layered_tidy = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js"(exports, module) {
    function WrappedTree(w3, h2, y4, c2) {
      if (c2 === void 0) {
        c2 = [];
      }
      var me = this;
      me.w = w3 || 0;
      me.h = h2 || 0;
      me.y = y4 || 0;
      me.x = 0;
      me.c = c2 || [];
      me.cs = c2.length;
      me.prelim = 0;
      me.mod = 0;
      me.shift = 0;
      me.change = 0;
      me.tl = null;
      me.tr = null;
      me.el = null;
      me.er = null;
      me.msel = 0;
      me.mser = 0;
    }
    WrappedTree.fromNode = function(root, isHorizontal) {
      if (!root)
        return null;
      var children = [];
      root.children.forEach(function(child) {
        children.push(WrappedTree.fromNode(child, isHorizontal));
      });
      if (isHorizontal)
        return new WrappedTree(root.height, root.width, root.x, children);
      return new WrappedTree(root.width, root.height, root.y, children);
    };
    function moveRight(node, move, isHorizontal) {
      if (isHorizontal) {
        node.y += move;
      } else {
        node.x += move;
      }
      node.children.forEach(function(child) {
        moveRight(child, move, isHorizontal);
      });
    }
    function getMin(node, isHorizontal) {
      var res = isHorizontal ? node.y : node.x;
      node.children.forEach(function(child) {
        res = Math.min(getMin(child, isHorizontal), res);
      });
      return res;
    }
    function normalize(node, isHorizontal) {
      var min4 = getMin(node, isHorizontal);
      moveRight(node, -min4, isHorizontal);
    }
    function convertBack(converted, root, isHorizontal) {
      if (isHorizontal) {
        root.y = converted.x;
      } else {
        root.x = converted.x;
      }
      converted.c.forEach(function(child, i2) {
        convertBack(child, root.children[i2], isHorizontal);
      });
    }
    function layer(node, isHorizontal, d2) {
      if (d2 === void 0) {
        d2 = 0;
      }
      if (isHorizontal) {
        node.x = d2;
        d2 += node.width;
      } else {
        node.y = d2;
        d2 += node.height;
      }
      node.children.forEach(function(child) {
        layer(child, isHorizontal, d2);
      });
    }
    module.exports = function(root, options) {
      if (options === void 0) {
        options = {};
      }
      var isHorizontal = options.isHorizontal;
      function firstWalk(t2) {
        if (t2.cs === 0) {
          setExtremes(t2);
          return;
        }
        firstWalk(t2.c[0]);
        var ih = updateIYL(bottom(t2.c[0].el), 0, null);
        for (var i2 = 1; i2 < t2.cs; ++i2) {
          firstWalk(t2.c[i2]);
          var min4 = bottom(t2.c[i2].er);
          separate(t2, i2, ih);
          ih = updateIYL(min4, i2, ih);
        }
        positionRoot(t2);
        setExtremes(t2);
      }
      function setExtremes(t2) {
        if (t2.cs === 0) {
          t2.el = t2;
          t2.er = t2;
          t2.msel = t2.mser = 0;
        } else {
          t2.el = t2.c[0].el;
          t2.msel = t2.c[0].msel;
          t2.er = t2.c[t2.cs - 1].er;
          t2.mser = t2.c[t2.cs - 1].mser;
        }
      }
      function separate(t2, i2, ih) {
        var sr = t2.c[i2 - 1];
        var mssr = sr.mod;
        var cl = t2.c[i2];
        var mscl = cl.mod;
        while (sr !== null && cl !== null) {
          if (bottom(sr) > ih.low)
            ih = ih.nxt;
          var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);
          if (dist > 0) {
            mscl += dist;
            moveSubtree2(t2, i2, ih.index, dist);
          }
          var sy = bottom(sr);
          var cy = bottom(cl);
          if (sy <= cy) {
            sr = nextRightContour(sr);
            if (sr !== null)
              mssr += sr.mod;
          }
          if (sy >= cy) {
            cl = nextLeftContour(cl);
            if (cl !== null)
              mscl += cl.mod;
          }
        }
        if (!sr && !!cl) {
          setLeftThread(t2, i2, cl, mscl);
        } else if (!!sr && !cl) {
          setRightThread(t2, i2, sr, mssr);
        }
      }
      function moveSubtree2(t2, i2, si, dist) {
        t2.c[i2].mod += dist;
        t2.c[i2].msel += dist;
        t2.c[i2].mser += dist;
        distributeExtra(t2, i2, si, dist);
      }
      function nextLeftContour(t2) {
        return t2.cs === 0 ? t2.tl : t2.c[0];
      }
      function nextRightContour(t2) {
        return t2.cs === 0 ? t2.tr : t2.c[t2.cs - 1];
      }
      function bottom(t2) {
        return t2.y + t2.h;
      }
      function setLeftThread(t2, i2, cl, modsumcl) {
        var li = t2.c[0].el;
        li.tl = cl;
        var diff = modsumcl - cl.mod - t2.c[0].msel;
        li.mod += diff;
        li.prelim -= diff;
        t2.c[0].el = t2.c[i2].el;
        t2.c[0].msel = t2.c[i2].msel;
      }
      function setRightThread(t2, i2, sr, modsumsr) {
        var ri = t2.c[i2].er;
        ri.tr = sr;
        var diff = modsumsr - sr.mod - t2.c[i2].mser;
        ri.mod += diff;
        ri.prelim -= diff;
        t2.c[i2].er = t2.c[i2 - 1].er;
        t2.c[i2].mser = t2.c[i2 - 1].mser;
      }
      function positionRoot(t2) {
        t2.prelim = (t2.c[0].prelim + t2.c[0].mod + t2.c[t2.cs - 1].mod + t2.c[t2.cs - 1].prelim + t2.c[t2.cs - 1].w) / 2 - t2.w / 2;
      }
      function secondWalk(t2, modsum) {
        modsum += t2.mod;
        t2.x = t2.prelim + modsum;
        addChildSpacing(t2);
        for (var i2 = 0; i2 < t2.cs; i2++) {
          secondWalk(t2.c[i2], modsum);
        }
      }
      function distributeExtra(t2, i2, si, dist) {
        if (si !== i2 - 1) {
          var nr = i2 - si;
          t2.c[si + 1].shift += dist / nr;
          t2.c[i2].shift -= dist / nr;
          t2.c[i2].change -= dist - dist / nr;
        }
      }
      function addChildSpacing(t2) {
        var d2 = 0;
        var modsumdelta = 0;
        for (var i2 = 0; i2 < t2.cs; i2++) {
          d2 += t2.c[i2].shift;
          modsumdelta += d2 + t2.c[i2].change;
          t2.c[i2].mod += modsumdelta;
        }
      }
      function updateIYL(low, index2, ih) {
        while (ih !== null && low >= ih.low) {
          ih = ih.nxt;
        }
        return {
          low,
          index: index2,
          nxt: ih
        };
      }
      layer(root, isHorizontal);
      var wt2 = WrappedTree.fromNode(root, isHorizontal);
      firstWalk(wt2);
      secondWalk(wt2, 0);
      convertBack(wt2, root, isHorizontal);
      normalize(root, isHorizontal);
      return root;
    };
  }
});

// node_modules/@antv/hierarchy/lib/layout/separate-root.js
var require_separate_root = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/separate-root.js"(exports, module) {
    var hierarchy2 = require_hierarchy3();
    module.exports = function(root, options) {
      var left2 = hierarchy2(root.data, options, true);
      var right2 = hierarchy2(root.data, options, true);
      var treeSize = root.children.length;
      var rightTreeSize = Math.round(treeSize / 2);
      var getSide = options.getSide || function(child2, index2) {
        if (index2 < rightTreeSize) {
          return "right";
        }
        return "left";
      };
      for (var i2 = 0; i2 < treeSize; i2++) {
        var child = root.children[i2];
        var side = getSide(child, i2);
        if (side === "right") {
          right2.children.push(child);
        } else {
          left2.children.push(child);
        }
      }
      left2.eachNode(function(node) {
        if (!node.isRoot()) {
          node.side = "left";
        }
      });
      right2.eachNode(function(node) {
        if (!node.isRoot()) {
          node.side = "right";
        }
      });
      return {
        left: left2,
        right: right2
      };
    };
  }
});

// node_modules/@antv/hierarchy/lib/layout/do-layout.js
var require_do_layout = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/do-layout.js"(exports, module) {
    var separateTree = require_separate_root();
    var VALID_DIRECTIONS = [
      "LR",
      "RL",
      "TB",
      "BT",
      "H",
      "V"
    ];
    var HORIZONTAL_DIRECTIONS = ["LR", "RL", "H"];
    var isHorizontal = function isHorizontal2(direction) {
      return HORIZONTAL_DIRECTIONS.indexOf(direction) > -1;
    };
    var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
    module.exports = function(root, options, layoutAlgrithm) {
      var direction = options.direction || DEFAULT_DIRECTION;
      options.isHorizontal = isHorizontal(direction);
      if (direction && VALID_DIRECTIONS.indexOf(direction) === -1) {
        throw new TypeError("Invalid direction: " + direction);
      }
      if (direction === VALID_DIRECTIONS[0]) {
        layoutAlgrithm(root, options);
      } else if (direction === VALID_DIRECTIONS[1]) {
        layoutAlgrithm(root, options);
        root.right2left();
      } else if (direction === VALID_DIRECTIONS[2]) {
        layoutAlgrithm(root, options);
      } else if (direction === VALID_DIRECTIONS[3]) {
        layoutAlgrithm(root, options);
        root.bottom2top();
      } else if (direction === VALID_DIRECTIONS[4] || direction === VALID_DIRECTIONS[5]) {
        var _separateTree = separateTree(root, options), left2 = _separateTree.left, right2 = _separateTree.right;
        layoutAlgrithm(left2, options);
        layoutAlgrithm(right2, options);
        options.isHorizontal ? left2.right2left() : left2.bottom2top();
        right2.translate(left2.x - right2.x, left2.y - right2.y);
        root.x = left2.x;
        root.y = right2.y;
        var bb = root.getBoundingBox();
        if (options.isHorizontal) {
          if (bb.top < 0) {
            root.translate(0, -bb.top);
          }
        } else {
          if (bb.left < 0) {
            root.translate(-bb.left, 0);
          }
        }
      }
      var fixedRoot = options.fixedRoot;
      if (fixedRoot === void 0)
        fixedRoot = true;
      if (fixedRoot) {
        root.translate(-(root.x + root.width / 2 + root.hgap), -(root.y + root.height / 2 + root.vgap));
      }
      return root;
    };
  }
});

// node_modules/@antv/hierarchy/lib/compact-box.js
var require_compact_box = __commonJS({
  "node_modules/@antv/hierarchy/lib/compact-box.js"(exports, module) {
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var TreeLayout = require_base();
    var nonLayeredTidyTree = require_non_layered_tidy();
    var doTreeLayout = require_do_layout();
    var util = require_util3();
    var CompactBoxTreeLayout = function(_TreeLayout) {
      _inheritsLoose(CompactBoxTreeLayout2, _TreeLayout);
      function CompactBoxTreeLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      var _proto = CompactBoxTreeLayout2.prototype;
      _proto.execute = function execute() {
        var me = this;
        return doTreeLayout(me.rootNode, me.options, nonLayeredTidyTree);
      };
      return CompactBoxTreeLayout2;
    }(TreeLayout);
    var DEFAULT_OPTIONS = {};
    function compactBoxLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new CompactBoxTreeLayout(root, options).execute();
    }
    module.exports = compactBoxLayout;
  }
});

// node_modules/@antv/hierarchy/lib/layout/dendrogram.js
var require_dendrogram = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/dendrogram.js"(exports, module) {
    var util = require_util3();
    function WrappedTree(height, children) {
      if (height === void 0) {
        height = 0;
      }
      if (children === void 0) {
        children = [];
      }
      var me = this;
      me.x = me.y = 0;
      me.leftChild = me.rightChild = null;
      me.height = 0;
      me.children = children;
    }
    var DEFAULT_OPTIONS = {
      isHorizontal: true,
      nodeSep: 20,
      nodeSize: 20,
      rankSep: 200,
      subTreeSep: 10
    };
    function convertBack(converted, root, isHorizontal) {
      if (isHorizontal) {
        root.x = converted.x;
        root.y = converted.y;
      } else {
        root.x = converted.y;
        root.y = converted.x;
      }
      converted.children.forEach(function(child, i2) {
        convertBack(child, root.children[i2], isHorizontal);
      });
    }
    module.exports = function(root, options) {
      if (options === void 0) {
        options = {};
      }
      options = util.assign({}, DEFAULT_OPTIONS, options);
      var maxDepth4 = 0;
      function wrappedTreeFromNode(n2) {
        if (!n2)
          return null;
        n2.width = 0;
        if (n2.depth && n2.depth > maxDepth4) {
          maxDepth4 = n2.depth;
        }
        var children = n2.children;
        var childrenCount = children.length;
        var t2 = new WrappedTree(n2.height, []);
        children.forEach(function(child, i2) {
          var childWT = wrappedTreeFromNode(child);
          t2.children.push(childWT);
          if (i2 === 0) {
            t2.leftChild = childWT;
          }
          if (i2 === childrenCount - 1) {
            t2.rightChild = childWT;
          }
        });
        t2.originNode = n2;
        t2.isLeaf = n2.isLeaf();
        return t2;
      }
      function getDrawingDepth(t2) {
        if (t2.isLeaf || t2.children.length === 0) {
          t2.drawingDepth = maxDepth4;
        } else {
          var depths = t2.children.map(function(child) {
            return getDrawingDepth(child);
          });
          var minChildDepth = Math.min.apply(null, depths);
          t2.drawingDepth = minChildDepth - 1;
        }
        return t2.drawingDepth;
      }
      var prevLeaf;
      function position(t2) {
        t2.x = t2.drawingDepth * options.rankSep;
        if (t2.isLeaf) {
          t2.y = 0;
          if (prevLeaf) {
            t2.y = prevLeaf.y + prevLeaf.height + options.nodeSep;
            if (t2.originNode.parent !== prevLeaf.originNode.parent) {
              t2.y += options.subTreeSep;
            }
          }
          prevLeaf = t2;
        } else {
          t2.children.forEach(function(child) {
            position(child);
          });
          t2.y = (t2.leftChild.y + t2.rightChild.y) / 2;
        }
      }
      var wt2 = wrappedTreeFromNode(root);
      getDrawingDepth(wt2);
      position(wt2);
      convertBack(wt2, root, options.isHorizontal);
      return root;
    };
  }
});

// node_modules/@antv/hierarchy/lib/dendrogram.js
var require_dendrogram2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/dendrogram.js"(exports, module) {
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var TreeLayout = require_base();
    var dendrogram = require_dendrogram();
    var doTreeLayout = require_do_layout();
    var util = require_util3();
    var DendrogramLayout = function(_TreeLayout) {
      _inheritsLoose(DendrogramLayout2, _TreeLayout);
      function DendrogramLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      var _proto = DendrogramLayout2.prototype;
      _proto.execute = function execute() {
        var me = this;
        me.rootNode.width = 0;
        return doTreeLayout(me.rootNode, me.options, dendrogram);
      };
      return DendrogramLayout2;
    }(TreeLayout);
    var DEFAULT_OPTIONS = {};
    function dendrogramLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new DendrogramLayout(root, options).execute();
    }
    module.exports = dendrogramLayout;
  }
});

// node_modules/@antv/hierarchy/lib/layout/indented.js
var require_indented = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/indented.js"(exports, module) {
    function positionNode(node, previousNode, indent, dropCap) {
      var displacementX = typeof indent === "function" ? indent(node) : indent * node.depth;
      if (!dropCap) {
        try {
          if (node.id === node.parent.children[0].id) {
            node.x += displacementX;
            node.y = previousNode ? previousNode.y : 0;
            return;
          }
        } catch (e3) {
        }
      }
      node.x += displacementX;
      node.y = previousNode ? previousNode.y + previousNode.height : 0;
      return;
    }
    module.exports = function(root, indent, dropCap) {
      var previousNode = null;
      root.eachNode(function(node) {
        positionNode(node, previousNode, indent, dropCap);
        previousNode = node;
      });
    };
  }
});

// node_modules/@antv/hierarchy/lib/indented.js
var require_indented2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/indented.js"(exports, module) {
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var TreeLayout = require_base();
    var indentedTree = require_indented();
    var separateTree = require_separate_root();
    var util = require_util3();
    var VALID_DIRECTIONS = [
      "LR",
      "RL",
      "H"
    ];
    var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
    var IndentedLayout = function(_TreeLayout) {
      _inheritsLoose(IndentedLayout2, _TreeLayout);
      function IndentedLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      var _proto = IndentedLayout2.prototype;
      _proto.execute = function execute() {
        var me = this;
        var options = me.options;
        var root = me.rootNode;
        options.isHorizontal = true;
        var _options$indent = options.indent, indent = _options$indent === void 0 ? 20 : _options$indent, _options$dropCap = options.dropCap, dropCap = _options$dropCap === void 0 ? true : _options$dropCap;
        var direction = options.direction || DEFAULT_DIRECTION;
        if (direction && VALID_DIRECTIONS.indexOf(direction) === -1) {
          throw new TypeError("Invalid direction: " + direction);
        }
        if (direction === VALID_DIRECTIONS[0]) {
          indentedTree(root, indent, dropCap);
        } else if (direction === VALID_DIRECTIONS[1]) {
          indentedTree(root, indent, dropCap);
          root.right2left();
        } else if (direction === VALID_DIRECTIONS[2]) {
          var _separateTree = separateTree(root, options), left2 = _separateTree.left, right2 = _separateTree.right;
          indentedTree(left2, indent, dropCap);
          left2.right2left();
          indentedTree(right2, indent, dropCap);
          var bbox = left2.getBoundingBox();
          right2.translate(bbox.width, 0);
          root.x = right2.x - root.width / 2;
        }
        return root;
      };
      return IndentedLayout2;
    }(TreeLayout);
    var DEFAULT_OPTIONS = {};
    function indentedLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new IndentedLayout(root, options).execute();
    }
    module.exports = indentedLayout;
  }
});

// node_modules/@antv/hierarchy/lib/layout/mindmap.js
var require_mindmap = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/mindmap.js"(exports, module) {
    var util = require_util3();
    function secondWalk(node, options) {
      var totalHeight = 0;
      if (!node.children.length) {
        totalHeight = node.height;
      } else {
        node.children.forEach(function(c2) {
          totalHeight += secondWalk(c2, options);
        });
      }
      node._subTreeSep = options.getSubTreeSep(node.data);
      node.totalHeight = Math.max(node.height, totalHeight) + 2 * node._subTreeSep;
      return node.totalHeight;
    }
    function thirdWalk(node) {
      var children = node.children;
      var len = children.length;
      if (len) {
        children.forEach(function(c2) {
          thirdWalk(c2);
        });
        var first = children[0];
        var last = children[len - 1];
        var childrenHeight = last.y - first.y + last.height;
        var childrenTotalHeight = 0;
        children.forEach(function(child) {
          childrenTotalHeight += child.totalHeight;
        });
        if (childrenHeight > node.height) {
          node.y = first.y + childrenHeight / 2 - node.height / 2;
        } else if (children.length !== 1 || node.height > childrenTotalHeight) {
          var offset = node.y + (node.height - childrenHeight) / 2 - first.y;
          children.forEach(function(c2) {
            c2.translate(0, offset);
          });
        } else {
          node.y = (first.y + first.height / 2 + last.y + last.height / 2) / 2 - node.height / 2;
        }
      }
    }
    var DEFAULT_OPTIONS = {
      getSubTreeSep: function getSubTreeSep() {
        return 0;
      }
    };
    module.exports = function(root, options) {
      if (options === void 0) {
        options = {};
      }
      options = util.assign({}, DEFAULT_OPTIONS, options);
      root.parent = {
        x: 0,
        width: 0,
        height: 0,
        y: 0
      };
      root.BFTraverse(function(node) {
        node.x = node.parent.x + node.parent.width;
      });
      root.parent = null;
      secondWalk(root, options);
      root.startY = 0;
      root.y = root.totalHeight / 2 - root.height / 2;
      root.eachNode(function(node) {
        var children = node.children;
        var len = children.length;
        if (len) {
          var first = children[0];
          first.startY = node.startY + node._subTreeSep;
          if (len === 1) {
            first.y = node.y + node.height / 2 - first.height / 2;
          } else {
            first.y = first.startY + first.totalHeight / 2 - first.height / 2;
            for (var i2 = 1; i2 < len; i2++) {
              var c2 = children[i2];
              c2.startY = children[i2 - 1].startY + children[i2 - 1].totalHeight;
              c2.y = c2.startY + c2.totalHeight / 2 - c2.height / 2;
            }
          }
        }
      });
      thirdWalk(root);
    };
  }
});

// node_modules/@antv/hierarchy/lib/mindmap.js
var require_mindmap2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/mindmap.js"(exports, module) {
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var TreeLayout = require_base();
    var mindmap = require_mindmap();
    var doTreeLayout = require_do_layout();
    var util = require_util3();
    var MindmapLayout = function(_TreeLayout) {
      _inheritsLoose(MindmapLayout2, _TreeLayout);
      function MindmapLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      var _proto = MindmapLayout2.prototype;
      _proto.execute = function execute() {
        var me = this;
        return doTreeLayout(me.rootNode, me.options, mindmap);
      };
      return MindmapLayout2;
    }(TreeLayout);
    var DEFAULT_OPTIONS = {};
    function mindmapLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new MindmapLayout(root, options).execute();
    }
    module.exports = mindmapLayout;
  }
});

// node_modules/@antv/hierarchy/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/index.js"(exports, module) {
    var hierarchy2 = {
      compactBox: require_compact_box(),
      dendrogram: require_dendrogram2(),
      indented: require_indented2(),
      mindmap: require_mindmap2()
    };
    module.exports = hierarchy2;
  }
});

// node_modules/@antv/data-set/lib/transform/hierarchy/compact-box.js
var require_compact_box2 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/hierarchy/compact-box.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var hierarchy_1 = tslib_1.__importDefault(require_lib2());
    var data_set_1 = require_data_set();
    var DEFAULT_OPTIONS = {};
    function transform(dataView, options) {
      var root = dataView.root;
      options = Object.assign({}, DEFAULT_OPTIONS, options);
      if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
        throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
      }
      dataView.root = hierarchy_1.default.compactBox(root, options);
    }
    data_set_1.DataSet.registerTransform("hierarchy.compact-box", transform);
    data_set_1.DataSet.registerTransform("compact-box-tree", transform);
    data_set_1.DataSet.registerTransform("non-layered-tidy-tree", transform);
    data_set_1.DataSet.registerTransform("mindmap-logical", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/hierarchy/dendrogram.js
var require_dendrogram3 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/hierarchy/dendrogram.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var hierarchy_1 = tslib_1.__importDefault(require_lib2());
    var data_set_1 = require_data_set();
    var DEFAULT_OPTIONS = {};
    function transform(dataView, options) {
      var root = dataView.root;
      options = Object.assign({}, DEFAULT_OPTIONS, options);
      if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
        throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
      }
      dataView.root = hierarchy_1.default.dendrogram(root, options);
    }
    data_set_1.DataSet.registerTransform("hierarchy.dendrogram", transform);
    data_set_1.DataSet.registerTransform("dendrogram", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/hierarchy/indented.js
var require_indented3 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/hierarchy/indented.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var hierarchy_1 = tslib_1.__importDefault(require_lib2());
    var data_set_1 = require_data_set();
    var DEFAULT_OPTIONS = {};
    function transform(dataView, options) {
      var root = dataView.root;
      options = Object.assign({}, DEFAULT_OPTIONS, options);
      if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
        throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
      }
      dataView.root = hierarchy_1.default.indented(root, options);
    }
    data_set_1.DataSet.registerTransform("hierarchy.indented", transform);
    data_set_1.DataSet.registerTransform("indented-tree", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/hierarchy/pack.js
var require_pack = __commonJS({
  "node_modules/@antv/data-set/lib/transform/hierarchy/pack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var d3Hierarchy = tslib_1.__importStar((init_src8(), src_exports2));
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      field: "value",
      size: [1, 1],
      padding: 0,
      as: ["x", "y", "r"]
    };
    function transform(dataView, options) {
      if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
        throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
      }
      var root = dataView.root;
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var as = options.as;
      if (!util_1.isArray(as) || as.length !== 3) {
        throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ "x", "y", "r" ])!');
      }
      var field;
      try {
        field = option_parser_1.getField(options);
      } catch (e3) {
        console.warn(e3);
      }
      if (field) {
        root.sum(function(d2) {
          return d2[field];
        }).sort(function(a3, b2) {
          return b2[field] - a3[field];
        });
      }
      var packLayout = d3Hierarchy.pack();
      packLayout.size(options.size);
      if (options.padding) {
        packLayout.padding(options.padding);
      }
      packLayout(root);
      var x4 = as[0];
      var y4 = as[1];
      var r2 = as[2];
      root.each(function(node) {
        node[x4] = node.x;
        node[y4] = node.y;
        node[r2] = node.r;
      });
    }
    data_set_1.DataSet.registerTransform("hierarchy.pack", transform);
    data_set_1.DataSet.registerTransform("hierarchy.circle-packing", transform);
    data_set_1.DataSet.registerTransform("circle-packing", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/hierarchy/partition.js
var require_partition4 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/hierarchy/partition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var d3Hierarchy = tslib_1.__importStar((init_src8(), src_exports2));
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      field: "value",
      size: [1, 1],
      round: false,
      padding: 0,
      sort: true,
      as: ["x", "y"]
    };
    function transform(dataView, options) {
      if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
        throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
      }
      var root = dataView.root;
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var as = options.as;
      if (!util_1.isArray(as) || as.length !== 2) {
        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
      }
      var field;
      try {
        field = option_parser_1.getField(options);
      } catch (e3) {
        console.warn(e3);
      }
      if (field) {
        root.sum(function(d2) {
          return d2[field];
        });
      }
      var partitionLayout = d3Hierarchy.partition();
      partitionLayout.size(options.size).round(options.round).padding(options.padding);
      partitionLayout(root);
      var x4 = as[0];
      var y4 = as[1];
      root.each(function(node) {
        node[x4] = [node.x0, node.x1, node.x1, node.x0];
        node[y4] = [node.y1, node.y1, node.y0, node.y0];
        ["x0", "x1", "y0", "y1"].forEach(function(prop) {
          if (as.indexOf(prop) === -1) {
            delete node[prop];
          }
        });
      });
    }
    data_set_1.DataSet.registerTransform("hierarchy.partition", transform);
    data_set_1.DataSet.registerTransform("adjacency", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/hierarchy/tree.js
var require_tree = __commonJS({
  "node_modules/@antv/data-set/lib/transform/hierarchy/tree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var d3Hierarchy = tslib_1.__importStar((init_src8(), src_exports2));
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      field: "value",
      size: [1, 1],
      nodeSize: null,
      separation: null,
      as: ["x", "y"]
    };
    function transform(dataView, options) {
      if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
        throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
      }
      var root = dataView.root;
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var as = options.as;
      if (!util_1.isArray(as) || as.length !== 2) {
        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
      }
      var field;
      try {
        field = option_parser_1.getField(options);
      } catch (e3) {
        console.warn(e3);
      }
      if (field) {
        root.sum(function(d2) {
          return d2[field];
        });
      }
      var treeLayout = d3Hierarchy.tree();
      treeLayout.size(options.size);
      if (options.nodeSize) {
        treeLayout.nodeSize(options.nodeSize);
      }
      if (options.separation) {
        treeLayout.separation(options.separation);
      }
      treeLayout(root);
      var x4 = as[0];
      var y4 = as[1];
      root.each(function(node) {
        node[x4] = node.x;
        node[y4] = node.y;
      });
    }
    data_set_1.DataSet.registerTransform("hierarchy.tree", transform);
    data_set_1.DataSet.registerTransform("tree", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/hierarchy/treemap.js
var require_treemap = __commonJS({
  "node_modules/@antv/data-set/lib/transform/hierarchy/treemap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var d3Hierarchy = tslib_1.__importStar((init_src8(), src_exports2));
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      field: "value",
      tile: "treemapSquarify",
      size: [1, 1],
      round: false,
      padding: 0,
      paddingInner: 0,
      paddingOuter: 0,
      paddingTop: 0,
      paddingRight: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      as: ["x", "y"]
    };
    function transform(dataView, options) {
      if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {
        throw new TypeError("Invalid DataView: This transform is for Hierarchy data only!");
      }
      var root = dataView.root;
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var as = options.as;
      if (!util_1.isArray(as) || as.length !== 2) {
        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
      }
      var field;
      try {
        field = option_parser_1.getField(options);
      } catch (e3) {
        console.warn(e3);
      }
      if (field) {
        root.sum(function(d2) {
          return d2[field];
        });
      }
      var treemapLayout = d3Hierarchy.treemap();
      treemapLayout.tile(d3Hierarchy[options.tile]).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft);
      treemapLayout(root);
      var x4 = as[0];
      var y4 = as[1];
      root.each(function(node) {
        node[x4] = [node.x0, node.x1, node.x1, node.x0];
        node[y4] = [node.y1, node.y1, node.y0, node.y0];
        ["x0", "x1", "y0", "y1"].forEach(function(prop) {
          if (as.indexOf(prop) === -1) {
            delete node[prop];
          }
        });
      });
    }
    data_set_1.DataSet.registerTransform("hierarchy.treemap", transform);
    data_set_1.DataSet.registerTransform("treemap", transform);
  }
});

// node_modules/@antv/data-set/lib/util/tag-cloud.js
var require_tag_cloud = __commonJS({
  "node_modules/@antv/data-set/lib/util/tag-cloud.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var cloudRadians = Math.PI / 180;
    var cw = 1 << 11 >> 5;
    var ch = 1 << 11;
    function cloudText(d2) {
      return d2.text;
    }
    function cloudFont() {
      return "serif";
    }
    function cloudFontNormal() {
      return "normal";
    }
    function cloudFontSize(d2) {
      return d2.value;
    }
    function cloudRotate() {
      return ~~(Math.random() * 2) * 90;
    }
    function cloudPadding() {
      return 1;
    }
    function cloudSprite(contextAndRatio, d2, data, di) {
      if (d2.sprite)
        return;
      var c2 = contextAndRatio.context, ratio = contextAndRatio.ratio;
      c2.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
      var x4 = 0, y4 = 0, maxh = 0;
      var n2 = data.length;
      --di;
      while (++di < n2) {
        d2 = data[di];
        c2.save();
        c2.font = d2.style + " " + d2.weight + " " + ~~((d2.size + 1) / ratio) + "px " + d2.font;
        var w3 = c2.measureText(d2.text + "m").width * ratio, h2 = d2.size << 1;
        if (d2.rotate) {
          var sr = Math.sin(d2.rotate * cloudRadians), cr = Math.cos(d2.rotate * cloudRadians), wcr = w3 * cr, wsr = w3 * sr, hcr = h2 * cr, hsr = h2 * sr;
          w3 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
          h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
        } else {
          w3 = w3 + 31 >> 5 << 5;
        }
        if (h2 > maxh)
          maxh = h2;
        if (x4 + w3 >= cw << 5) {
          x4 = 0;
          y4 += maxh;
          maxh = 0;
        }
        if (y4 + h2 >= ch)
          break;
        c2.translate((x4 + (w3 >> 1)) / ratio, (y4 + (h2 >> 1)) / ratio);
        if (d2.rotate)
          c2.rotate(d2.rotate * cloudRadians);
        c2.fillText(d2.text, 0, 0);
        if (d2.padding) {
          c2.lineWidth = 2 * d2.padding;
          c2.strokeText(d2.text, 0, 0);
        }
        c2.restore();
        d2.width = w3;
        d2.height = h2;
        d2.xoff = x4;
        d2.yoff = y4;
        d2.x1 = w3 >> 1;
        d2.y1 = h2 >> 1;
        d2.x0 = -d2.x1;
        d2.y0 = -d2.y1;
        d2.hasText = true;
        x4 += w3;
      }
      var pixels = c2.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
      while (--di >= 0) {
        d2 = data[di];
        if (!d2.hasText)
          continue;
        var w3 = d2.width, w32 = w3 >> 5;
        var h2 = d2.y1 - d2.y0;
        for (var i2 = 0; i2 < h2 * w32; i2++)
          sprite[i2] = 0;
        x4 = d2.xoff;
        if (x4 == null)
          return;
        y4 = d2.yoff;
        var seen = 0, seenRow = -1;
        for (var j2 = 0; j2 < h2; j2++) {
          for (var i2 = 0; i2 < w3; i2++) {
            var k4 = w32 * j2 + (i2 >> 5), m2 = pixels[(y4 + j2) * (cw << 5) + (x4 + i2) << 2] ? 1 << 31 - i2 % 32 : 0;
            sprite[k4] |= m2;
            seen |= m2;
          }
          if (seen)
            seenRow = j2;
          else {
            d2.y0++;
            h2--;
            j2--;
            y4++;
          }
        }
        d2.y1 = d2.y0 + seenRow;
        d2.sprite = sprite.slice(0, (d2.y1 - d2.y0) * w32);
      }
    }
    function cloudCollide(tag, board, sw) {
      sw >>= 5;
      var sprite = tag.sprite, w3 = tag.width >> 5, lx = tag.x - (w3 << 4), sx = lx & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0;
      var x4 = (tag.y + tag.y0) * sw + (lx >> 5), last;
      for (var j2 = 0; j2 < h2; j2++) {
        last = 0;
        for (var i2 = 0; i2 <= w3; i2++) {
          if ((last << msx | (i2 < w3 ? (last = sprite[j2 * w3 + i2]) >>> sx : 0)) & board[x4 + i2])
            return true;
        }
        x4 += sw;
      }
      return false;
    }
    function cloudBounds(bounds, d2) {
      var b0 = bounds[0], b1 = bounds[1];
      if (d2.x + d2.x0 < b0.x)
        b0.x = d2.x + d2.x0;
      if (d2.y + d2.y0 < b0.y)
        b0.y = d2.y + d2.y0;
      if (d2.x + d2.x1 > b1.x)
        b1.x = d2.x + d2.x1;
      if (d2.y + d2.y1 > b1.y)
        b1.y = d2.y + d2.y1;
    }
    function collideRects(a3, b2) {
      return a3.x + a3.x1 > b2[0].x && a3.x + a3.x0 < b2[1].x && a3.y + a3.y1 > b2[0].y && a3.y + a3.y0 < b2[1].y;
    }
    function archimedeanSpiral(size) {
      var e3 = size[0] / size[1];
      return function(t2) {
        return [e3 * (t2 *= 0.1) * Math.cos(t2), t2 * Math.sin(t2)];
      };
    }
    function rectangularSpiral(size) {
      var dy = 4, dx = dy * size[0] / size[1];
      var x4 = 0, y4 = 0;
      return function(t2) {
        var sign6 = t2 < 0 ? -1 : 1;
        switch (Math.sqrt(1 + 4 * sign6 * t2) - sign6 & 3) {
          case 0:
            x4 += dx;
            break;
          case 1:
            y4 += dy;
            break;
          case 2:
            x4 -= dx;
            break;
          default:
            y4 -= dy;
            break;
        }
        return [x4, y4];
      };
    }
    function zeroArray(n2) {
      var a3 = [];
      var i2 = -1;
      while (++i2 < n2)
        a3[i2] = 0;
      return a3;
    }
    function cloudCanvas() {
      return document.createElement("canvas");
    }
    function functor(d2) {
      return typeof d2 === "function" ? d2 : function() {
        return d2;
      };
    }
    var spirals = {
      archimedean: archimedeanSpiral,
      rectangular: rectangularSpiral
    };
    function default_1() {
      var size = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontStyle = cloudFontNormal, fontWeight = cloudFontNormal, rotate = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, words = [], timeInterval = Infinity, random = Math.random, canvas = cloudCanvas;
      var cloud = {};
      cloud.canvas = function(_2) {
        return arguments.length ? (canvas = functor(_2), cloud) : canvas;
      };
      cloud.start = function() {
        var _a = tslib_1.__read(size, 2), width = _a[0], height = _a[1];
        var contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]), n2 = words.length, tags = [], data = words.map(function(d2, i3) {
          d2.text = text.call(this, d2, i3);
          d2.font = font.call(this, d2, i3);
          d2.style = fontStyle.call(this, d2, i3);
          d2.weight = fontWeight.call(this, d2, i3);
          d2.rotate = rotate.call(this, d2, i3);
          d2.size = ~~fontSize.call(this, d2, i3);
          d2.padding = padding.call(this, d2, i3);
          return d2;
        }).sort(function(a3, b2) {
          return b2.size - a3.size;
        });
        var i2 = -1, bounds = !cloud.board ? null : [
          {
            x: 0,
            y: 0
          },
          {
            x: width,
            y: height
          }
        ];
        step();
        function step() {
          var start = Date.now();
          while (Date.now() - start < timeInterval && ++i2 < n2) {
            var d2 = data[i2];
            d2.x = width * (random() + 0.5) >> 1;
            d2.y = height * (random() + 0.5) >> 1;
            cloudSprite(contextAndRatio, d2, data, i2);
            if (d2.hasText && place2(board, d2, bounds)) {
              tags.push(d2);
              if (bounds) {
                if (!cloud.hasImage) {
                  cloudBounds(bounds, d2);
                }
              } else {
                bounds = [
                  { x: d2.x + d2.x0, y: d2.y + d2.y0 },
                  { x: d2.x + d2.x1, y: d2.y + d2.y1 }
                ];
              }
              d2.x -= size[0] >> 1;
              d2.y -= size[1] >> 1;
            }
          }
          cloud._tags = tags;
          cloud._bounds = bounds;
        }
        return cloud;
      };
      function getContext(canvas2) {
        canvas2.width = canvas2.height = 1;
        var ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
        canvas2.width = (cw << 5) / ratio;
        canvas2.height = ch / ratio;
        var context = canvas2.getContext("2d");
        context.fillStyle = context.strokeStyle = "red";
        context.textAlign = "center";
        return { context, ratio };
      }
      function place2(board, tag, bounds) {
        var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s3 = spiral(size), dt2 = random() < 0.5 ? 1 : -1;
        var dxdy, t2 = -dt2, dx, dy;
        while (dxdy = s3(t2 += dt2)) {
          dx = ~~dxdy[0];
          dy = ~~dxdy[1];
          if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
            break;
          tag.x = startX + dx;
          tag.y = startY + dy;
          if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])
            continue;
          if (!bounds || !cloudCollide(tag, board, size[0])) {
            if (!bounds || collideRects(tag, bounds)) {
              var sprite = tag.sprite, w3 = tag.width >> 5, sw = size[0] >> 5, lx = tag.x - (w3 << 4), sx = lx & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0;
              var last = void 0, x4 = (tag.y + tag.y0) * sw + (lx >> 5);
              for (var j2 = 0; j2 < h2; j2++) {
                last = 0;
                for (var i2 = 0; i2 <= w3; i2++) {
                  board[x4 + i2] |= last << msx | (i2 < w3 ? (last = sprite[j2 * w3 + i2]) >>> sx : 0);
                }
                x4 += sw;
              }
              delete tag.sprite;
              return true;
            }
          }
        }
        return false;
      }
      cloud.createMask = function(img) {
        var can = document.createElement("canvas");
        var _a = tslib_1.__read(size, 2), width = _a[0], height = _a[1];
        if (!width || !height) {
          return;
        }
        var w32 = width >> 5;
        var board = zeroArray((width >> 5) * height);
        can.width = width;
        can.height = height;
        var cxt = can.getContext("2d");
        cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
        var imageData = cxt.getImageData(0, 0, width, height).data;
        for (var j2 = 0; j2 < height; j2++) {
          for (var i2 = 0; i2 < width; i2++) {
            var k4 = w32 * j2 + (i2 >> 5);
            var tmp = j2 * width + i2 << 2;
            var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
            var m2 = flag ? 1 << 31 - i2 % 32 : 0;
            board[k4] |= m2;
          }
        }
        cloud.board = board;
        cloud.hasImage = true;
      };
      cloud.timeInterval = function(_2) {
        return arguments.length ? (timeInterval = _2 == null ? Infinity : _2, cloud) : timeInterval;
      };
      cloud.words = function(_2) {
        return arguments.length ? (words = _2, cloud) : words;
      };
      cloud.size = function(_2) {
        return arguments.length ? (size = [+_2[0], +_2[1]], cloud) : size;
      };
      cloud.font = function(_2) {
        return arguments.length ? (font = functor(_2), cloud) : font;
      };
      cloud.fontStyle = function(_2) {
        return arguments.length ? (fontStyle = functor(_2), cloud) : fontStyle;
      };
      cloud.fontWeight = function(_2) {
        return arguments.length ? (fontWeight = functor(_2), cloud) : fontWeight;
      };
      cloud.rotate = function(_2) {
        return arguments.length ? (rotate = functor(_2), cloud) : rotate;
      };
      cloud.text = function(_2) {
        return arguments.length ? (text = functor(_2), cloud) : text;
      };
      cloud.spiral = function(_2) {
        return arguments.length ? (spiral = spirals[_2] || _2, cloud) : spiral;
      };
      cloud.fontSize = function(_2) {
        return arguments.length ? (fontSize = functor(_2), cloud) : fontSize;
      };
      cloud.padding = function(_2) {
        return arguments.length ? (padding = functor(_2), cloud) : padding;
      };
      cloud.random = function(_2) {
        return arguments.length ? (random = _2, cloud) : random;
      };
      return cloud;
    }
    exports.default = default_1;
  }
});

// node_modules/@antv/data-set/lib/transform/tag-cloud.js
var require_tag_cloud2 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/tag-cloud.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var data_set_1 = require_data_set();
    var tag_cloud_1 = tslib_1.__importDefault(require_tag_cloud());
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      fields: ["text", "value"],
      font: function() {
        return "serif";
      },
      padding: 1,
      size: [500, 500],
      spiral: "archimedean",
      timeInterval: 500
    };
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var layout = tag_cloud_1.default();
      if (!options.size[0] || !options.size[1]) {
        dataView.rows = [];
        dataView._tagCloud = layout;
        return;
      }
      ["font", "fontSize", "fontWeight", "padding", "rotate", "size", "spiral", "timeInterval"].forEach(function(key) {
        if (options[key]) {
          layout[key](options[key]);
        }
      });
      var fields = option_parser_1.getFields(options);
      var _a = tslib_1.__read(fields, 2), text = _a[0], value2 = _a[1];
      if (!util_1.isString(text) || !util_1.isString(value2)) {
        throw new TypeError('Invalid fields: must be an array with 2 strings (e.g. [ "text", "value" ])!');
      }
      var words = dataView.rows.map(function(row) {
        row.text = row[text];
        row.value = row[value2];
        return row;
      });
      layout.words(words);
      if (options.imageMask) {
        layout.createMask(options.imageMask);
      }
      var result = layout.start();
      var tags = result._tags;
      var bounds = result._bounds || [
        { x: 0, y: 0 },
        { x: options.size[0], y: options.size[1] }
      ];
      tags.forEach(function(tag) {
        tag.x += options.size[0] / 2;
        tag.y += options.size[1] / 2;
      });
      var _b = tslib_1.__read(options.size, 2), w3 = _b[0], h2 = _b[1];
      var hasImage = result.hasImage;
      tags.push({
        text: "",
        value: 0,
        x: hasImage ? 0 : bounds[0].x,
        y: hasImage ? 0 : bounds[0].y,
        opacity: 0
      });
      tags.push({
        text: "",
        value: 0,
        x: hasImage ? w3 : bounds[1].x,
        y: hasImage ? h2 : bounds[1].y,
        opacity: 0
      });
      dataView.rows = tags;
      dataView._tagCloud = result;
    }
    data_set_1.DataSet.registerTransform("tag-cloud", transform);
    data_set_1.DataSet.registerTransform("word-cloud", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/waffle.js
var require_waffle = __commonJS({
  "node_modules/@antv/data-set/lib/transform/waffle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var simple_statistics_1 = (init_simple_statistics(), simple_statistics_exports);
    var partition_1 = tslib_1.__importDefault(require_partition());
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var DEFAULT_OPTIONS = {
      fields: ["name", "value"],
      rows: 5,
      size: [1, 1],
      scale: 1,
      groupBy: [],
      maxCount: 1e3,
      gapRatio: 0.1,
      as: ["x", "y"]
    };
    function transform(dataView, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var fields = option_parser_1.getFields(options);
      var _a = tslib_1.__read(fields, 2), nameField = _a[0], valueField = _a[1];
      var _b = tslib_1.__read(options.as, 2), asX = _b[0], asY = _b[1];
      var groupBy = options.groupBy;
      var groups2 = partition_1.default(dataView.rows, groupBy);
      var groupKeys = util_1.keys(groups2);
      var _c = tslib_1.__read(options.size, 2), width = _c[0], height = _c[1];
      var maxCount = options.maxCount;
      var groupCount = groupKeys.length;
      var partHeight = height / groupCount;
      var rows = options.rows;
      var gapRatio = options.gapRatio;
      var result = [];
      var scale = options.scale;
      var currentGroupIndex = 0;
      var wStep = 0;
      util_1.forIn(groups2, function(group2) {
        var totalValue = simple_statistics_1.sum(util_1.map(group2, function(row) {
          return row[valueField];
        }));
        var cols = Math.ceil(totalValue * scale / rows);
        if (totalValue * scale > maxCount) {
          scale = maxCount / totalValue;
          cols = Math.ceil(totalValue * scale / rows);
        }
        wStep = width / cols;
      });
      util_1.forIn(groups2, function(group2) {
        var heightRange = [currentGroupIndex * partHeight, (currentGroupIndex + 1) * partHeight];
        var h2 = heightRange[1] - heightRange[0];
        var hStep = h2 * (1 - gapRatio) / rows;
        var currentCol = 0;
        var currentRow = 0;
        util_1.each(group2, function(row) {
          var value2 = row[valueField];
          var count3 = Math.round(value2 * scale);
          for (var i2 = 0; i2 < count3; i2++) {
            if (currentRow === rows) {
              currentRow = 0;
              currentCol++;
            }
            var resultRow = util_1.pick(row, [nameField, valueField].concat(groupBy));
            resultRow[asX] = currentCol * wStep + wStep / 2;
            resultRow[asY] = currentRow * hStep + hStep / 2 + heightRange[0];
            resultRow._wStep = wStep;
            resultRow._hStep = hStep;
            currentRow++;
            result.push(resultRow);
          }
        });
        currentGroupIndex += 1;
      });
      dataView.rows = result;
    }
    data_set_1.DataSet.registerTransform("waffle", transform);
  }
});

// node_modules/@antv/data-set/lib/transform/kernel-smooth/density.js
var require_density = __commonJS({
  "node_modules/@antv/data-set/lib/transform/kernel-smooth/density.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var get_series_values_1 = tslib_1.__importDefault(require_get_series_values());
    var kernel_1 = tslib_1.__importDefault(require_kernel());
    var data_set_1 = require_data_set();
    var option_parser_1 = require_option_parser();
    var bandwidth_1 = require_bandwidth();
    var DEFAULT_OPTIONS = {
      as: ["x", "y", "z"],
      method: "gaussian"
    };
    var KERNEL_METHODS = util_1.keys(kernel_1.default);
    function transform(dv, options) {
      var _a, _b;
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var fields = option_parser_1.getFields(options);
      if (!util_1.isArray(fields) || fields.length !== 2) {
        throw new TypeError("invalid fields: must be an array of 2 strings!");
      }
      var _c = tslib_1.__read(options.as, 3), asX = _c[0], asY = _c[1], asZ = _c[2];
      if (!util_1.isString(asX) || !util_1.isString(asY) || !util_1.isString(asZ)) {
        throw new TypeError("invalid as: must be an array of 3 strings!");
      }
      var method;
      if (util_1.isString(options.method)) {
        if (KERNEL_METHODS.indexOf(options.method) === -1) {
          throw new TypeError("invalid method: " + options.method + ". Must be one of " + KERNEL_METHODS.join(", "));
        }
        method = kernel_1.default[options.method];
      }
      var _d = tslib_1.__read(fields, 2), xField = _d[0], yField = _d[1];
      var extent = options.extent, bandwidth = options.bandwidth;
      var extentX;
      var extentY;
      if (extent && Array.isArray(extent) && Array.isArray(extent[0]) && Array.isArray(extent[1])) {
        _a = tslib_1.__read(extent, 2), extentX = _a[0], extentY = _a[1];
      } else {
        extentX = dv.range(xField);
        extentY = dv.range(yField);
      }
      var bwX, bwY;
      if (bandwidth && Array.isArray(bandwidth) && bandwidth.slice(0, 2).every(util_1.isNumber) && bandwidth.slice(0, 2).every(function(item) {
        return item > 0;
      })) {
        _b = tslib_1.__read(bandwidth, 2), bwX = _b[0], bwY = _b[1];
      } else {
        bwX = bandwidth_1.silverman(dv.getColumn(xField));
        bwY = bandwidth_1.silverman(dv.getColumn(yField));
      }
      var seriesValuesX = get_series_values_1.default(extentX, bwX);
      var seriesValuesY = get_series_values_1.default(extentY, bwY);
      var count3 = dv.rows.length;
      var result = [];
      for (var i2 = 0; i2 < seriesValuesX.length; i2++) {
        for (var j2 = 0; j2 < seriesValuesY.length; j2++) {
          var sum5 = 0;
          var x4 = seriesValuesX[i2];
          var y4 = seriesValuesY[j2];
          for (var k4 = 0; k4 < count3; k4++) {
            sum5 += method((x4 - dv.rows[k4][xField]) / bwX) * method((y4 - dv.rows[k4][yField]) / bwY);
          }
          var z2 = 1 / (count3 * bwX * bwY) * sum5;
          var row = {};
          row[asX] = x4;
          row[asY] = y4;
          row[asZ] = z2;
          result.push(row);
        }
      }
      dv.rows = result;
    }
    data_set_1.DataSet.registerTransform("kernel-smooth.density", transform);
    data_set_1.DataSet.registerTransform("kernel.density", transform);
    exports.default = {
      KERNEL_METHODS
    };
  }
});

// node_modules/@antv/data-set/lib/transform/kernel-smooth/regression.js
var require_regression3 = __commonJS({
  "node_modules/@antv/data-set/lib/transform/kernel-smooth/regression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), esm_exports);
    var get_series_values_1 = tslib_1.__importDefault(require_get_series_values());
    var kernel_1 = tslib_1.__importDefault(require_kernel());
    var data_set_1 = require_data_set();
    var simple_statistics_1 = (init_simple_statistics(), simple_statistics_exports);
    var option_parser_1 = require_option_parser();
    var bandwidth_1 = require_bandwidth();
    var DEFAULT_OPTIONS = {
      as: ["x", "y"],
      method: "gaussian"
    };
    var KERNEL_METHODS = util_1.keys(kernel_1.default);
    function weight(kernel, bandwidth, x_0, x_i) {
      var arg = (x_i - x_0) / bandwidth;
      return kernel(arg);
    }
    function vectorize(fun) {
      return function(x4) {
        if (!util_1.isArray(x4)) {
          return fun(x4);
        }
        return x4.map(function(x5) {
          return fun(x5);
        });
      };
    }
    function transform(dv, options) {
      options = util_1.assign({}, DEFAULT_OPTIONS, options);
      var fields = option_parser_1.getFields(options);
      if (!util_1.isArray(fields) || !(fields.length === 1 || fields.length === 2)) {
        throw new TypeError("invalid fields: must be an array of 1 or 2 strings!");
      }
      var _a = tslib_1.__read(options.as, 2), asX = _a[0], asY = _a[1];
      if (!util_1.isString(asX) || !util_1.isString(asY)) {
        throw new TypeError("invalid as: must be an array of 2 strings!");
      }
      var func;
      var method = options.method;
      if (util_1.isString(method)) {
        if (KERNEL_METHODS.indexOf(method) === -1) {
          throw new TypeError("invalid method: " + method + ". Must be one of " + KERNEL_METHODS.join(", "));
        }
        func = kernel_1.default[method];
      }
      var _b = tslib_1.__read(fields, 2), xField = _b[0], yField = _b[1];
      var xs = dv.getColumn(xField);
      var extent = options.extent;
      if (extent || !util_1.isArray(extent)) {
        extent = dv.range(xField);
      }
      var bandwidth = options.bandwidth;
      if (!bandwidth || !util_1.isNumber(bandwidth) || bandwidth <= 0) {
        bandwidth = bandwidth_1.silverman(xs);
      }
      var seriesValues = get_series_values_1.default(extent, bandwidth);
      var xCount = xs.length;
      var weightFunc = weight.bind(null, func, bandwidth);
      var kernelSmoother;
      if (util_1.isNil(yField)) {
        kernelSmoother = vectorize(function(x4) {
          var weights = xs.map(function(x_i) {
            return weightFunc(x4, x_i);
          });
          var num = simple_statistics_1.sum(weights);
          var denom = xCount * bandwidth;
          if (!num || !denom)
            return 0;
          return num / denom;
        });
      } else {
        var ys_1 = dv.getColumn(yField);
        kernelSmoother = vectorize(function(x4) {
          var weights = xs.map(function(x_i) {
            return weightFunc(x4, x_i);
          });
          var num = simple_statistics_1.sum(weights.map(function(w3, i2) {
            return w3 * ys_1[i2];
          }));
          var denom = simple_statistics_1.sum(weights);
          if (!num || !denom)
            return 0;
          return num / denom;
        });
      }
      var result = seriesValues.map(function(x4) {
        var row = {};
        row[asX] = x4;
        row[asY] = kernelSmoother(x4);
        return row;
      });
      dv.rows = result;
    }
    data_set_1.DataSet.registerTransform("kernel-smooth.regression", transform);
    data_set_1.DataSet.registerTransform("kernel.regression", transform);
    exports.default = {
      KERNEL_METHODS
    };
  }
});

// node_modules/@antv/data-set/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@antv/data-set/lib/index.js"(exports, module) {
    "use strict";
    require_geo();
    require_hierarchy();
    require_partition2();
    require_statistics();
    require_default();
    require_dsv();
    require_geo_graticule();
    require_geojson();
    require_graph();
    require_hexjson();
    require_hierarchy2();
    require_topojson();
    require_default2();
    require_filter();
    require_fold();
    require_map2();
    require_partition3();
    require_percent();
    require_pick();
    require_proportion();
    require_rename();
    require_reverse();
    require_sort();
    require_sort_by();
    require_subset();
    require_fill_rows();
    require_impute();
    require_aggregate();
    require_regression2();
    require_kde();
    require_hexagon();
    require_histogram();
    require_quantile();
    require_rectangle();
    require_centroid();
    require_projection();
    require_region();
    require_arc();
    require_dagre2();
    require_sankey();
    require_voronoi();
    require_cluster();
    require_compact_box2();
    require_dendrogram3();
    require_indented3();
    require_pack();
    require_partition4();
    require_tree();
    require_treemap();
    require_tag_cloud2();
    require_waffle();
    require_density();
    require_regression3();
    var data_set_1 = require_data_set();
    module.exports = data_set_1.DataSet;
  }
});

// dep:@antv_data-set
var antv_data_set_default = require_lib3();
export {
  antv_data_set_default as default
};
/*!
 * EventEmitter v5.2.9 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - https://oli.me.uk/
 * @preserve
 */
//# sourceMappingURL=@antv_data-set.js.map
